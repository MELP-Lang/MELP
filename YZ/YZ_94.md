# YZ_94: Nested Function Calls in String Interpolation

**Session:** YZ_94  
**Date:** 15 AralÄ±k 2025  
**Agent:** GitHub Copilot (Claude Opus 4.5)  
**Branch:** `phase18-array-support_YZ_74`

## ðŸŽ‰ Summary

Successfully implemented **nested function calls** in string interpolation expressions. This allows complex expressions like `${abs(min(x, y))}` and even triple-nested calls like `${abs(min(max(a, b), c))}`.

## What Was Implemented

### 1. Built-in Function Registration âœ…

**File:** `compiler/stage0/modules/functions/functions.c`

Added `min` and `max` to the builtin function list:
```c
// YZ_94: Min/Max functions for nested call support
if (strcmp(name, "min") == 0) return 1;
if (strcmp(name, "max") == 0) return 1;
```

### 2. Runtime Math Library âœ…

**New Files:**
- `runtime/stdlib/mlp_math.h`
- `runtime/stdlib/mlp_math.c`

```c
int64_t min(int64_t a, int64_t b) {
    return (a < b) ? a : b;
}

int64_t max(int64_t a, int64_t b) {
    return (a > b) ? a : b;
}
```

**Updated:** `runtime/stdlib/Makefile` - Added `mlp_math.c` to SOURCES

### 3. Codegen Fix for Nested Calls âœ…

**File:** `compiler/stage0/modules/arithmetic/arithmetic_codegen.c`

**Problem:** When evaluating multiple function call arguments, the parameter registers (`%rdi`, `%rsi`, etc.) were being clobbered by inner function calls.

**Example:** `max(abs(a), abs(c))`
- Old: `abs(a)` result in `%rdi`, then `abs(c)` call overwrites `%rdi` â†’ WRONG
- New: Both results pushed to stack first, then popped into parameter registers â†’ CORRECT

**Solution:** Two-phase argument evaluation:
```c
// Phase 1: Evaluate all arguments and push to stack (in order)
for (int i = 0; i < actual_arg_count; i++) {
    generate_expr_code(output, arg_expr, 2, func);  // Use r10
    fprintf(output, "    pushq %%r10  # Save arg %d\n", i + 1);
}

// Phase 2: Pop arguments into parameter registers (reverse order)
for (int i = actual_arg_count - 1; i >= 0; i--) {
    fprintf(output, "    popq %s  # Restore arg %d\n", param_regs[i], i + 1);
}
```

## Test Results âœ…

### Basic Nested Calls
```pmpl
-- test_expr_interp_nested.mlp
string result = "Result: ${abs(min(x, y))}"
-- Output: "Result: 10" âœ…
```

### Multiple Nested Calls
```pmpl
-- test_nested_calls_multi.mlp
Test1: ${abs(min(a, b))}     â†’ 15 âœ…  (abs(-15))
Test2: ${abs(max(a, c))}     â†’ 5 âœ…   (abs(-5))
Test3: ${max(abs(a), abs(c))} â†’ 15 âœ…  (max(15, 5))
Test4: ${min(abs(a), abs(b))} â†’ 15 âœ…  (min(15, 25))
```

### Triple Nested Calls
```pmpl
-- test_nested_calls_deep.mlp
Triple: ${abs(min(max(a, b), c))}  â†’ 5 âœ…   (abs(min(10, -5)) = abs(-5))
With arith: ${abs(min(a + b, c))}  â†’ 10 âœ…  (abs(min(-10, -5)) = abs(-10))
```

### Existing Tests (Regression Check) âœ…
- `test_expr_interp_basic.mlp` â†’ "Sum: 30" âœ…
- `test_expr_interp_func.mlp` â†’ "Absolute: 10" âœ…
- `test_expr_interp_length.mlp` â†’ "Length: 5" âœ…
- `test_expr_interp_paren.mlp` â†’ "Result: 60" âœ…
- `test_expr_interp_multi.mlp` â†’ "Sum: 30, Product: 200, Abs: 10" âœ…
- `test_for_loop_basic.mlp` â†’ Exit 15 âœ…
- `test_switch_basic.mlp` â†’ Exit 20 âœ…

## Files Modified

| File | Change |
|------|--------|
| `compiler/stage0/modules/functions/functions.c` | Added `min`, `max` to builtin list |
| `compiler/stage0/modules/arithmetic/arithmetic_codegen.c` | Two-phase argument evaluation for nested calls |
| `runtime/stdlib/Makefile` | Added `mlp_math.c` to sources |

## Files Created

| File | Purpose |
|------|---------|
| `runtime/stdlib/mlp_math.h` | Math function declarations |
| `runtime/stdlib/mlp_math.c` | `min`, `max`, `mlp_abs` implementations |
| `tests/manual/test_nested_calls_multi.mlp` | Multi nested call test |
| `tests/manual/test_nested_calls_deep.mlp` | Triple nested call test |

## Technical Details

### Assembly Output (Before Fix)
```asm
# max(abs(a), abs(c)) - WRONG
call abs
movq %rax, %rdi     # First arg in %rdi
call abs            # CLOBBERS %rdi!
movq %rax, %rsi
call max            # Wrong first arg
```

### Assembly Output (After Fix)
```asm
# max(abs(a), abs(c)) - CORRECT
call abs
pushq %rax          # Save first result
call abs
pushq %rax          # Save second result
popq %rsi           # Second arg
popq %rdi           # First arg
call max            # Correct args!
```

## Limitations

1. **Maximum 6 function arguments** (x86-64 register calling convention)
2. **No vararg functions** (printf-style not supported)
3. **Integer only** - Float nested calls would need `xmm` register handling

## Next Steps (YZ_95+)

- **Option B:** Float-to-String interpolation (`${pi}`)
- **Option C:** Enum types
- **Option D:** String methods in interpolation (`${name.upper()}`)

---

**Status:** âœ… Complete - Phase 22.3 Nested Function Calls
