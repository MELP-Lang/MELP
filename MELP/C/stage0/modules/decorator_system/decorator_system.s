; Generated by MLP Decorator System
; NASM x86-64 assembly

section .data
deprecated_msg: db 'WARNING: This function is deprecated!', 10, 0
cache_table: times 1024 dq 0  ; Cache storage

section .text
global _start

; @synchronized wrapper for critical_section
__synchronized_critical_section_wrapper:
    push rbp
    mov rbp, rsp
    
    ; Acquire lock (simplified - real impl would use mutex)
.acquire_lock:
    mov rax, 1
    lea rbx, [rel lock_critical_section]
    lock xchg [rbx], rax
    test rax, rax
    jnz .acquire_lock  ; Spin if lock taken
    
    ; Call original function
    call critical_section
    push rax
    
    ; Release lock
    lea rbx, [rel lock_critical_section]
    mov qword [rbx], 0
    
    pop rax
    pop rbp
    ret

section .data
lock_critical_section: dq 0
section .text

; @property getter for get_name
__property_get_name_wrapper:
    push rbp
    mov rbp, rsp
    
    ; Load property value from object (rdi = self)
    mov rax, [rdi]
    
    pop rbp
    ret

; @deprecated wrapper for old_algorithm
__deprecated_old_algorithm_wrapper:
    push rbp
    mov rbp, rsp
    
    ; Print deprecation warning
    lea rdi, [rel deprecated_msg]
    mov rax, 1  ; sys_write
    mov rsi, rdi
    mov rdi, 2  ; stderr
    mov rdx, 43 ; message length
    syscall
    
    ; Call original function
    call old_algorithm
    
    pop rbp
    ret

; @timeit wrapper for old_algorithm
__timeit_old_algorithm_wrapper:
    push rbp
    mov rbp, rsp
    push rbx
    
    ; Get start timestamp (RDTSC)
    rdtsc
    shl rdx, 32
    or rax, rdx
    mov rbx, rax  ; Save start time
    
    ; Call original function
    call old_algorithm
    push rax  ; Save return value
    
    ; Get end timestamp
    rdtsc
    shl rdx, 32
    or rax, rdx
    
    ; Calculate elapsed cycles
    sub rax, rbx
    ; Store elapsed in rdx for later use
    
    pop rax  ; Restore return value
    pop rbx
    pop rbp
    ret

; @cached wrapper for fibonacci
__cached_fibonacci_wrapper:
    push rbp
    mov rbp, rsp
    
    ; Hash function arguments (rdi) for cache key
    mov rax, rdi
    and rax, 0xFF  ; Simple hash: arg % 256
    
    ; Check cache
    lea rbx, [rel cache_table]
    mov rcx, [rbx + rax*8]
    test rcx, rcx
    jnz .cache_hit
    
    ; Cache miss - call original function
    call fibonacci
    
    ; Store result in cache
    mov [rbx + rax*8], rax
    jmp .done
    
.cache_hit:
    ; Return cached value
    mov rax, rcx
    
.done:
    pop rbp
    ret

