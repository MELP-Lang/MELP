/**
 * MODÃœL #57: DECORATOR_SYSTEM - Code Generation
 * 
 * Generates x86-64 assembly for decorated functions
 */

#include "decorator_system.h"

// ============================================================================
// ASSEMBLY GENERATION HELPERS
// ============================================================================

static void codegen_emit_header(FILE* out) {
    fprintf(out, "; Generated by MLP Decorator System\n");
    fprintf(out, "; NASM x86-64 assembly\n\n");
    fprintf(out, "section .data\n");
}

static void codegen_emit_data_section(FILE* out, DecoratorContext* ctx) {
    // Emit string constants for deprecation warnings
    bool has_deprecated = false;
    Decorator* current = ctx->decorators;
    while (current) {
        if (strcmp(current->name, "deprecated") == 0) {
            has_deprecated = true;
            break;
        }
        current = current->next;
    }
    
    if (has_deprecated) {
        fprintf(out, "deprecated_msg: db 'WARNING: This function is deprecated!', 10, 0\n");
    }
    
    // Emit cache table for @cached decorator
    bool has_cached = false;
    current = ctx->decorators;
    while (current) {
        if (strcmp(current->name, "cached") == 0) {
            has_cached = true;
            break;
        }
        current = current->next;
    }
    
    if (has_cached) {
        fprintf(out, "cache_table: times 1024 dq 0  ; Cache storage\n");
    }
    
    fprintf(out, "\nsection .text\n");
    fprintf(out, "global _start\n\n");
}

// ============================================================================
// DECORATOR CODE GENERATION
// ============================================================================

static void codegen_emit_cached_wrapper(FILE* out, Decorator* dec) {
    const char* wrapper = decorator_generate_wrapper_name(dec->target_name, "cached");
    
    fprintf(out, "; @cached wrapper for %s\n", dec->target_name);
    fprintf(out, "%s:\n", wrapper);
    fprintf(out, "    push rbp\n");
    fprintf(out, "    mov rbp, rsp\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Hash function arguments (rdi) for cache key\n");
    fprintf(out, "    mov rax, rdi\n");
    fprintf(out, "    and rax, 0xFF  ; Simple hash: arg %% 256\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Check cache\n");
    fprintf(out, "    lea rbx, [rel cache_table]\n");
    fprintf(out, "    mov rcx, [rbx + rax*8]\n");
    fprintf(out, "    test rcx, rcx\n");
    fprintf(out, "    jnz .cache_hit\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Cache miss - call original function\n");
    fprintf(out, "    call %s\n", dec->target_name);
    fprintf(out, "    \n");
    fprintf(out, "    ; Store result in cache\n");
    fprintf(out, "    mov [rbx + rax*8], rax\n");
    fprintf(out, "    jmp .done\n");
    fprintf(out, "    \n");
    fprintf(out, ".cache_hit:\n");
    fprintf(out, "    ; Return cached value\n");
    fprintf(out, "    mov rax, rcx\n");
    fprintf(out, "    \n");
    fprintf(out, ".done:\n");
    fprintf(out, "    pop rbp\n");
    fprintf(out, "    ret\n\n");
}

static void codegen_emit_timeit_wrapper(FILE* out, Decorator* dec) {
    const char* wrapper = decorator_generate_wrapper_name(dec->target_name, "timeit");
    
    fprintf(out, "; @timeit wrapper for %s\n", dec->target_name);
    fprintf(out, "%s:\n", wrapper);
    fprintf(out, "    push rbp\n");
    fprintf(out, "    mov rbp, rsp\n");
    fprintf(out, "    push rbx\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Get start timestamp (RDTSC)\n");
    fprintf(out, "    rdtsc\n");
    fprintf(out, "    shl rdx, 32\n");
    fprintf(out, "    or rax, rdx\n");
    fprintf(out, "    mov rbx, rax  ; Save start time\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Call original function\n");
    fprintf(out, "    call %s\n", dec->target_name);
    fprintf(out, "    push rax  ; Save return value\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Get end timestamp\n");
    fprintf(out, "    rdtsc\n");
    fprintf(out, "    shl rdx, 32\n");
    fprintf(out, "    or rax, rdx\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Calculate elapsed cycles\n");
    fprintf(out, "    sub rax, rbx\n");
    fprintf(out, "    ; Store elapsed in rdx for later use\n");
    fprintf(out, "    \n");
    fprintf(out, "    pop rax  ; Restore return value\n");
    fprintf(out, "    pop rbx\n");
    fprintf(out, "    pop rbp\n");
    fprintf(out, "    ret\n\n");
}

static void codegen_emit_deprecated_wrapper(FILE* out, Decorator* dec) {
    const char* wrapper = decorator_generate_wrapper_name(dec->target_name, "deprecated");
    
    fprintf(out, "; @deprecated wrapper for %s\n", dec->target_name);
    fprintf(out, "%s:\n", wrapper);
    fprintf(out, "    push rbp\n");
    fprintf(out, "    mov rbp, rsp\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Print deprecation warning\n");
    fprintf(out, "    lea rdi, [rel deprecated_msg]\n");
    fprintf(out, "    mov rax, 1  ; sys_write\n");
    fprintf(out, "    mov rsi, rdi\n");
    fprintf(out, "    mov rdi, 2  ; stderr\n");
    fprintf(out, "    mov rdx, 43 ; message length\n");
    fprintf(out, "    syscall\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Call original function\n");
    fprintf(out, "    call %s\n", dec->target_name);
    fprintf(out, "    \n");
    fprintf(out, "    pop rbp\n");
    fprintf(out, "    ret\n\n");
}

static void codegen_emit_property_getter(FILE* out, Decorator* dec) {
    const char* wrapper = decorator_generate_wrapper_name(dec->target_name, "property");
    
    fprintf(out, "; @property getter for %s\n", dec->target_name);
    fprintf(out, "%s:\n", wrapper);
    fprintf(out, "    push rbp\n");
    fprintf(out, "    mov rbp, rsp\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Load property value from object (rdi = self)\n");
    fprintf(out, "    mov rax, [rdi]\n");
    fprintf(out, "    \n");
    fprintf(out, "    pop rbp\n");
    fprintf(out, "    ret\n\n");
}

static void codegen_emit_synchronized_wrapper(FILE* out, Decorator* dec) {
    const char* wrapper = decorator_generate_wrapper_name(dec->target_name, "synchronized");
    
    fprintf(out, "; @synchronized wrapper for %s\n", dec->target_name);
    fprintf(out, "%s:\n", wrapper);
    fprintf(out, "    push rbp\n");
    fprintf(out, "    mov rbp, rsp\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Acquire lock (simplified - real impl would use mutex)\n");
    fprintf(out, ".acquire_lock:\n");
    fprintf(out, "    mov rax, 1\n");
    fprintf(out, "    lea rbx, [rel lock_%s]\n", dec->target_name);
    fprintf(out, "    lock xchg [rbx], rax\n");
    fprintf(out, "    test rax, rax\n");
    fprintf(out, "    jnz .acquire_lock  ; Spin if lock taken\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Call original function\n");
    fprintf(out, "    call %s\n", dec->target_name);
    fprintf(out, "    push rax\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Release lock\n");
    fprintf(out, "    lea rbx, [rel lock_%s]\n", dec->target_name);
    fprintf(out, "    mov qword [rbx], 0\n");
    fprintf(out, "    \n");
    fprintf(out, "    pop rax\n");
    fprintf(out, "    pop rbp\n");
    fprintf(out, "    ret\n\n");
    
    // Emit lock variable in data section
    fprintf(out, "section .data\n");
    fprintf(out, "lock_%s: dq 0\n", dec->target_name);
    fprintf(out, "section .text\n\n");
}

// ============================================================================
// MAIN CODEGEN
// ============================================================================

void decorator_codegen(DecoratorContext* ctx, FILE* out) {
    codegen_emit_header(out);
    codegen_emit_data_section(out, ctx);
    
    // Generate wrapper for each decorator
    Decorator* current = ctx->decorators;
    while (current) {
        if (decorator_is_builtin(current->name)) {
            BuiltinDecoratorType builtin = decorator_get_builtin_type(current->name);
            
            switch (builtin) {
                case BUILTIN_CACHED:
                    codegen_emit_cached_wrapper(out, current);
                    break;
                case BUILTIN_TIMEIT:
                    codegen_emit_timeit_wrapper(out, current);
                    break;
                case BUILTIN_DEPRECATED:
                    codegen_emit_deprecated_wrapper(out, current);
                    break;
                case BUILTIN_PROPERTY:
                    codegen_emit_property_getter(out, current);
                    break;
                case BUILTIN_SYNCHRONIZED:
                    codegen_emit_synchronized_wrapper(out, current);
                    break;
                default:
                    // Generic wrapper
                    decorator_generate_wrapper(ctx, current, out);
                    break;
            }
        }
        
        current = current->next;
    }
}

void decorator_codegen_to_file(DecoratorContext* ctx, const char* filename) {
    FILE* out = fopen(filename, "w");
    if (!out) {
        fprintf(stderr, "Error: Cannot open output file %s\n", filename);
        return;
    }
    
    decorator_codegen(ctx, out);
    fclose(out);
}

// ============================================================================
// DECORATOR INLINING
// ============================================================================

void decorator_inline_call(FILE* out, Decorator* dec, const char* args) {
    fprintf(out, "    ; Inlined decorator @%s\n", dec->name);
    
    if (strcmp(dec->name, "timeit") == 0) {
        fprintf(out, "    rdtsc\n");
        fprintf(out, "    push rax\n");
        fprintf(out, "    call %s\n", dec->target_name);
        fprintf(out, "    rdtsc\n");
        fprintf(out, "    pop rbx\n");
        fprintf(out, "    sub rax, rbx  ; elapsed cycles\n");
    } else {
        // Default: call wrapper
        const char* wrapper = decorator_generate_wrapper_name(dec->target_name, dec->name);
        fprintf(out, "    call %s\n", wrapper);
    }
}
