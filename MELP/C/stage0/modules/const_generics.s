; Generated by MLP Const Generics System
; NASM x86-64 assembly

section .data
type_count: dq 2
instance_count: dq 5

section .text
global _start

; Array type: Array_i32_1024
section .bss
Array_i32_1024_data: resb 8192  ; Array of 1024 elements
Array_i32_1024_size: dq 1024

; Array get function for Array_i32_1024
section .text
Array_i32_1024_get:
    ; rdi = array pointer, rsi = index
    ; Bounds check
    mov rax, [rel Array_i32_1024_size]
    cmp rsi, rax
    jae .out_of_bounds
    
    ; Calculate offset and load
    shl rsi, 3  ; index * 8 (element size)
    lea rax, [rel Array_i32_1024_data]
    add rax, rsi
    mov rax, [rax]
    ret
    
.out_of_bounds:
    xor rax, rax  ; Return 0 on error
    ret

; Array set function for Array_i32_1024
section .text
Array_i32_1024_set:
    ; rdi = array pointer, rsi = index, rdx = value
    ; Bounds check
    mov rax, [rel Array_i32_1024_size]
    cmp rsi, rax
    jae .out_of_bounds
    
    ; Calculate offset and store
    shl rsi, 3  ; index * 8
    lea rax, [rel Array_i32_1024_data]
    add rax, rsi
    mov [rax], rdx
    mov rax, 1  ; Success
    ret
    
.out_of_bounds:
    xor rax, rax  ; Return 0 on error
    ret

; Matrix type: Matrix_f64_4_4
section .bss
Matrix_f64_4_4_data: resb 128  ; Matrix 4x4
Matrix_f64_4_4_rows: dq 4
Matrix_f64_4_4_cols: dq 4

; Matrix get function for Matrix_f64_4_4
section .text
Matrix_f64_4_4_get:
    ; rdi = matrix pointer, rsi = row, rdx = col
    ; Calculate: row * cols + col
    mov rax, [rel Matrix_f64_4_4_cols]
    imul rsi, rax
    add rsi, rdx
    
    ; Load element
    shl rsi, 3  ; * 8
    lea rax, [rel Matrix_f64_4_4_data]
    add rax, rsi
    mov rax, [rax]
    ret

; Array type: Array_i32_256
section .bss
Array_i32_256_data: resb 2048  ; Array of 256 elements
Array_i32_256_size: dq 256

; Array get function for Array_i32_256
section .text
Array_i32_256_get:
    ; rdi = array pointer, rsi = index
    ; Bounds check
    mov rax, [rel Array_i32_256_size]
    cmp rsi, rax
    jae .out_of_bounds
    
    ; Calculate offset and load
    shl rsi, 3  ; index * 8 (element size)
    lea rax, [rel Array_i32_256_data]
    add rax, rsi
    mov rax, [rax]
    ret
    
.out_of_bounds:
    xor rax, rax  ; Return 0 on error
    ret

; Array set function for Array_i32_256
section .text
Array_i32_256_set:
    ; rdi = array pointer, rsi = index, rdx = value
    ; Bounds check
    mov rax, [rel Array_i32_256_size]
    cmp rsi, rax
    jae .out_of_bounds
    
    ; Calculate offset and store
    shl rsi, 3  ; index * 8
    lea rax, [rel Array_i32_256_data]
    add rax, rsi
    mov [rax], rdx
    mov rax, 1  ; Success
    ret
    
.out_of_bounds:
    xor rax, rax  ; Return 0 on error
    ret

; Array type: Array_f64_20
section .bss
Array_f64_20_data: resb 160  ; Array of 20 elements
Array_f64_20_size: dq 20

; Array get function for Array_f64_20
section .text
Array_f64_20_get:
    ; rdi = array pointer, rsi = index
    ; Bounds check
    mov rax, [rel Array_f64_20_size]
    cmp rsi, rax
    jae .out_of_bounds
    
    ; Calculate offset and load
    shl rsi, 3  ; index * 8 (element size)
    lea rax, [rel Array_f64_20_data]
    add rax, rsi
    mov rax, [rax]
    ret
    
.out_of_bounds:
    xor rax, rax  ; Return 0 on error
    ret

; Array set function for Array_f64_20
section .text
Array_f64_20_set:
    ; rdi = array pointer, rsi = index, rdx = value
    ; Bounds check
    mov rax, [rel Array_f64_20_size]
    cmp rsi, rax
    jae .out_of_bounds
    
    ; Calculate offset and store
    shl rsi, 3  ; index * 8
    lea rax, [rel Array_f64_20_data]
    add rax, rsi
    mov [rax], rdx
    mov rax, 1  ; Success
    ret
    
.out_of_bounds:
    xor rax, rax  ; Return 0 on error
    ret

; Array type: Array_i32_10
section .bss
Array_i32_10_data: resb 80  ; Array of 10 elements
Array_i32_10_size: dq 10

; Array get function for Array_i32_10
section .text
Array_i32_10_get:
    ; rdi = array pointer, rsi = index
    ; Bounds check
    mov rax, [rel Array_i32_10_size]
    cmp rsi, rax
    jae .out_of_bounds
    
    ; Calculate offset and load
    shl rsi, 3  ; index * 8 (element size)
    lea rax, [rel Array_i32_10_data]
    add rax, rsi
    mov rax, [rax]
    ret
    
.out_of_bounds:
    xor rax, rax  ; Return 0 on error
    ret

; Array set function for Array_i32_10
section .text
Array_i32_10_set:
    ; rdi = array pointer, rsi = index, rdx = value
    ; Bounds check
    mov rax, [rel Array_i32_10_size]
    cmp rsi, rax
    jae .out_of_bounds
    
    ; Calculate offset and store
    shl rsi, 3  ; index * 8
    lea rax, [rel Array_i32_10_data]
    add rax, rsi
    mov [rax], rdx
    mov rax, 1  ; Success
    ret
    
.out_of_bounds:
    xor rax, rax  ; Return 0 on error
    ret

_start:
    ; Const generics initialized
    mov rax, 60  ; sys_exit
    xor rdi, rdi
    syscall
