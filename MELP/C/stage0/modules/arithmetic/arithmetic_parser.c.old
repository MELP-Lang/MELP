#include "arithmetic_parser.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Expression parsing for arithmetic operations
// Stage 1: Full implementation using recursive descent with precedence climbing

void expression_free(Expression* expr) {
    if (!expr) return;
    
    if (expr->type == EXPR_VARIABLE) {
        free(expr->data.var_name);
    } else if (expr->type == EXPR_STRING) {
        free(expr->data.string_value);
    } else if (expr->type == EXPR_BINARY_OP) {
        expression_free(expr->data.binary.left);
        expression_free(expr->data.binary.right);
    } else if (expr->type == EXPR_CALL) {
        free(expr->data.call.func_name);
        for (int i = 0; i < expr->data.call.arg_count; i++) {
            expression_free(expr->data.call.args[i]);
        }
        free(expr->data.call.args);
    }
    
    free(expr);
}

// Helper: Advance to next token
static void advance(Parser* parser) {
    if (parser->current_token) {
        token_free(parser->current_token);
    }
    parser->current_token = lexer_next_token(parser->lexer);
}

// Helper: Check if current token matches expected type
static int match(Parser* parser, TokenType type) {
    return parser->current_token && parser->current_token->type == type;
}

// Helper: Parse primary expression (number, variable, function call, or parenthesized expression)
static Expression* parse_primary(Parser* parser) {
    Expression* expr = malloc(sizeof(Expression));
    
    // Number literal
    if (match(parser, TOKEN_NUMBER)) {
        expr->type = EXPR_NUMBER;
        expr->data.number_value = atol(parser->current_token->value);
        advance(parser);
        return expr;
    }
    
    // Variable reference or function call
    if (match(parser, TOKEN_IDENTIFIER)) {
        char* name = strdup(parser->current_token->value);
        advance(parser);
        
        // Check for function call: name(args)
        if (match(parser, TOKEN_LPAREN)) {
            advance(parser);  // consume '('
            
            expr->type = EXPR_CALL;
            expr->data.call.func_name = name;
            expr->data.call.args = NULL;
            expr->data.call.arg_count = 0;
            
            // Parse arguments
            if (!match(parser, TOKEN_RPAREN)) {
                int arg_capacity = 4;
                expr->data.call.args = malloc(sizeof(Expression*) * arg_capacity);
                
                // Parse first argument
                Expression* arg = expression_parse(parser);
                if (arg) {
                    expr->data.call.args[expr->data.call.arg_count++] = arg;
                }
                
                // Parse remaining arguments
                while (match(parser, TOKEN_COMMA)) {
                    advance(parser);  // consume ','
                    arg = expression_parse(parser);
                    if (arg) {
                        if (expr->data.call.arg_count >= arg_capacity) {
                            arg_capacity *= 2;
                            expr->data.call.args = realloc(expr->data.call.args,
                                                          sizeof(Expression*) * arg_capacity);
                        }
                        expr->data.call.args[expr->data.call.arg_count++] = arg;
                    }
                }
            }
            
            if (match(parser, TOKEN_RPAREN)) {
                advance(parser);  // consume ')'
            }
            
            return expr;
        }
        
        // Just a variable
        expr->type = EXPR_VARIABLE;
        expr->data.var_name = name;
        return expr;
    }
    
    // Parenthesized expression: (expr)
    if (match(parser, TOKEN_LPAREN)) {
        advance(parser);  // consume '('
        free(expr);
        expr = expression_parse(parser);
        if (!match(parser, TOKEN_RPAREN)) {
            fprintf(stderr, "Error: Expected ')' after expression\n");
            expression_free(expr);
            return NULL;
        }
        advance(parser);  // consume ')'
        return expr;
    }
    
    // String literal
    if (match(parser, TOKEN_STRING)) {
        expr->type = EXPR_STRING;
        expr->data.string_value = strdup(parser->current_token->value);
        advance(parser);
        return expr;
    }
    
    // Unary minus: -expr
    if (match(parser, TOKEN_MINUS)) {
        advance(parser);  // consume '-'
        Expression* operand = parse_primary(parser);
        if (!operand) {
            free(expr);
            return NULL;
        }
        
        // Convert to binary: 0 - operand
        expr->type = EXPR_BINARY_OP;
        Expression* zero = malloc(sizeof(Expression));
        zero->type = EXPR_NUMBER;
        zero->data.number_value = 0;
        
        expr->data.binary.left = zero;
        expr->data.binary.right = operand;
        expr->data.binary.op = BIN_OP_SUB;
        return expr;
    }
    
    // Error: unexpected token
    fprintf(stderr, "Error: Unexpected token in expression: %d\n", 
            parser->current_token ? parser->current_token->type : -1);
    free(expr);
    return NULL;
}

// Helper: Get operator precedence (higher = tighter binding)
static int get_precedence(TokenType type) {
    switch (type) {
        case TOKEN_MULTIPLY:
        case TOKEN_DIVIDE:
            return 2;  // * and / have higher precedence
        case TOKEN_PLUS:
        case TOKEN_MINUS:
            return 1;  // + and - have lower precedence
        default:
            return 0;  // Not an operator
    }
}

// Helper: Convert token type to BinaryOp
static BinaryOp token_to_binop(TokenType type) {
    switch (type) {
        case TOKEN_PLUS:     return BIN_OP_ADD;
        case TOKEN_MINUS:    return BIN_OP_SUB;
        case TOKEN_MULTIPLY: return BIN_OP_MUL;
        case TOKEN_DIVIDE:   return BIN_OP_DIV;
        default:
            fprintf(stderr, "Error: Unknown operator token type: %d\n", type);
            return BIN_OP_ADD;  // fallback
    }
}

// Main expression parser using precedence climbing
// Parses: primary ( op primary )*
Expression* expression_parse(Parser* parser) {
    // Parse left operand
    Expression* left = parse_primary(parser);
    if (!left) return NULL;
    
    // Parse operators and right operands with precedence
    while (parser->current_token) {
        TokenType op_type = parser->current_token->type;
        int prec = get_precedence(op_type);
        
        if (prec == 0) break;  // Not an operator, stop parsing
        
        advance(parser);  // consume operator
        
        // Parse right operand
        Expression* right = parse_primary(parser);
        if (!right) {
            expression_free(left);
            return NULL;
        }
        
        // Handle right-associative operators (look ahead)
        while (parser->current_token) {
            int next_prec = get_precedence(parser->current_token->type);
            if (next_prec <= prec) break;  // Lower or equal precedence, stop
            
            // Higher precedence: right side becomes a subtree
            TokenType next_op = parser->current_token->type;
            advance(parser);
            
            Expression* next_right = parse_primary(parser);
            if (!next_right) {
                expression_free(left);
                expression_free(right);
                return NULL;
            }
            
            // Build right subtree
            Expression* subtree = malloc(sizeof(Expression));
            subtree->type = EXPR_BINARY_OP;
            subtree->data.binary.left = right;
            subtree->data.binary.right = next_right;
            subtree->data.binary.op = token_to_binop(next_op);
            right = subtree;
        }
        
        // Build binary operation node
        Expression* binary = malloc(sizeof(Expression));
        binary->type = EXPR_BINARY_OP;
        binary->data.binary.left = left;
        binary->data.binary.right = right;
        binary->data.binary.op = token_to_binop(op_type);
        left = binary;
    }
    
    return left;
}
