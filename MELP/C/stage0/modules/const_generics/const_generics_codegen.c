/**
 * MODÃœL #58: CONST_GENERICS - Code Generation
 * 
 * Generates x86-64 assembly for const generic types
 */

#define _GNU_SOURCE
#include "const_generics.h"

// ============================================================================
// ASSEMBLY GENERATION HELPERS
// ============================================================================

static void codegen_emit_header(FILE* out) {
    fprintf(out, "; Generated by MLP Const Generics System\n");
    fprintf(out, "; NASM x86-64 assembly\n\n");
    fprintf(out, "section .data\n");
}

static void codegen_emit_data_section(FILE* out, ConstGenericContext* ctx) {
    // Emit type information
    fprintf(out, "type_count: dq %d\n", ctx->type_count);
    fprintf(out, "instance_count: dq %d\n", ctx->instance_count);
    fprintf(out, "\n");
}

// ============================================================================
// CONST ARRAY CODE GENERATION
// ============================================================================

static void codegen_emit_array_type(FILE* out, ConstGenericInstance* inst) {
    if (strcmp(inst->generic_type->base_type, "Array") != 0) {
        return;
    }
    
    fprintf(out, "; Array type: %s\n", inst->mangled_name);
    fprintf(out, "section .bss\n");
    
    // Get array size from const arg
    uint64_t size = inst->const_args[0]->value.usize_val;
    
    // Calculate element size (assume 8 bytes for now)
    uint64_t element_size = 8;
    uint64_t total_bytes = size * element_size;
    
    fprintf(out, "%s_data: resb %lu  ; Array of %lu elements\n", 
            inst->mangled_name, total_bytes, size);
    fprintf(out, "%s_size: dq %lu\n", inst->mangled_name, size);
    fprintf(out, "\n");
}

// ============================================================================
// CONST GENERIC ACCESSORS
// ============================================================================

static void codegen_emit_array_get(FILE* out, ConstGenericInstance* inst) {
    fprintf(out, "; Array get function for %s\n", inst->mangled_name);
    fprintf(out, "section .text\n");
    fprintf(out, "%s_get:\n", inst->mangled_name);
    fprintf(out, "    ; rdi = array pointer, rsi = index\n");
    fprintf(out, "    ; Bounds check\n");
    fprintf(out, "    mov rax, [rel %s_size]\n", inst->mangled_name);
    fprintf(out, "    cmp rsi, rax\n");
    fprintf(out, "    jae .out_of_bounds\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Calculate offset and load\n");
    fprintf(out, "    shl rsi, 3  ; index * 8 (element size)\n");
    fprintf(out, "    lea rax, [rel %s_data]\n", inst->mangled_name);
    fprintf(out, "    add rax, rsi\n");
    fprintf(out, "    mov rax, [rax]\n");
    fprintf(out, "    ret\n");
    fprintf(out, "    \n");
    fprintf(out, ".out_of_bounds:\n");
    fprintf(out, "    xor rax, rax  ; Return 0 on error\n");
    fprintf(out, "    ret\n\n");
}

static void codegen_emit_array_set(FILE* out, ConstGenericInstance* inst) {
    fprintf(out, "; Array set function for %s\n", inst->mangled_name);
    fprintf(out, "section .text\n");
    fprintf(out, "%s_set:\n", inst->mangled_name);
    fprintf(out, "    ; rdi = array pointer, rsi = index, rdx = value\n");
    fprintf(out, "    ; Bounds check\n");
    fprintf(out, "    mov rax, [rel %s_size]\n", inst->mangled_name);
    fprintf(out, "    cmp rsi, rax\n");
    fprintf(out, "    jae .out_of_bounds\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Calculate offset and store\n");
    fprintf(out, "    shl rsi, 3  ; index * 8\n");
    fprintf(out, "    lea rax, [rel %s_data]\n", inst->mangled_name);
    fprintf(out, "    add rax, rsi\n");
    fprintf(out, "    mov [rax], rdx\n");
    fprintf(out, "    mov rax, 1  ; Success\n");
    fprintf(out, "    ret\n");
    fprintf(out, "    \n");
    fprintf(out, ".out_of_bounds:\n");
    fprintf(out, "    xor rax, rax  ; Return 0 on error\n");
    fprintf(out, "    ret\n\n");
}

// ============================================================================
// MATRIX CODE GENERATION
// ============================================================================

static void codegen_emit_matrix_type(FILE* out, ConstGenericInstance* inst) {
    if (strcmp(inst->generic_type->base_type, "Matrix") != 0) {
        return;
    }
    
    fprintf(out, "; Matrix type: %s\n", inst->mangled_name);
    fprintf(out, "section .bss\n");
    
    // Get dimensions from const args
    uint64_t rows = inst->const_args[0]->value.usize_val;
    uint64_t cols = inst->const_args[1]->value.usize_val;
    uint64_t total_size = rows * cols * 8; // 8 bytes per element
    
    fprintf(out, "%s_data: resb %lu  ; Matrix %lux%lu\n", 
            inst->mangled_name, total_size, rows, cols);
    fprintf(out, "%s_rows: dq %lu\n", inst->mangled_name, rows);
    fprintf(out, "%s_cols: dq %lu\n", inst->mangled_name, cols);
    fprintf(out, "\n");
}

static void codegen_emit_matrix_get(FILE* out, ConstGenericInstance* inst) {
    fprintf(out, "; Matrix get function for %s\n", inst->mangled_name);
    fprintf(out, "section .text\n");
    fprintf(out, "%s_get:\n", inst->mangled_name);
    fprintf(out, "    ; rdi = matrix pointer, rsi = row, rdx = col\n");
    fprintf(out, "    ; Calculate: row * cols + col\n");
    fprintf(out, "    mov rax, [rel %s_cols]\n", inst->mangled_name);
    fprintf(out, "    imul rsi, rax\n");
    fprintf(out, "    add rsi, rdx\n");
    fprintf(out, "    \n");
    fprintf(out, "    ; Load element\n");
    fprintf(out, "    shl rsi, 3  ; * 8\n");
    fprintf(out, "    lea rax, [rel %s_data]\n", inst->mangled_name);
    fprintf(out, "    add rax, rsi\n");
    fprintf(out, "    mov rax, [rax]\n");
    fprintf(out, "    ret\n\n");
}

// ============================================================================
// MAIN CODEGEN
// ============================================================================

void const_generic_codegen(ConstGenericContext* ctx, FILE* out) {
    codegen_emit_header(out);
    codegen_emit_data_section(out, ctx);
    
    fprintf(out, "section .text\n");
    fprintf(out, "global _start\n\n");
    
    // Generate code for each instance
    ConstGenericInstance* current = ctx->instances;
    while (current) {
        if (strcmp(current->generic_type->base_type, "Array") == 0) {
            codegen_emit_array_type(out, current);
            codegen_emit_array_get(out, current);
            codegen_emit_array_set(out, current);
        } else if (strcmp(current->generic_type->base_type, "Matrix") == 0) {
            codegen_emit_matrix_type(out, current);
            codegen_emit_matrix_get(out, current);
        }
        
        current = current->next;
    }
    
    // Emit main entry point
    fprintf(out, "_start:\n");
    fprintf(out, "    ; Const generics initialized\n");
    fprintf(out, "    mov rax, 60  ; sys_exit\n");
    fprintf(out, "    xor rdi, rdi\n");
    fprintf(out, "    syscall\n");
}

void const_generic_codegen_to_file(ConstGenericContext* ctx, const char* filename) {
    FILE* out = fopen(filename, "w");
    if (!out) {
        fprintf(stderr, "Error: Cannot open output file %s\n", filename);
        return;
    }
    
    const_generic_codegen(ctx, out);
    fclose(out);
}

// ============================================================================
// SIZE CALCULATION
// ============================================================================

uint64_t const_generic_calculate_size(ConstGenericInstance* inst) {
    if (strcmp(inst->generic_type->base_type, "Array") == 0) {
        uint64_t count = inst->const_args[0]->value.usize_val;
        return count * 8; // Assume 8 bytes per element
    } else if (strcmp(inst->generic_type->base_type, "Matrix") == 0) {
        uint64_t rows = inst->const_args[0]->value.usize_val;
        uint64_t cols = inst->const_args[1]->value.usize_val;
        return rows * cols * 8;
    }
    return 0;
}

// ============================================================================
// LAYOUT GENERATION
// ============================================================================

void const_generic_emit_layout_info(ConstGenericInstance* inst, FILE* out) {
    fprintf(out, "; Layout for %s\n", inst->mangled_name);
    fprintf(out, ";   Type: %s<%s", 
            inst->generic_type->base_type, 
            inst->concrete_type);
    
    for (int i = 0; i < inst->const_arg_count; i++) {
        char* val_str = const_value_to_string(inst->const_args[i]);
        fprintf(out, ", %s", val_str);
        free(val_str);
    }
    fprintf(out, ">\n");
    
    uint64_t size = const_generic_calculate_size(inst);
    fprintf(out, ";   Size: %lu bytes\n", size);
    fprintf(out, ";   Valid: %s\n\n", inst->is_valid ? "yes" : "no");
}
