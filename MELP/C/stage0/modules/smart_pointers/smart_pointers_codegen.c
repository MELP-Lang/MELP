#include "smart_pointers.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

// ============================================================================
// MLP SMART POINTER CODEGEN - MODULE #51
// ============================================================================
// Generates NASM x86-64 assembly for smart pointer operations
// Includes atomic instructions (lock prefix) for Arc<T>

// Forward declarations from parser
typedef enum {
    SP_OP_PARSE_RC_NEW,
    SP_OP_PARSE_RC_CLONE,
    SP_OP_PARSE_RC_DROP,
    SP_OP_PARSE_RC_DOWNGRADE,
    SP_OP_PARSE_ARC_NEW,
    SP_OP_PARSE_ARC_CLONE,
    SP_OP_PARSE_ARC_DROP,
    SP_OP_PARSE_ARC_DOWNGRADE,
    SP_OP_PARSE_BOX_NEW,
    SP_OP_PARSE_BOX_DROP,
    SP_OP_PARSE_WEAK_UPGRADE,
    SP_OP_PARSE_WEAK_DROP,
    SP_OP_PARSE_UNKNOWN
} SmartPointerOpKind;

typedef struct {
    SmartPointerKind kind;
    char* var_name;
    char* inner_type;
    char* init_expr;
} SmartPointerDecl;

typedef struct {
    SmartPointerOpKind op_kind;
    char* target_var;
    char* arg;
} SmartPointerOp;

typedef struct {
    SmartPointerDecl** declarations;
    size_t decl_count;
    SmartPointerOp** operations;
    size_t op_count;
} SmartPointerParseResult;

// ============================================================================
// CODEGEN CONTEXT
// ============================================================================

typedef struct {
    FILE* output;
    size_t label_counter;
} CodegenContext;

static CodegenContext* codegen_create(FILE* output) {
    CodegenContext* ctx = (CodegenContext*)malloc(sizeof(CodegenContext));
    ctx->output = output;
    ctx->label_counter = 0;
    return ctx;
}

static void codegen_destroy(CodegenContext* ctx) {
    free(ctx);
}

static char* codegen_new_label(CodegenContext* ctx, const char* prefix) {
    char* label = (char*)malloc(64);
    snprintf(label, 64, "%s_%zu", prefix, ctx->label_counter++);
    return label;
}

// ============================================================================
// ASSEMBLY GENERATION HELPERS
// ============================================================================

static void emit(CodegenContext* ctx, const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vfprintf(ctx->output, fmt, args);
    va_end(args);
    fprintf(ctx->output, "\n");
}

static void emit_comment(CodegenContext* ctx, const char* comment) {
    emit(ctx, "    ; %s", comment);
}

static void emit_header(CodegenContext* ctx) {
    emit(ctx, "; Generated by MLP Smart Pointers System");
    emit(ctx, "; NASM x86-64 assembly");
    emit(ctx, "");
    emit(ctx, "section .data");
}

static void emit_bss_section(CodegenContext* ctx, SmartPointerParseResult* parse_result) {
    emit(ctx, "");
    emit(ctx, "section .bss");
    
    for (size_t i = 0; i < parse_result->decl_count; i++) {
        SmartPointerDecl* decl = parse_result->declarations[i];
        
        // Reserve space for smart pointer (8 bytes for pointer)
        emit(ctx, "    %s: resq 1    ; %s<%s>", 
             decl->var_name,
             decl->kind == SP_RC ? "Rc" :
             decl->kind == SP_ARC ? "Arc" :
             decl->kind == SP_BOX ? "Box" : "Weak",
             decl->inner_type);
    }
}

// ============================================================================
// Rc<T> CODEGEN
// ============================================================================

static void codegen_rc_new(CodegenContext* ctx, const char* var_name, const char* type_name) {
    emit_comment(ctx, "Rc::new()");
    
    // Allocate RcInner
    emit(ctx, "    mov rdi, %zu    ; sizeof(RcInner)", sizeof(RcInner));
    emit(ctx, "    call malloc");
    emit(ctx, "    mov [%s], rax    ; Store inner pointer", var_name);
    
    // Initialize strong_count = 1
    emit(ctx, "    mov qword [rax], 1    ; strong_count = 1");
    
    // Initialize weak_count = 0
    emit(ctx, "    mov qword [rax + 8], 0    ; weak_count = 0");
}

static void codegen_rc_clone(CodegenContext* ctx, const char* var_name) {
    char* skip_label = codegen_new_label(ctx, "rc_clone_skip");
    
    emit_comment(ctx, "Rc::clone() - increment strong_count");
    
    // Load inner pointer
    emit(ctx, "    mov rax, [%s]    ; Load inner pointer", var_name);
    
    // Check if NULL
    emit(ctx, "    test rax, rax");
    emit(ctx, "    jz %s    ; Skip if NULL", skip_label);
    
    // Increment strong_count
    emit(ctx, "    inc qword [rax]    ; strong_count++");
    
    emit(ctx, "%s:", skip_label);
    free(skip_label);
}

static void codegen_rc_drop(CodegenContext* ctx, const char* var_name) {
    char* skip_label = codegen_new_label(ctx, "rc_drop_skip");
    char* free_data_label = codegen_new_label(ctx, "rc_drop_free_data");
    char* free_inner_label = codegen_new_label(ctx, "rc_drop_free_inner");
    
    emit_comment(ctx, "Rc::drop() - decrement strong_count");
    
    // Load inner pointer
    emit(ctx, "    mov rax, [%s]    ; Load inner pointer", var_name);
    
    // Check if NULL
    emit(ctx, "    test rax, rax");
    emit(ctx, "    jz %s    ; Skip if NULL", skip_label);
    
    // Decrement strong_count
    emit(ctx, "    dec qword [rax]    ; strong_count--");
    
    // Check if strong_count == 0
    emit(ctx, "    cmp qword [rax], 0");
    emit(ctx, "    je %s    ; Free data if last strong ref", free_data_label);
    emit(ctx, "    jmp %s", skip_label);
    
    // Free data
    emit(ctx, "%s:", free_data_label);
    emit(ctx, "    mov rdi, [rax + 16]    ; Load data pointer");
    emit(ctx, "    call free    ; Free data");
    
    // Check if weak_count == 0
    emit(ctx, "    mov rax, [%s]    ; Reload inner pointer", var_name);
    emit(ctx, "    cmp qword [rax + 8], 0    ; Check weak_count");
    emit(ctx, "    je %s    ; Free inner if no weak refs", free_inner_label);
    emit(ctx, "    jmp %s", skip_label);
    
    // Free inner
    emit(ctx, "%s:", free_inner_label);
    emit(ctx, "    mov rdi, rax    ; inner pointer");
    emit(ctx, "    call free    ; Free inner");
    
    emit(ctx, "%s:", skip_label);
    
    free(skip_label);
    free(free_data_label);
    free(free_inner_label);
}

// ============================================================================
// Arc<T> CODEGEN (Atomic Operations)
// ============================================================================

static void codegen_arc_new(CodegenContext* ctx, const char* var_name, const char* type_name) {
    emit_comment(ctx, "Arc::new() - atomic reference counting");
    
    // Allocate ArcInner
    emit(ctx, "    mov rdi, %zu    ; sizeof(ArcInner)", sizeof(ArcInner));
    emit(ctx, "    call malloc");
    emit(ctx, "    mov [%s], rax    ; Store inner pointer", var_name);
    
    // Initialize strong_count = 1 (atomic)
    emit(ctx, "    mov qword [rax], 1    ; strong_count = 1");
    
    // Initialize weak_count = 0 (atomic)
    emit(ctx, "    mov qword [rax + 8], 0    ; weak_count = 0");
}

static void codegen_arc_clone(CodegenContext* ctx, const char* var_name) {
    char* skip_label = codegen_new_label(ctx, "arc_clone_skip");
    
    emit_comment(ctx, "Arc::clone() - atomic increment strong_count");
    
    // Load inner pointer
    emit(ctx, "    mov rax, [%s]    ; Load inner pointer", var_name);
    
    // Check if NULL
    emit(ctx, "    test rax, rax");
    emit(ctx, "    jz %s    ; Skip if NULL", skip_label);
    
    // Atomic increment strong_count
    emit(ctx, "    lock inc qword [rax]    ; Atomic strong_count++");
    
    emit(ctx, "%s:", skip_label);
    free(skip_label);
}

static void codegen_arc_drop(CodegenContext* ctx, const char* var_name) {
    char* skip_label = codegen_new_label(ctx, "arc_drop_skip");
    char* free_data_label = codegen_new_label(ctx, "arc_drop_free_data");
    char* free_inner_label = codegen_new_label(ctx, "arc_drop_free_inner");
    
    emit_comment(ctx, "Arc::drop() - atomic decrement strong_count");
    
    // Load inner pointer
    emit(ctx, "    mov rax, [%s]    ; Load inner pointer", var_name);
    
    // Check if NULL
    emit(ctx, "    test rax, rax");
    emit(ctx, "    jz %s    ; Skip if NULL", skip_label);
    
    // Atomic decrement strong_count
    emit(ctx, "    mov rbx, rax    ; Save inner pointer");
    emit(ctx, "    mov rcx, 1");
    emit(ctx, "    lock xadd [rax], rcx    ; Atomic fetch_sub");
    
    // rcx now contains old value, check if it was 1
    emit(ctx, "    cmp rcx, 1");
    emit(ctx, "    je %s    ; Free data if last strong ref", free_data_label);
    emit(ctx, "    jmp %s", skip_label);
    
    // Free data
    emit(ctx, "%s:", free_data_label);
    emit(ctx, "    mov rdi, [rbx + 16]    ; Load data pointer");
    emit(ctx, "    call free    ; Free data");
    
    // Check if weak_count == 0 (atomic load)
    emit(ctx, "    mov rcx, [rbx + 8]    ; Atomic load weak_count");
    emit(ctx, "    test rcx, rcx");
    emit(ctx, "    jz %s    ; Free inner if no weak refs", free_inner_label);
    emit(ctx, "    jmp %s", skip_label);
    
    // Free inner
    emit(ctx, "%s:", free_inner_label);
    emit(ctx, "    mov rdi, rbx    ; inner pointer");
    emit(ctx, "    call free    ; Free inner");
    
    emit(ctx, "%s:", skip_label);
    
    free(skip_label);
    free(free_data_label);
    free(free_inner_label);
}

// ============================================================================
// Box<T> CODEGEN
// ============================================================================

static void codegen_box_new(CodegenContext* ctx, const char* var_name, const char* type_name) {
    emit_comment(ctx, "Box::new() - heap allocation");
    
    // Allocate Box
    emit(ctx, "    mov rdi, %zu    ; sizeof(Box)", sizeof(Box));
    emit(ctx, "    call malloc");
    emit(ctx, "    mov [%s], rax    ; Store box pointer", var_name);
}

static void codegen_box_drop(CodegenContext* ctx, const char* var_name) {
    char* skip_label = codegen_new_label(ctx, "box_drop_skip");
    
    emit_comment(ctx, "Box::drop() - free heap memory");
    
    // Load box pointer
    emit(ctx, "    mov rax, [%s]    ; Load box pointer", var_name);
    
    // Check if NULL
    emit(ctx, "    test rax, rax");
    emit(ctx, "    jz %s    ; Skip if NULL", skip_label);
    
    // Free data
    emit(ctx, "    mov rdi, [rax]    ; Load data pointer");
    emit(ctx, "    call free    ; Free data");
    
    // Free box
    emit(ctx, "    mov rdi, [%s]    ; Reload box pointer", var_name);
    emit(ctx, "    call free    ; Free box");
    
    emit(ctx, "%s:", skip_label);
    free(skip_label);
}

// ============================================================================
// MAIN CODEGEN FUNCTION
// ============================================================================

void smart_pointer_codegen(SmartPointerParseResult* parse_result, const char* output_path) {
    FILE* output = fopen(output_path, "w");
    if (!output) {
        fprintf(stderr, "Error: Cannot open output file: %s\n", output_path);
        return;
    }
    
    CodegenContext* ctx = codegen_create(output);
    
    // Emit header
    emit_header(ctx);
    
    // Emit BSS section (variable declarations)
    emit_bss_section(ctx, parse_result);
    
    // Emit text section
    emit(ctx, "");
    emit(ctx, "section .text");
    emit(ctx, "    global _start");
    emit(ctx, "    extern malloc, free");
    emit(ctx, "");
    emit(ctx, "_start:");
    
    // Generate code for operations
    for (size_t i = 0; i < parse_result->op_count; i++) {
        SmartPointerOp* op = parse_result->operations[i];
        
        emit(ctx, "");
        
        switch (op->op_kind) {
            case SP_OP_PARSE_RC_NEW:
                codegen_rc_new(ctx, op->arg, "Unknown");
                break;
            case SP_OP_PARSE_RC_CLONE:
                codegen_rc_clone(ctx, op->arg);
                break;
            case SP_OP_PARSE_RC_DROP:
                codegen_rc_drop(ctx, op->arg);
                break;
            case SP_OP_PARSE_ARC_NEW:
                codegen_arc_new(ctx, op->arg, "Unknown");
                break;
            case SP_OP_PARSE_ARC_CLONE:
                codegen_arc_clone(ctx, op->arg);
                break;
            case SP_OP_PARSE_ARC_DROP:
                codegen_arc_drop(ctx, op->arg);
                break;
            case SP_OP_PARSE_BOX_NEW:
                codegen_box_new(ctx, op->arg, "Unknown");
                break;
            case SP_OP_PARSE_BOX_DROP:
                codegen_box_drop(ctx, op->arg);
                break;
            default:
                emit_comment(ctx, "Unknown operation");
                break;
        }
    }
    
    // Exit
    emit(ctx, "");
    emit_comment(ctx, "Exit program");
    emit(ctx, "    mov rax, 60    ; sys_exit");
    emit(ctx, "    xor rdi, rdi    ; exit code 0");
    emit(ctx, "    syscall");
    
    codegen_destroy(ctx);
    fclose(output);
}

int smart_pointer_get_declaration_count(SmartPointerParseResult* result) {
    return result ? result->decl_count : 0;
}

int smart_pointer_get_operation_count(SmartPointerParseResult* result) {
    return result ? result->op_count : 0;
}
