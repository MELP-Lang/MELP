-- lang: en-US
-- syntax: mlp

-- -----------------------------------------------------------------------------
-- Parser Data Structures Module - List, HashMap, Set, Struct parsing
-- -----------------------------------------------------------------------------
-- C bootstrap derleyicisindeki veri yapısı parsing mantığını MLP'ye taşır.
-- List literals, HashMap literals, Set literals, Struct definitions.
-- -----------------------------------------------------------------------------

import "modules/token_types.mlp"
import "modules/ast_nodes.mlp"
import "modules/parser.mlp"

-- -----------------------------------------------------------------------------
-- List literal parsing
-- -----------------------------------------------------------------------------

function parse_list_literal(state)
    state = parser_expect(state; TOKEN_LEFT_BRACKET)
    
    list element_ids = list()
    
    if parser_check(state; TOKEN_RIGHT_BRACKET) == 0 then
        while 1 == 1
            Numeric elem_id = 0
            elem_id = parse_expression(state; 0)
            mlp_list_add(element_ids; elem_id)
            
            if parser_match(state; TOKEN_COMMA) == 0 then
                break
            end_if
        end
    end_if
    
    state = parser_expect(state; TOKEN_RIGHT_BRACKET)
    
    Numeric list_id = 0
    list_id = parser_create_node(state; AST_LIST_LITERAL; "list_literal")
    
    ASTListLiteralData data
    data.node_id = list_id
    data.element_ids = element_ids
    data.element_type = "numeric"
    
    return list_id
end_function

-- -----------------------------------------------------------------------------
-- HashMap literal parsing
-- -----------------------------------------------------------------------------

function parse_hashmap_literal(state)
    state = parser_expect(state; TOKEN_LEFT_BRACE)
    
    list key_ids = list()
    list value_ids = list()
    
    if parser_check(state; TOKEN_RIGHT_BRACE) == 0 then
        while 1 == 1
            Numeric key_id = 0
            key_id = parse_expression(state; 0)
            state = parser_expect(state; TOKEN_COLON)
            Numeric value_id = 0
            value_id = parse_expression(state; 0)
            
            mlp_list_add(key_ids; key_id)
            mlp_list_add(value_ids; value_id)
            
            if parser_match(state; TOKEN_COMMA) == 0 then
                break
            end_if
        end
    end_if
    
    state = parser_expect(state; TOKEN_RIGHT_BRACE)
    
    Numeric map_id = 0
    map_id = parser_create_node(state; AST_HASHMAP_LITERAL; "hashmap_literal")
    
    ASTHashMapLiteralData data
    data.node_id = map_id
    data.key_ids = key_ids
    data.value_ids = value_ids
    data.key_type = "string"
    data.value_type = "numeric"
    
    return map_id
end_function

-- -----------------------------------------------------------------------------
-- Set literal parsing (brace notation with single expressions)
-- -----------------------------------------------------------------------------

function parse_set_literal(state)
    state = parser_expect(state; TOKEN_LEFT_BRACE)
    
    list element_ids = list()
    
    if parser_check(state; TOKEN_RIGHT_BRACE) == 0 then
        while 1 == 1
            Numeric elem_id = 0
            elem_id = parse_expression(state; 0)
            mlp_list_add(element_ids; elem_id)
            
            if parser_match(state; TOKEN_COMMA) == 0 then
                break
            end_if
        end
    end_if
    
    state = parser_expect(state; TOKEN_RIGHT_BRACE)
    
    Numeric set_id = 0
    set_id = parser_create_node(state; AST_SET_LITERAL; "set_literal")
    
    ASTSetLiteralData data
    data.node_id = set_id
    data.element_ids = element_ids
    data.element_type = "numeric"
    
    return set_id
end_function

-- -----------------------------------------------------------------------------
-- Struct field definition (Phase 6.2: Nested Structs + Methods)
-- -----------------------------------------------------------------------------
-- Port from: mlp_compiler.c komut() lines 3500-3560
-- Supports:
-- - Basic fields: numeric x, string name
-- - Nested structs: Person owner
-- - Methods: function greet() ... end_function
-- -----------------------------------------------------------------------------

struct ASTStructField
    String type_name        -- Field type (numeric; string; or struct name)
    String field_name       -- Field name
    Numeric default_value_id  -- Default value (optional)
    bool is_method         -- True if this is a method definition
    Numeric method_body_id -- Method body AST node ID (if is_method)
end_struct

function parse_struct_field(state)
    -- Check if this is a method definition
    if parser_check(state; TOKEN_FUNCTION) == 1 then
        -- Method definition inside struct
        state = parser_expect(state; TOKEN_FUNCTION)
        
        Token method_name_token
        method_name_token = parser_peek(state)
        state = parser_expect(state; TOKEN_IDENTIFIER)
        
        -- Parse method parameters
        list parameters = parse_parameter_list(state)
        
        -- Method body
        state = parser_enter_scope(state)
        Numeric body_id = 0
        body_id = parse_block(state; TOKEN_END)
        state = parser_exit_scope(state)
        
        state = parser_expect(state; TOKEN_END)
        state = parser_expect(state; TOKEN_FUNCTION)
        
        -- Create method field
        ASTStructField field
        field.type_name = "METHOD"
        field.field_name = method_name_token.lexeme
        field.default_value_id = -1
        field.is_method = true
        field.method_body_id = body_id
        
        return field
    else
        -- Regular field definition
        -- Field type (numeric; string; boolean; or struct name)
        Token type_token
        type_token = parser_peek(state)
        
        -- Check if it's a type keyword or identifier (struct name)
        if parser_check(state; TOKEN_TYPE_NUMERIC) == 1 or
           parser_check(state; TOKEN_TYPE_STRING) == 1 or
           parser_check(state; TOKEN_TYPE_BOOLEAN) == 1 then
            state = parser_advance(state)
        else if parser_check(state; TOKEN_IDENTIFIER) == 1 then
            -- Nested struct type (e.g.; Person owner)
            state = parser_advance(state)
        else
            -- Error: expected type
            parser_error(state; "Expected field type (numeric, string, boolean, or struct name)")
        end_if
        
        -- Field name
        Token name_token
        name_token = parser_peek(state)
        state = parser_expect(state; TOKEN_IDENTIFIER)
        
        -- Optional default value
        Numeric default_value_id = -1
        if parser_match(state; TOKEN_ASSIGN) == 1 then
            default_value_id = parse_expression(state; 0)
        end_if
        
        ASTStructField field
        field.type_name = type_token.lexeme
        field.field_name = name_token.lexeme
        field.default_value_id = default_value_id
        field.is_method = false
        field.method_body_id = -1
        
        return field
    end_if
end_function

-- -----------------------------------------------------------------------------
-- Struct definition (Phase 6.2: Enhanced with Nested Structs + Methods)
-- -----------------------------------------------------------------------------
-- Port from: mlp_compiler.c komut() lines 3500-3565
-- Example:
-- struct Person then
--     numeric age
--     string name
--     Address home        -- Nested struct
--     
--     function greet()    -- Method
--         yaz("Hello, " + name)
--     end_function
-- end_struct
-- -----------------------------------------------------------------------------

function parse_struct_definition(state)
    state = parser_expect(state; TOKEN_YAPI_STRUCT)
    
    Token name_token
    name_token = parser_peek(state)
    state = parser_expect(state; TOKEN_IDENTIFIER)
    
    -- Optional 'then' keyword (for compatibility)
    if parser_check(state; TOKEN_THEN) == 1 then
        state = parser_expect(state; TOKEN_THEN)
    end_if
    
    list fields = list()
    
    -- Parse fields until 'end' or 'end_struct'
    while parser_check(state; TOKEN_END) == 0 and 
          parser_check(state; TOKEN_END_STRUCT) == 0
        if parser_check(state; TOKEN_EOF) == 1 then
            break
        end_if
        
        ASTStructField field
        field = parse_struct_field(state)
        mlp_list_add(fields; field)
    end
    
    -- Accept both "end_struct" and plain "end"
    if parser_check(state; TOKEN_END) == 1 then
        state = parser_expect(state; TOKEN_END)
        -- Optional "struct" keyword after "end"
        if parser_check(state; TOKEN_YAPI_STRUCT) == 1 then
            state = parser_advance(state)
        end_if
    else if parser_check(state; TOKEN_END_STRUCT) == 1 then
        state = parser_expect(state; TOKEN_END_STRUCT)
    end_if
    
    Numeric struct_id = 0
    struct_id = parser_create_node(state; AST_STRUCT_DEFINITION; "struct_def")
    
    ASTStructData data
    data.node_id = struct_id
    data.name = name_token.lexeme
    data.fields = fields
    data.field_count = mlp_list_length(fields)
    
    -- Register struct metadata for later use
    state.registry = register_struct_type(state.registry; name_token.lexeme; fields)
    
    return struct_id
end_function

-- -----------------------------------------------------------------------------
-- Enum definition
-- -----------------------------------------------------------------------------

function parse_enum_definition(state)
    state = parser_expect(state; TOKEN_YAPI_ENUM)
    
    Token name_token
    name_token = parser_peek(state)
    state = parser_expect(state; TOKEN_IDENTIFIER)
    
    state = parser_expect(state; TOKEN_THEN)
    
    list variant_names = list()
    list variant_values = list()
    
    Numeric auto_value = 0
    
    while parser_check(state; TOKEN_END) == 0
        if parser_check(state; TOKEN_EOF) == 1 then
            break
        end_if
        
        Token variant_token
        variant_token = parser_peek(state)
        state = parser_expect(state; TOKEN_IDENTIFIER)
        
        mlp_list_add(variant_names; variant_token.lexeme)
        
        if parser_match(state; TOKEN_ASSIGN) == 1 then
            Numeric value_id = 0
            value_id = parse_expression(state; 0)
            mlp_list_add(variant_values; value_id)
        else
            mlp_list_add(variant_values; auto_value)
            auto_value = auto_value + 1
        end_if
    end
    
    state = parser_expect(state; TOKEN_END)
    state = parser_expect(state; TOKEN_YAPI_ENUM)
    
    Numeric enum_id = 0
    enum_id = parser_create_node(state; AST_ENUM_DEFINITION; "enum_def")
    
    ASTEnumData data
    data.node_id = enum_id
    data.name = name_token.lexeme
    data.variant_names = variant_names
    data.variant_values = variant_values
    
    return enum_id
end_function

-- -----------------------------------------------------------------------------
-- Struct instantiation
-- -----------------------------------------------------------------------------

function parse_struct_instantiation(state; type_name)
    state = parser_expect(state; TOKEN_LEFT_BRACE)
    
    list field_names = list()
    list field_value_ids = list()
    
    if parser_check(state; TOKEN_RIGHT_BRACE) == 0 then
        while 1 == 1
            Token field_token
            field_token = parser_peek(state)
            state = parser_expect(state; TOKEN_IDENTIFIER)
            
            state = parser_expect(state; TOKEN_COLON)
            
            Numeric value_id = 0
            value_id = parse_expression(state; 0)
            
            mlp_list_add(field_names; field_token.lexeme)
            mlp_list_add(field_value_ids; value_id)
            
            if parser_match(state; TOKEN_COMMA) == 0 then
                break
            end_if
        end
    end_if
    
    state = parser_expect(state; TOKEN_RIGHT_BRACE)
    
    Numeric inst_id = 0
    inst_id = parser_create_node(state; AST_STRUCT_INSTANTIATION; "struct_inst")
    
    ASTStructInstantiationData data
    data.node_id = inst_id
    data.type_name = type_name
    data.field_names = field_names
    data.field_value_ids = field_value_ids
    
    return inst_id
end_function

-- -----------------------------------------------------------------------------
-- Member access (dot notation)
-- -----------------------------------------------------------------------------

function parse_member_access(state; object_id)
    state = parser_expect(state; TOKEN_DOT)
    
    Token member_token
    member_token = parser_peek(state)
    state = parser_expect(state; TOKEN_IDENTIFIER)
    
    Numeric access_id = 0
    access_id = parser_create_node(state; AST_MEMBER_ACCESS; "member_access")
    
    ASTMemberAccessData data
    data.node_id = access_id
    data.object_id = object_id
    data.member_name = member_token.lexeme
    
    return access_id
end_function

-- -----------------------------------------------------------------------------
-- List type annotation parsing (list; HashMap[string; numeric])
-- -----------------------------------------------------------------------------

function parse_type_annotation(state)
    Token base_type_token
    base_type_token = parser_peek(state)
    state = parser_advance(state)
    
    String type_str = base_type_token.lexeme
    
    if parser_match(state; TOKEN_LEFT_BRACKET) == 1 then
        String element_type = ""
        element_type = parse_type_annotation(state)
        type_str = type_str + "[" + element_type
        
        if parser_match(state; TOKEN_COMMA) == 1 then
            String value_type = ""
            value_type = parse_type_annotation(state)
            type_str = type_str + ", " + value_type
        end_if
        
        state = parser_expect(state; TOKEN_RIGHT_BRACKET)
        type_str = type_str + "]"
    end_if
    
    return type_str
end_function

-- -----------------------------------------------------------------------------
-- Range expression (1..10)
-- -----------------------------------------------------------------------------

function parse_range_expression(state; start_id)
    state = parser_expect(state; TOKEN_RANGE)
    Numeric end_id = 0
    end_id = parse_expression(state; 0)
    
    Numeric range_id = 0
    range_id = parser_create_node(state; AST_RANGE; "range_expr")
    
    ASTRangeData data
    data.node_id = range_id
    data.start_id = start_id
    data.end_id = end_id
    data.is_inclusive = 0
    
    return range_id
end_function

-- -----------------------------------------------------------------------------
-- For-each loop
-- -----------------------------------------------------------------------------

function parse_foreach_loop(state)
    state = parser_expect(state; TOKEN_FOR)
    
    Token var_token
    var_token = parser_peek(state)
    state = parser_expect(state; TOKEN_IDENTIFIER)
    
    state = parser_expect(state; TOKEN_IN)
    
    Numeric iterable_id = 0
    iterable_id = parse_expression(state; 0)
    
    state = parser_expect(state; TOKEN_YAPI_DO)
    
    state = parser_enter_scope(state)
    Numeric body_id = 0
    body_id = parse_block(state; TOKEN_END)
    state = parser_exit_scope(state)
    
    state = parser_expect(state; TOKEN_END)
    state = parser_expect(state; TOKEN_FOR)
    
    Numeric foreach_id = 0
    foreach_id = parser_create_node(state; AST_FOR_EACH_LOOP; "foreach_loop")
    
    ASTForEachData data
    data.node_id = foreach_id
    data.iterator_name = var_token.lexeme
    data.iterable_id = iterable_id
    data.body_block_id = body_id
    
    return foreach_id
end_function

-- -----------------------------------------------------------------------------
-- For loop with range
-- -----------------------------------------------------------------------------

function parse_for_loop(state)
    Token next_token
    next_token = parser_peek(state)
    
    if next_token.type == TOKEN_FOR then
        return parse_foreach_loop(state)
    end_if
    
    state = parser_expect(state; TOKEN_FOR)
    
    Token var_token
    var_token = parser_peek(state)
    state = parser_expect(state; TOKEN_IDENTIFIER)
    
    state = parser_expect(state; TOKEN_ASSIGN)
    
    Numeric init_id = 0
    init_id = parse_expression(state; 0)
    
    state = parser_expect(state; TOKEN_TO)
    
    Numeric end_id = 0
    end_id = parse_expression(state; 0)
    
    Numeric step_id = -1
    if parser_match(state; TOKEN_STEP) == 1 then
        step_id = parse_expression(state; 0)
    end_if
    
    state = parser_expect(state; TOKEN_YAPI_DO)
    
    state = parser_enter_scope(state)
    Numeric body_id = 0
    body_id = parse_block(state; TOKEN_END)
    state = parser_exit_scope(state)
    
    state = parser_expect(state; TOKEN_END)
    state = parser_expect(state; TOKEN_FOR)
    
    Numeric for_id = 0
    for_id = parser_create_node(state; AST_FOR_LOOP; "for_loop")
    
    ASTForLoopData data
    data.node_id = for_id
    data.iterator_name = var_token.lexeme
    data.init_id = init_id
    data.condition_id = end_id
    data.step_id = step_id
    data.body_block_id = body_id
    
    return for_id
end_function
