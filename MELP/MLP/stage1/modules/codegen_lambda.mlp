-- lang: en-US
-- syntax: mlp

-- -----------------------------------------------------------------------------
-- Code Generator - Lambda & Closures Module
-- -----------------------------------------------------------------------------
-- Lambda expressions, closure capture, first-class functions
-- -----------------------------------------------------------------------------

import "modules/token_types.mlp"
import "modules/ast_nodes.mlp"
import "modules/scope_manager.mlp"
-- Note: codegen.mlp imports this file, avoid circular dependency

-- Global lambda section (deferred code generation)
String lambda_section_code = ""
Numeric lambda_counter = 0

-- -----------------------------------------------------------------------------
-- Lambda expression code generation with closure support
-- -----------------------------------------------------------------------------

function visit_lambda_expression(state; numeric node_id)
    ASTArena arena = state.arena
    ASTNode node
    node = ast_arena_get(arena; node_id)
    
    -- Get lambda data once
    LambdaData lambda_data
    lambda_data = node.lambda_data
    
    -- Detect captured variables at codegen time
    list captured_vars = list()
    
    if mlp_list_length(lambda_data.captured_vars) == 0 then
        state = find_free_variables(state; lambda_data.body_id; captured_vars; lambda_data.parameters)
        lambda_data.captured_vars = captured_vars
        lambda_data.captured_count = mlp_list_length(captured_vars)
    else
        captured_vars = lambda_data.captured_vars
    end_if
    
    Numeric captured_count = 0
    captured_count = mlp_list_length(captured_vars)
    
    -- Generate unique labels
    String lambda_label
    lambda_label = "__lambda_" + numeric_to_metin(lambda_counter)
    String closure_label
    closure_label = "__closure_" + numeric_to_metin(lambda_counter)
    lambda_counter = lambda_counter + 1
    
    -- =========================
    -- CLOSURE ALLOCATION (ALWAYS - uniform calling convention)
    -- =========================
    
    state.code = asm_emit_text(state.code; "    ; --- Closure Allocation (captures: " + numeric_to_metin(captured_count) + ") ---")
    
    -- 1. Allocate closure struct on heap
    -- Layout: [0-7] function_ptr, [8-15] captured_var_1, [16-23] captured_var_2, ...
    Numeric closure_size
    Numeric temp_size
    temp_size = captured_count * 8
    closure_size = 8 + temp_size
    state.code = asm_emit_text(state.code; "    mov rdi, " + numeric_to_metin(closure_size) + "  ; Closure size")
    state.code = asm_emit_text(state.code; "    call malloc")
    state.code = asm_emit_text(state.code; "    mov [rel " + closure_label + "], rax  ; Save closure base")
    
    -- 2. Store function pointer at offset 0
    state.code = asm_emit_text(state.code; "    lea rbx, [rel " + lambda_label + "]  ; Get lambda address")
    state.code = asm_emit_text(state.code; "    mov rcx, [rel " + closure_label + "]  ; Load closure base")
    state.code = asm_emit_text(state.code; "    mov [rcx], rbx  ; Store function pointer")
    
    -- 3. Copy captured variables into closure struct
    if captured_count > 0 then
        for i = 0 to captured_count - 1 do
            String var_name
            var_name = mlp_list_get(captured_vars; i)
            Variable var
            var = scope_find_variable(state; var_name)
            
            if var == null then
                yazdir("ERROR: Captured variable '" + var_name + "' not found!")
                -- exit(1)  -- TODO: Implement proper error handling
            end_if
            
            Numeric offset
            Numeric temp
            temp = i * 8
            offset = 8 + temp
            state.code = asm_emit_text(state.code; "    ; Capture '" + var_name + "' at offset " + numeric_to_metin(offset))
            state.code = asm_emit_text(state.code; "    mov rbx, " + var.asm_address + "  ; Load variable")
            state.code = asm_emit_text(state.code; "    mov rcx, [rel " + closure_label + "]  ; Load closure base")
            state.code = asm_emit_text(state.code; "    mov [rcx+" + numeric_to_metin(offset) + "], rbx  ; Store in closure")
        end
    end_if
    
    -- 4. Return closure pointer in RAX
    state.code = asm_emit_text(state.code; "    mov rax, [rel " + closure_label + "]  ; Return closure pointer")
    
    -- =========================
    -- LAMBDA FUNCTION DEFINITION (DEFERRED)
    -- =========================
    
    -- Add closure storage to data section
    state.data_code = asm_emit_data(state.data_code; closure_label + ": dq 0  ; Closure pointer")
    
    -- Save current scope context
    Numeric saved_var_count = state.scope_var_count
    Numeric saved_stack_offset = state.scope_stack_offset
    
    -- Keep globals, reset locals
    state = scope_enter(state)
    
    -- Generate lambda function in deferred section
    lambda_section_code = lambda_section_code + "\n" + lambda_label + ":\n"
    
    if captured_count > 0 then
        lambda_section_code = lambda_section_code + "    ; --- Lambda with Closure (params: " + numeric_to_metin(lambda_data.parameter_count) + ", captured: " + numeric_to_metin(captured_count) + ") ---\n"
    else
        lambda_section_code = lambda_section_code + "    ; --- Lambda Expression (params: " + numeric_to_metin(lambda_data.parameter_count) + ") ---\n"
    end_if
    
    -- Function prolog
    lambda_section_code = lambda_section_code + "    push rbp\n"
    lambda_section_code = lambda_section_code + "    mov rbp, rsp\n"
    lambda_section_code = lambda_section_code + "    sub rsp, 256\n"
    
    -- Save closure pointer (first parameter; always in rdi)
    String closure_var_addr = ""
    closure_var_addr = scope_allocate_variable(state; "__closure"; "SAYISAL")
    lambda_section_code = lambda_section_code + "    mov " + closure_var_addr + ", rdi  ; Save closure pointer\n"
    
    -- Save user parameters (rsi; rdx; rcx; ...)
    list arg_registers = list("rsi"; "rdx"; "rcx"; "r8"; "r9")
    
    for i = 0 to lambda_data.parameter_count - 1 do
        Token param
        param = mlp_list_get(lambda_data.parameters; i)
        String param_name
        param_name = param.lexeme
        String param_addr
        param_addr = scope_allocate_variable(state; param.lexeme; "SAYISAL")
        String reg
        reg = mlp_list_get(arg_registers; i)
        lambda_section_code = lambda_section_code + "    mov " + param_addr + ", " + reg + "  ; Parameter '" + param_name + "'\n"
    end
    
    -- Load captured variables from closure struct
    if captured_count > 0 then
        for i = 0 to captured_count - 1 do
            String var_name
            var_name = mlp_list_get(captured_vars; i)
            Numeric offset
            Numeric temp2
            temp2 = i * 8
            offset = 8 + temp2
            
            String var_addr
            var_addr = scope_allocate_variable(state; var_name; "SAYISAL")
            
            lambda_section_code = lambda_section_code + "    ; Load captured '" + var_name + "' from closure\n"
            lambda_section_code = lambda_section_code + "    mov rbx, " + closure_var_addr + "  ; Closure pointer\n"
            lambda_section_code = lambda_section_code + "    mov rax, [rbx+" + numeric_to_metin(offset) + "]  ; Load from offset\n"
            lambda_section_code = lambda_section_code + "    mov " + var_addr + ", rax  ; Store locally\n"
        end
    end_if
    
    -- CRITICAL: Swap text section to lambda section during body evaluation
    String saved_text_code = state.code
    state.code = lambda_section_code
    
    -- Evaluate body expression
    state = visit_expression(state; lambda_data.body_id)
    
    -- Save updated lambda section
    lambda_section_code = state.code
    
    -- Restore text section
    state.code = saved_text_code
    
    -- Function epilog (RAX already has return value)
    lambda_section_code = lambda_section_code + "    ; --- Lambda Return ---\n"
    lambda_section_code = lambda_section_code + "    mov rsp, rbp\n"
    lambda_section_code = lambda_section_code + "    pop rbp\n"
    lambda_section_code = lambda_section_code + "    ret\n"
    
    -- Restore scope
    state = scope_exit(state)
    state.scope_stack_offset = saved_stack_offset
    
    return state
end_function

-- -----------------------------------------------------------------------------
-- Indirect lambda call (through closure pointer)
-- -----------------------------------------------------------------------------

function visit_lambda_call(state; closure_var_name; argument_ids)
    Variable closure_var
    closure_var = scope_find_variable(state; closure_var_name)
    
    if closure_var == null then
        yazdir("ERROR: Closure variable '" + closure_var_name + "' not found!")
        -- exit(1)  -- TODO: Implement proper error handling
    end_if
    
    state.code = asm_emit_text(state.code; "    ; --- Lambda Indirect Call ---")
    
    -- 1. Load closure pointer
    state.code = asm_emit_text(state.code; "    mov r10, " + closure_var.asm_address + "  ; Load closure pointer")
    
    -- 2. Extract function pointer from closure[0]
    state.code = asm_emit_text(state.code; "    mov r11, [r10]  ; Extract function pointer")
    
    -- 3. Evaluate arguments
    list arg_registers = list("rsi"; "rdx"; "rcx"; "r8"; "r9")
    
    for i = 0 to mlp_list_length(argument_ids) - 1 do
        Numeric arg_id
        arg_id = mlp_list_get(argument_ids; i)
        state = visit_expression(state; arg_id)
        
        String reg
        reg = mlp_list_get(arg_registers; i)
        state.code = asm_emit_text(state.code; "    mov " + reg + ", rax  ; Argument " + numeric_to_metin(i + 1))
    end
    
    -- 4. First argument is always closure pointer (rdi)
    state.code = asm_emit_text(state.code; "    mov rdi, r10  ; First arg = closure pointer")
    
    -- 5. Indirect call
    state.code = asm_emit_text(state.code; "    call r11  ; Indirect lambda call")
    
    -- Result in RAX
    
    return state
end_function

-- -----------------------------------------------------------------------------
-- Append lambda section to final assembly
-- -----------------------------------------------------------------------------

function finalize_lambda_section(state)
    if lambda_section_code != "" then
        state.code = asm_emit_text(state.code; "")
        state.code = asm_emit_text(state.code; "; ========================================")
        state.code = asm_emit_text(state.code; "; LAMBDA FUNCTIONS (DEFERRED)")
        state.code = asm_emit_text(state.code; "; ========================================")
        state.code = state.code + lambda_section_code
    end_if
    
    return state
end_function
