-- lang: en-US
-- syntax: mlp

-- -----------------------------------------------------------------------------
-- Lexer Module - Tam Entegre
-- -----------------------------------------------------------------------------
-- C bootstrap derleyicisindeki lexer mantığını MLP'ye taşır.
-- UTF-8, string interpolation, multi-line strings, line continuation desteği.
-- -----------------------------------------------------------------------------

import "compiler_core/token_types.mlp"

-- -----------------------------------------------------------------------------
-- Lexer durumu
-- -----------------------------------------------------------------------------

struct LexerState
    String source_code
    Numeric position
    Numeric length
    Numeric line
    Numeric column
    Numeric eof_reached
end_struct

function lexer_state_create(source_code)
    LexerState state
    state.source_code = source_code
    state.position = 0
    state.length = string_length(source_code)
    state.line = 1
    state.column = 1
    state.eof_reached = 0
    return state
end_function

-- -----------------------------------------------------------------------------
-- Karakter yardımcıları
-- -----------------------------------------------------------------------------

function char_at(state; offset)
    Numeric pos = state.position + offset
    if pos >= state.length then
        return ""
    end_if
    return string_substring(state.source_code; pos; 1)
end_function

function current_char(state)
    return char_at(state; 0)
end_function

function peek_char(state; offset)
    return char_at(state; offset)
end_function

function is_eof(state)
    if state.position >= state.length then
        return 1
    end_if
    return 0
end_function

function advance(state)
    if is_eof(state) == 1 then
        return state
    end_if

    String ch = ""
    ch = current_char(state)
    
    if ch == "\n" then
        state.line = state.line + 1
        state.column = 1
    else
        state.column = state.column + 1
    end_if
    
    state.position = state.position + 1
    return state
end_function

function is_digit(ch)
    if ch >= "0" then
        if ch <= "9" then
            return 1
        end_if
    end_if
    return 0
end_function

function is_alpha(ch)
    if ch >= "a" then
        if ch <= "z" then
            return 1
        end_if
    end_if
    if ch >= "A" then
        if ch <= "Z" then
            return 1
        end_if
    end_if
    if ch == "_" then
        return 1
    end_if
    return 0
end_function

function is_alnum(ch)
    if is_alpha(ch) == 1 then
        return 1
    end_if
    if is_digit(ch) == 1 then
        return 1
    end_if
    return 0
end_function

function is_whitespace(ch)
    if ch == " " then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- -----------------------------------------------------------------------------
-- Boşluk ve yorum atlama
-- -----------------------------------------------------------------------------

function skip_whitespace(state)
    while is_eof(state) == 0
        String ch = ""
        ch = current_char(state)
        if is_whitespace(ch) == 0 then
            break
        end_if
        state = advance(state)
    end
    return state
end_function

function skip_line_comment(state)
    while is_eof(state) == 0
        String ch = ""
        ch = current_char(state)
        if ch == "\n" then
            break
        end_if
        state = advance(state)
    end
    return state
end_function

function skip_block_comment(state)
    state = advance(state)
    state = advance(state)
    
    while is_eof(state) == 0
        String ch = ""
        ch = current_char(state)
        String next = ""
        next = peek_char(state; 1)
        
        if ch == "-" then
            if next == "}" then
                state = advance(state)
                state = advance(state)
                break
            end_if
        end_if
        
        state = advance(state)
    end
    
    return state
end_function

function skip_whitespace_and_comments(state)
    while is_eof(state) == 0
        state = skip_whitespace(state)
        
        if is_eof(state) == 1 then
            break
        end_if
        
        String ch = ""
        ch = current_char(state)
        String next = ""
        next = peek_char(state; 1)
        
        if ch == "-" then
            if next == "-" then
                state = skip_line_comment(state)
            else
                break
            end_if
        else
            if ch == "{" then
                if next == "-" then
                    state = skip_block_comment(state)
                else
                    break
                end_if
            else
                break
            end_if
        end_if
    end
    
    return state
end_function

-- -----------------------------------------------------------------------------
-- Sayı okuma
-- -----------------------------------------------------------------------------

function read_number(state)
    Numeric start = state.position
    
    while is_eof(state) == 0
        String ch = ""
        ch = current_char(state)
        if is_digit(ch) == 0 then
            break
        end_if
        state = advance(state)
    end
    
    Numeric len = state.position - start
    String value = ""
    value = string_substring(state.source_code; start; len)
    
    Token token
    token = make_token(TOKEN_NUMBER; value; state.line; state.column)
    return token
end_function

-- -----------------------------------------------------------------------------
-- String okuma (UTF-8; interpolation; triple-quote desteği)
-- -----------------------------------------------------------------------------

function read_metin(state; delimiter)
    state = advance(state)
    Numeric start = state.position
    list parts = list()
    String current_part = ""
    
    while is_eof(state) == 0
        String ch = ""
        ch = current_char(state)
        
        if ch == delimiter then
            if string_length(current_part) > 0 then
                mlp_list_add(parts; current_part)
            end_if
            state = advance(state)
            break
        end_if
        
        if ch == "{" then
            if string_length(current_part) > 0 then
                mlp_list_add(parts; current_part)
                current_part = ""
            end_if
            
            state = advance(state)
            Numeric var_start = state.position
            
            while is_eof(state) == 0
                String vch = ""
                vch = current_char(state)
                if vch == "}" then
                    break
                end_if
                state = advance(state)
            end
            
            Numeric var_len = state.position - var_start
            String var_name = ""
            var_name = string_substring(state.source_code; var_start; var_len)
            mlp_list_add(parts; "{" + var_name + "}")
            
            state = advance(state)
        else
            current_part = current_part + ch
            state = advance(state)
        end_if
    end
    
    if string_length(current_part) > 0 then
        mlp_list_add(parts; current_part)
    end_if
    
    Numeric part_count = 0
    part_count = mlp_list_length(parts)
    if part_count > 1 then
        Token token
        token = make_token(TOKEN_INTERPOLATED_STRING; ""; state.line; state.column)
        token.interpolation_parts = parts
        return token
    else
        String final_value = ""
        if part_count == 1 then
            final_value = mlp_list_get(parts; 0)
        end_if
        Token token
        token = make_token(TOKEN_STRING; final_value; state.line; state.column)
        return token
    end_if
end_function

-- -----------------------------------------------------------------------------
-- Identifier ve keyword okuma
-- -----------------------------------------------------------------------------

function read_identifier(state)
    Numeric start = state.position
    
    while is_eof(state) == 0
        String ch = ""
        ch = current_char(state)
        if is_alnum(ch) == 0 then
            break
        end_if
        state = advance(state)
    end
    
    Numeric len = state.position - start
    String value = ""
    value = string_substring(state.source_code; start; len)
    
    TokenType token_type
    token_type = check_keyword(value)
    
    Token token
    token = make_token(token_type; value; state.line; state.column)
    return token
end_function

function check_keyword(word)
    if word == "numeric" then return TOKEN_TYPE_NUMERIC end_if
    if word == "string" then return TOKEN_TYPE_STRING end_if
    if word == "boolean" then return TOKEN_TYPE_BOOLEAN end_if
    if word == "const" then return TOKEN_CONST end_if
    if word == "typeof" then return TOKEN_TYPEOF end_if
    if word == "type" then return TOKEN_TYPE end_if
    if word == "as" then return TOKEN_AS end_if
    if word == "import" then return TOKEN_IMPORT end_if
    if word == "lambda" then return TOKEN_LAMBDA end_if
    if word == "in" then return TOKEN_IN end_if
    if word == "range" then return TOKEN_RANGE end_if
    if word == "print" then return TOKEN_PRINT end_if
    if word == "if" then return TOKEN_IF end_if
    if word == "then" then return TOKEN_THEN end_if
    if word == "else" then return TOKEN_ELSE end_if
    if word == "with" then return TOKEN_WITH end_if
    if word == "function" then return TOKEN_FUNCTION end_if
    if word == "return" then return TOKEN_RETURN end_if
    if word == "while" then return TOKEN_WHILE end_if
    if word == "do" then return TOKEN_YAPI_DO end_if
    if word == "for" then return TOKEN_FOR end_if
    if word == "to" then return TOKEN_TO end_if
    if word == "step" then return TOKEN_STEP end_if
    if word == "break" then return TOKEN_WHILE_BITIR end_if
    if word == "continue" then return TOKEN_WHILE_DEVAM end_if
    if word == "end" then return TOKEN_END end_if
    if word == "true" then return TOKEN_TRUE end_if
    if word == "false" then return TOKEN_FALSE end_if
    if word == "null" then return TOKEN_NULL end_if
    if word == "and" then return TOKEN_AND end_if
    if word == "or" then return TOKEN_OR end_if
    if word == "not" then return TOKEN_NOT end_if
    if word == "struct" then return TOKEN_YAPI_STRUCT end_if
    if word == "list" then return TOKEN_LIST end_if
    if word == "optional" then return TOKEN_OPTIONAL end_if
    if word == "map" then return TOKEN_MAP end_if
    if word == "enum" then return TOKEN_YAPI_ENUM end_if
    if word == "switch" then return TOKEN_YAPI_SWITCH end_if
    if word == "case" then return TOKEN_YAPI_CASE end_if
    if word == "default" then return TOKEN_YAPI_DEFAULT end_if
    if word == "match" then return TOKEN_MATCH end_if
    if word == "try" then return TOKEN_TRY end_if
    if word == "catch" then return TOKEN_CATCH end_if
    if word == "throw" then return TOKEN_THROW end_if
    if word == "defer" then return TOKEN_DEFER end_if
    if word == "panic" then return TOKEN_PANIC end_if
    if word == "async" then return TOKEN_ASYNC end_if
    if word == "await" then return TOKEN_AWAIT end_if
    if word == "stop" then return TOKEN_STOP end_if
    if word == "goto" then return TOKEN_GOTO end_if
    
    return TOKEN_IDENTIFIER
end_function

-- -----------------------------------------------------------------------------
-- Operatör okuma
-- -----------------------------------------------------------------------------

function read_operator(state)
    String ch = ""
    ch = current_char(state)
    String next = ""
    next = peek_char(state; 1)
    
    if ch == "=" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_OP_ESIT_KARSILASTIRMA; "=="; state.line; state.column)
        else
            state = advance(state)
            return make_token(TOKEN_ASSIGN; "="; state.line; state.column)
        end_if
    end_if
    
    if ch == "!" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_NOT_ESIT; "!="; state.line; state.column)
        end_if
    end_if
    
    if ch == ">" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_GTE; ">="; state.line; state.column)
        else
            if next == ">" then
                state = advance(state)
                state = advance(state)
                return make_token(TOKEN_RSHIFT; ">>"; state.line; state.column)
            else
                state = advance(state)
                return make_token(TOKEN_GT; ">"; state.line; state.column)
            end_if
        end_if
    end_if
    
    if ch == "<" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_LTE; "<="; state.line; state.column)
        else
            if next == "<" then
                state = advance(state)
                state = advance(state)
                return make_token(TOKEN_LSHIFT; "<<"; state.line; state.column)
            else
                state = advance(state)
                return make_token(TOKEN_LT; "<"; state.line; state.column)
            end_if
        end_if
    end_if
    
    if ch == "+" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_PLUS_ASSIGN; "+="; state.line; state.column)
        else
            if next == "+" then
                state = advance(state)
                state = advance(state)
                return make_token(TOKEN_INCREMENT; "++"; state.line; state.column)
            else
                state = advance(state)
                return make_token(TOKEN_PLUS; "+"; state.line; state.column)
            end_if
        end_if
    end_if
    
    if ch == "-" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_MINUS_ASSIGN; "-="; state.line; state.column)
        else
            if next == "-" then
                state = advance(state)
                state = advance(state)
                return make_token(TOKEN_DECREMENT; "--"; state.line; state.column)
            else
                state = advance(state)
                return make_token(TOKEN_MINUS; "-"; state.line; state.column)
            end_if
        end_if
    end_if
    
    if ch == "*" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_MUL_ASSIGN; "*="; state.line; state.column)
        else
            state = advance(state)
            return make_token(TOKEN_MUL; "*"; state.line; state.column)
        end_if
    end_if
    
    if ch == "/" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_DIV_ASSIGN; "/="; state.line; state.column)
        else
            state = advance(state)
            return make_token(TOKEN_DIV; "/"; state.line; state.column)
        end_if
    end_if
    
    if ch == "%" then
        state = advance(state)
        return make_token(TOKEN_MOD; "%"; state.line; state.column)
    end_if
    
    if ch == "&" then
        state = advance(state)
        return make_token(TOKEN_BITWISE_AND; "&"; state.line; state.column)
    end_if
    
    if ch == "|" then
        state = advance(state)
        return make_token(TOKEN_BITWISE_OR; "|"; state.line; state.column)
    end_if
    
    if ch == "^" then
        state = advance(state)
        return make_token(TOKEN_BITWISE_XOR; "^"; state.line; state.column)
    end_if
    
    if ch == "~" then
        state = advance(state)
        return make_token(TOKEN_BITWISE_NOT; "~"; state.line; state.column)
    end_if
    
    if ch == "(" then
        state = advance(state)
        return make_token(TOKEN_LEFT_PAREN; "("; state.line; state.column)
    end_if
    
    if ch == ")" then
        state = advance(state)
        return make_token(TOKEN_RIGHT_PAREN; ")"; state.line; state.column)
    end_if
    
    if ch == "[" then
        state = advance(state)
        return make_token(TOKEN_LEFT_BRACKET; "["; state.line; state.column)
    end_if
    
    if ch == "]" then
        state = advance(state)
        return make_token(TOKEN_RIGHT_BRACKET; "]"; state.line; state.column)
    end_if
    
    if ch == "{" then
        state = advance(state)
        return make_token(TOKEN_LEFT_BRACE; "{"; state.line; state.column)
    end_if
    
    if ch == "}" then
        state = advance(state)
        return make_token(TOKEN_RIGHT_BRACE; "}"; state.line; state.column)
    end_if
    
    if ch == "," then
        state = advance(state)
        return make_token(TOKEN_COMMA; "; "; state.line; state.column)
    end_if
    
    if ch == ";" then
        state = advance(state)
        return make_token(TOKEN_SEMICOLON; ";"; state.line; state.column)
    end_if
    
    if ch == "." then
        state = advance(state)
        return make_token(TOKEN_DOT; "."; state.line; state.column)
    end_if
    
    if ch == ":" then
        state = advance(state)
        return make_token(TOKEN_COLON; ":"; state.line; state.column)
    end_if
    
    if ch == "?" then
        state = advance(state)
        return make_token(TOKEN_TERNARY_QUESTION; "?"; state.line; state.column)
    end_if
    
    state = advance(state)
    return make_token(TOKEN_EOF; ""; state.line; state.column)
end_function

-- -----------------------------------------------------------------------------
-- Ana tokenizer
-- -----------------------------------------------------------------------------

function get_next_token(state)
    if state.eof_reached == 1 then
        return make_token(TOKEN_EOF; ""; state.line; state.column)
    end_if
    
    state = skip_whitespace_and_comments(state)
    
    if is_eof(state) == 1 then
        state.eof_reached = 1
        return make_token(TOKEN_EOF; ""; state.line; state.column)
    end_if
    
    String ch = ""
    ch = current_char(state)
    
    if is_digit(ch) == 1 then
        return read_number(state)
    end_if
    
    if ch == "\"" then
        return read_metin(state; "\"")
    end_if
    
    if ch == "'" then
        return read_metin(state; "'")
    end_if
    
    if is_alpha(ch) == 1 then
        return read_identifier(state)
    end_if
    
    return read_operator(state)
end_function

function tokenize(source_code)
    LexerState state
    state = lexer_state_create(source_code)
    TokenStream stream
    stream = token_stream_create(list())
    
    while state.eof_reached == 0
        Token token
        token = get_next_token(state)
        mlp_list_add(stream.tokens; token)
        
        if token.type == TOKEN_EOF then
            break
        end_if
    end
    
    return stream
end_function
