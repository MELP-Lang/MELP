-- lang: en-US
-- syntax: mlp

-- ============================================================================
-- MELP Import Handler Module
-- ============================================================================
-- Port from: mlp_compiler.c (lines 42-72; 5625-5715)
-- Date: 24 Kasım 2025
-- Strategy: Pre-Scan Import Strategy (Phase 5.10)
--
-- Bu modül import statement'ları yönetir:
-- 1. Import path resolution (MLP_SOURCE_DIR kullanarak)
-- 2. Circular import detection
-- 3. Imported function collection (Pre-Scan strategy)
-- 4. Recursive import handling
-- ============================================================================

import "compiler_core/ast/ast_nodes.mlp"
import "compiler_core/lexer.mlp"
import "compiler_core/parser.mlp"

-- ========== Import Context ==========
-- C'deki global state'i struct olarak kapsülledik

struct ImportContext
    -- Imported function AST nodes (Pre-Scan strategy)
    list imported_functions
    Numeric imported_count
    
    -- Imported enum definitions (CRITICAL FIX!)
    list imported_enums
    Numeric enum_count
    
    -- Imported struct definitions (CRITICAL FIX!)
    list imported_structs
    Numeric struct_count
    
    -- Circular import detection
    list imported_files
    Numeric file_count
    
    -- Base directory for relative imports
    String base_dir
end_struct

-- ========== Constructor ==========

function create_import_context(base_directory)
    ImportContext ctx
    
    -- Initialize arrays (empty)
    ctx.imported_functions = list()
    ctx.imported_count = 0
    
    ctx.imported_enums = list()
    ctx.enum_count = 0
    
    ctx.imported_structs = list()
    ctx.struct_count = 0
    
    ctx.imported_files = list()
    ctx.file_count = 0
    
    ctx.base_dir = base_directory
    
    return ctx
end_function

-- ========== Circular Import Detection ==========

function is_file_imported(ctx; file_path)
    for i = 0 to ctx.file_count - 1 do
        if mlp_list_get(ctx.imported_files; i) == file_path then
            return true  -- Already imported
        end_if
    end
    return false
end_function

function mark_file_imported(ctx; file_path)
    -- Add to imported files list
    mlp_list_add(ctx.imported_files; file_path)
    ctx.file_count = ctx.file_count + 1
end_function

-- ========== Import Path Resolution ==========

function resolve_import_path(import_path; base_dir)
    String resolved_path
    
    -- Check if absolute path
    if string_alt(import_path; 0; 1) == "/" then
        -- Absolute path - use as is
        resolved_path = import_path
    else
        -- Relative path - try MLP_SOURCE_DIR first
        String source_dir
        source_dir = getenv("MLP_SOURCE_DIR")
        
        if source_dir != "" then
            -- Use MLP_SOURCE_DIR
            resolved_path = source_dir + "/" + import_path
        else
            if base_dir != "" then
                -- Use base_dir
                resolved_path = base_dir + "/" + import_path
            else
                -- No base, use as is (current directory)
                resolved_path = import_path
            end_if
        end_if
    end_if
    
    return resolved_path
end_function

-- ========== Collect Imported Function ==========
-- Pre-Scan Strategy: Collect AST nodes, don't emit assembly yet

function collect_imported_function(ctx; func_node)
    -- Add to imported functions array
    mlp_list_add(ctx.imported_functions; func_node)
    ctx.imported_count = ctx.imported_count + 1
end_function

-- ========== Collect Imported Enum (CRITICAL FIX!) ==========
function collect_imported_enum(ctx; enum_node)
    -- Add to imported enums array
    mlp_list_add(ctx.imported_enums; enum_node)
    ctx.enum_count = ctx.enum_count + 1
end_function

-- ========== Collect Imported Struct (CRITICAL FIX!) ==========
function collect_imported_struct(ctx; struct_node)
    -- Add to imported structs array
    mlp_list_add(ctx.imported_structs; struct_node)
    ctx.struct_count = ctx.struct_count + 1
end_function

-- ========== Handle Import Statement ==========
-- C'deki visit_Import() fonksiyonunun MELP versiyonu

function handle_import(ctx; import_node; lexer; parser)
    String file_path = import_node.import_path
    
    -- ========== Import Path Resolution ==========
    String resolved_path
    resolved_path = resolve_import_path(file_path; ctx.base_dir)
    
    -- ========== Circular Import Detection ==========
    if is_file_imported(ctx; resolved_path) then
        return 0  -- Already imported, skip
    end_if
    
    -- Mark as imported
    mark_file_imported(ctx; resolved_path)
    
    -- ========== Parse Imported File ==========
    String import_source
    import_source = read_file(resolved_path)
    
    if import_source == "" then
        yaz("ERROR: Cannot open import file '" + resolved_path + "'")
        return 0
    end_if
    
    -- Save current lexer state
    String saved_source = lexer.source_code
    Numeric saved_position = lexer.current_position
    Numeric saved_line = lexer.current_line
    Numeric saved_column = lexer.current_column
    Token saved_token
    saved_token = lexer.current_token
    
    -- Initialize lexer with imported file
    lexer = create_lexer(import_source)
    
    -- Get first token
    lexer.current_token = get_next_token(lexer)
    
    -- ========== COLLECT Imported Functions (Pre-Scan Strategy) ==========
    -- Parse the imported file and collect function definitions
    -- They will be emitted BEFORE main() in codegen
    
    Token lex_token
    lex_token = lexer.current_token
    while lex_token.type != TOKEN_EOF do
        ASTNode stmt
        stmt = parse_statement(parser; lexer)
        
        if stmt != null then
            -- Collect function definitions (don't emit yet)
            if stmt.type == AST_FUNCTION_DECLARATION then
                collect_imported_function(ctx; stmt)
            end_if
            if stmt.type == AST_ENUM_DECLARATION then
                -- CRITICAL FIX: Collect enum definitions!
                collect_imported_enum(ctx; stmt)
            end_if
            if stmt.type == AST_STRUCT_DECLARATION then
                -- CRITICAL FIX: Collect struct definitions!
                collect_imported_struct(ctx; stmt)
            end_if
            if stmt.type == AST_IMPORT then
                -- Handle nested imports recursively
                handle_import(ctx; stmt; lexer; parser)  -- Recursive
            end_if
            -- Skip other statements (variable declarations; etc.)
        end_if
        
        -- Update token for next iteration
        lex_token = lexer.current_token
    end
    
    -- Restore lexer state
    lexer.source_code = saved_source
    lexer.current_position = saved_position
    lexer.current_line = saved_line
    lexer.current_column = saved_column
    lexer.current_token = saved_token
end_function

-- ========== Get Imported Functions ==========
-- Returns collected imported functions for codegen

function get_imported_functions(ctx)
    return ctx.imported_functions
end_function

function get_imported_count(ctx)
    return ctx.imported_count
end_function

-- ========== Get Imported Enums (CRITICAL FIX!) ==========
function get_imported_enums(ctx)
    return ctx.imported_enums
end_function

function get_enum_count(ctx)
    return ctx.enum_count
end_function

-- ========== Get Imported Structs (CRITICAL FIX!) ==========
function get_imported_structs(ctx)
    return ctx.imported_structs
end_function

function get_struct_count(ctx)
    return ctx.struct_count
end_function

-- ========== Cleanup ==========

function cleanup_imports(ctx)
    -- MELP has automatic memory management
    -- Just reset counters
    ctx.imported_count = 0
    ctx.file_count = 0
end_function
