-- lang: en-US
-- syntax: mlp

-- -----------------------------------------------------------------------------
-- Parser Functions Module - Fonksiyon tanımı ve çağrı
-- -----------------------------------------------------------------------------
-- C bootstrap derleyicisindeki fonksiyon parsing mantığını MLP'ye taşır.
-- Function declarations, calls, parameters, default values, variadic args.
-- -----------------------------------------------------------------------------

import "modules/token_types.mlp"
import "modules/ast_nodes.mlp"
import "modules/parser.mlp"

-- -----------------------------------------------------------------------------
-- Parameter parsing (Phase 5.10: Typed Parameters)
-- -----------------------------------------------------------------------------
-- Port from: mlp_compiler.c islec_tanimlama() lines 4510-4520
-- Supports: numeric|string|boolean type annotations
-- Example: function greet(string name, numeric age)
-- -----------------------------------------------------------------------------

function parse_parameter(state)
    -- Optional type annotation: numeric|string|boolean
    TokenType param_type = TOKEN_TYPE_NUMERIC  -- Default to numeric
    
    if parser_check(state; TOKEN_TYPE_NUMERIC) == 1 or
       parser_check(state; TOKEN_TYPE_STRING) == 1 or
       parser_check(state; TOKEN_TYPE_BOOLEAN) == 1 then
        -- Save type annotation
        Token type_token
        type_token = parser_peek(state)
        param_type = type_token.type
        state = parser_advance(state)
    end_if
    
    -- Parameter name (required)
    Token name_token
    name_token = parser_peek(state)
    state = parser_expect(state; TOKEN_IDENTIFIER)
    
    -- Phase 7.6: Check for array parameter syntax: name[]
    Numeric is_array = 0
    if parser_match(state; TOKEN_LEFT_BRACKET) == 1 then
        state = parser_expect(state; TOKEN_RIGHT_BRACKET)
        is_array = 1
    end_if
    
    -- Phase 5.11: Default value (optional)
    Numeric default_value_id = -1
    if parser_match(state; TOKEN_ASSIGN) == 1 then
        default_value_id = parse_expression(state; 0)
    end_if
    
    -- Create parameter info
    ASTFunctionParameter param
    param.type = param_type              -- TokenType (TOKEN_TYPE_NUMERIC; etc.)
    param.name = name_token.lexeme       -- Parameter name
    param.is_array = is_array             -- Array parameter flag
    param.default_value_id = default_value_id
    
    return param
end_function

function parse_parameter_list(state)
    list parameters = list()
    
    state = parser_expect(state; TOKEN_LEFT_PAREN)
    
    if parser_check(state; TOKEN_RIGHT_PAREN) == 0 then
        while 1 == 1
            ASTFunctionParameter param
            param = parse_parameter(state)
            mlp_list_add(parameters; param)
            
            if parser_match(state; TOKEN_COMMA) == 0 then
                break
            end_if
        end
    end_if
    
    state = parser_expect(state; TOKEN_RIGHT_PAREN)
    
    return parameters
end_function

-- -----------------------------------------------------------------------------
-- Function declaration
-- -----------------------------------------------------------------------------

function parse_function_declaration(state)
    state = parser_expect(state; TOKEN_FUNCTION)
    
    Token name_token
    name_token = parser_peek(state)
    state = parser_expect(state; TOKEN_IDENTIFIER)
    
    list parameters = parse_parameter_list(state)
    
    -- Return type (opsiyonel)
    String return_type = "numeric"
    if parser_match(state; TOKEN_ARROW) == 1 then
        Token ret_type_token
        ret_type_token = parser_peek(state)
        state = parser_advance(state)
        return_type = ret_type_token.lexeme
    end_if
    
    -- Register function signature
    FunctionSignature sig
    sig.name = name_token.lexeme
    sig.parameter_count = mlp_list_length(parameters)
    sig.parameters = parameters
    sig.return_type = return_type
    
    state.registry = function_registry_register(state.registry; sig)
    
    -- Function body
    state = parser_enter_scope(state)
    Numeric body_id = 0
    body_id = parse_block(state; TOKEN_END)
    state = parser_exit_scope(state)
    
    state = parser_expect(state; TOKEN_END)
    state = parser_expect(state; TOKEN_FUNCTION)
    
    Numeric func_id = 0
    func_id = parser_create_node(state; AST_FUNCTION_DECLARATION; "func_decl")
    
    ASTFunctionData data
    data.node_id = func_id
    data.name = name_token.lexeme
    data.parameters = parameters
    data.body_block_id = body_id
    data.return_type = return_type
    data.is_async = 0
    data.is_generator = 0
    
    state.arena = ast_arena_set_data(state.arena; func_id; data)
    
    return func_id
end_function

-- -----------------------------------------------------------------------------
-- Function call argument parsing
-- -----------------------------------------------------------------------------

function parse_argument_list(state)
    list argument_ids = list()
    
    state = parser_expect(state; TOKEN_LEFT_PAREN)
    
    if parser_check(state; TOKEN_RIGHT_PAREN) == 0 then
        while 1 == 1
            Numeric arg_id = 0
            arg_id = parse_expression(state; 0)
            mlp_list_add(argument_ids; arg_id)
            
            if parser_match(state; TOKEN_COMMA) == 0 then
                break
            end_if
        end
    end_if
    
    state = parser_expect(state; TOKEN_RIGHT_PAREN)
    
    return argument_ids
end_function

-- -----------------------------------------------------------------------------
-- Function call
-- -----------------------------------------------------------------------------

function parse_function_call(state; identifier_id)
    Token name_token
    name_token = parser_peek(state)
    String func_name = name_token.lexeme
    
    list arguments = parse_argument_list(state)
    
    Numeric call_id = 0
    call_id = parser_create_node(state; AST_FUNCTION_CALL; "func_call")
    
    ASTFunctionCallData data
    data.node_id = call_id
    data.function_name = func_name
    data.argument_ids = arguments
    data.is_method_call = 0
    data.receiver_id = -1
    
    state.arena = ast_arena_set_data(state.arena; call_id; data)
    
    return call_id
end_function

-- -----------------------------------------------------------------------------
-- Method call (object.method())
-- -----------------------------------------------------------------------------

function parse_method_call(state; receiver_id)
    state = parser_expect(state; TOKEN_DOT)
    
    Token method_token
    method_token = parser_peek(state)
    state = parser_expect(state; TOKEN_IDENTIFIER)
    
    list arguments = parse_argument_list(state)
    
    Numeric call_id = 0
    call_id = parser_create_node(state; AST_FUNCTION_CALL; "method_call")
    
    ASTFunctionCallData data
    data.node_id = call_id
    data.function_name = method_token.lexeme
    data.argument_ids = arguments
    data.is_method_call = 1
    data.receiver_id = receiver_id
    
    state.arena = ast_arena_set_data(state.arena; call_id; data)
    
    return call_id
end_function

-- -----------------------------------------------------------------------------
-- Postfix expression parsing (function calls; method calls; array access)
-- -----------------------------------------------------------------------------

function parse_postfix_expression(state)
    Numeric left_id = 0
    left_id = parse_primary(state)
    
    while 1 == 1
        Token token
        token = parser_peek(state)
        
        if token.type == TOKEN_LEFT_PAREN then
            left_id = parse_function_call(state; left_id)
        else if token.type == TOKEN_DOT then
            left_id = parse_method_call(state; left_id)
        else if token.type == TOKEN_LEFT_BRACKET then
            state = parser_advance(state)
            Numeric index_id = 0
            index_id = parse_expression(state; 0)
            state = parser_expect(state; TOKEN_RIGHT_BRACKET)
            
            Numeric access_id = 0
            access_id = parser_create_node(state; AST_ARRAY_ACCESS; "array_access")
            
            ASTArrayAccessData data
            data.node_id = access_id
            data.array_id = left_id
            data.index_id = index_id
            
            left_id = access_id
        else
            break
        end_if
    end
    
    return left_id
end_function

-- -----------------------------------------------------------------------------
-- Lambda expression
-- -----------------------------------------------------------------------------

function parse_lambda_expression(state)
    state = parser_expect(state; TOKEN_LAMBDA)
    
    list parameters = parse_parameter_list(state)
    
    state = parser_expect(state; TOKEN_ARROW)
    
    state = parser_enter_scope(state)
    Numeric body_id = 0
    body_id = parse_block(state; TOKEN_END)
    state = parser_exit_scope(state)
    
    state = parser_expect(state; TOKEN_END)
    state = parser_expect(state; TOKEN_LAMBDA)
    
    Numeric lambda_id = 0
    lambda_id = parser_create_node(state; AST_LAMBDA; "lambda_expr")
    
    ASTLambdaData data
    data.node_id = lambda_id
    data.parameters = parameters
    data.body_block_id = body_id
    data.capture_list = list()
    
    return lambda_id
end_function

-- -----------------------------------------------------------------------------
-- Async function declaration
-- -----------------------------------------------------------------------------

function parse_async_function(state)
    state = parser_expect(state; TOKEN_ASYNC)
    state = parser_expect(state; TOKEN_FUNCTION)
    
    Token name_token
    name_token = parser_peek(state)
    state = parser_expect(state; TOKEN_IDENTIFIER)
    
    list parameters = parse_parameter_list(state)
    
    String return_type = "numeric"
    if parser_match(state; TOKEN_ARROW) == 1 then
        Token ret_type_token
        ret_type_token = parser_peek(state)
        state = parser_advance(state)
        return_type = ret_type_token.lexeme
    end_if
    
    FunctionSignature sig
    sig.name = name_token.lexeme
    sig.parameter_count = mlp_list_length(parameters)
    sig.parameters = parameters
    sig.return_type = return_type
    
    state.registry = function_registry_register(state.registry; sig)
    
    state = parser_enter_scope(state)
    Numeric body_id = 0
    body_id = parse_block(state; TOKEN_END)
    state = parser_exit_scope(state)
    
    state = parser_expect(state; TOKEN_END)
    state = parser_expect(state; TOKEN_FUNCTION)
    
    Numeric func_id = 0
    func_id = parser_create_node(state; AST_FUNCTION_DECLARATION; "async_func_decl")
    
    ASTFunctionData data
    data.node_id = func_id
    data.name = name_token.lexeme
    data.parameters = parameters
    data.body_block_id = body_id
    data.return_type = return_type
    data.is_async = 1
    data.is_generator = 0
    
    state.arena = ast_arena_set_data(state.arena; func_id; data)
    
    return func_id
end_function

-- -----------------------------------------------------------------------------
-- Await expression
-- -----------------------------------------------------------------------------

function parse_await_expression(state)
    state = parser_expect(state; TOKEN_AWAIT)
    Numeric expr_id = 0
    expr_id = parse_expression(state; 0)
    
    Numeric await_id = 0
    await_id = parser_create_node(state; AST_AWAIT; "await_expr")
    
    ASTAwaitData data
    data.node_id = await_id
    data.expression_id = expr_id
    
    return await_id
end_function

-- -----------------------------------------------------------------------------
-- Yield expression
-- -----------------------------------------------------------------------------

function parse_yield_expression(state)
    state = parser_expect(state; TOKEN_YIELD)
    Numeric expr_id = 0
    expr_id = parse_expression(state; 0)
    
    Numeric yield_id = 0
    yield_id = parser_create_node(state; AST_YIELD; "yield_expr")
    
    ASTYieldData data
    data.node_id = yield_id
    data.expression_id = expr_id
    
    return yield_id
end_function
