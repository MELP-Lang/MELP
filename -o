; MELP Program - Generated LLVM IR
; Compiler: MELP Stage 0 with LLVM Backend
; Date: 13 AralÄ±k 2025

; Type definitions
%sto_value = type { i8, i64 }

; MLP Standard Library - I/O Functions
; void mlp_println_numeric(void* value, uint8_t sto_type)
declare void @mlp_println_numeric(i8*, i8)
; void mlp_println_string(const char* str)
declare void @mlp_println_string(i8*)

; C Standard Library - Memory Allocation
; void* malloc(size_t size)
declare i8* @malloc(i64)

; MLP Standard Library - List Functions (YZ_200)
; MelpList* melp_list_create(size_t element_size)
declare i8* @melp_list_create(i64)
; int melp_list_append(MelpList* list, void* element)
declare i32 @melp_list_append(i8*, i8*)
; int melp_list_prepend(MelpList* list, void* element)
declare i32 @melp_list_prepend(i8*, i8*)
; size_t melp_list_length(MelpList* list)
declare i64 @melp_list_length(i8*)
; void* melp_list_get(MelpList* list, size_t index)
declare i8* @melp_list_get(i8*, i64)
; int melp_list_set(MelpList* list, size_t index, void* element)
declare i32 @melp_list_set(i8*, i64, i8*)

; MLP Standard Library - Map Functions (YZ_201)
; MelpMap* melp_map_create(size_t value_size)
declare i8* @melp_map_create(i64)
; int melp_map_insert(MelpMap* map, const char* key, const void* value)
declare i32 @melp_map_insert(i8*, i8*, i8*)
; void* melp_map_get(MelpMap* map, const char* key)
declare i8* @melp_map_get(i8*, i8*)
; int melp_map_remove(MelpMap* map, const char* key)
declare i32 @melp_map_remove(i8*, i8*)
; int melp_map_has_key(MelpMap* map, const char* key)
declare i32 @melp_map_has_key(i8*, i8*)
; size_t melp_map_length(MelpMap* map)
declare i64 @melp_map_length(i8*)


; Function: main
define i64 @main() {
entry:
    %T_IMPORT = alloca i64, align 8
    store i64 22, i64* %T_IMPORT, align 8
    %T_FUNCTION = alloca i64, align 8
    store i64 1, i64* %T_FUNCTION, align 8
    %T_END = alloca i64, align 8
    store i64 2, i64* %T_END, align 8
    %T_STRUCT = alloca i64, align 8
    store i64 20, i64* %T_STRUCT, align 8
    %T_ENUM = alloca i64, align 8
    store i64 21, i64* %T_ENUM, align 8
    %T_NUMERIC = alloca i64, align 8
    store i64 10, i64* %T_NUMERIC, align 8
    %T_STRING = alloca i64, align 8
    store i64 11, i64* %T_STRING, align 8
    %T_RETURNS = alloca i64, align 8
    store i64 9, i64* %T_RETURNS, align 8
    %T_RETURN = alloca i64, align 8
    store i64 14, i64* %T_RETURN, align 8
    %T_IF = alloca i64, align 8
    store i64 3, i64* %T_IF, align 8
    %T_THEN = alloca i64, align 8
    store i64 4, i64* %T_THEN, align 8
    %T_ELSE = alloca i64, align 8
    store i64 5, i64* %T_ELSE, align 8
    %T_LPAREN = alloca i64, align 8
    store i64 50, i64* %T_LPAREN, align 8
    %T_RPAREN = alloca i64, align 8
    store i64 51, i64* %T_RPAREN, align 8
    %T_COMMA = alloca i64, align 8
    store i64 52, i64* %T_COMMA, align 8
    %T_ID = alloca i64, align 8
    store i64 32, i64* %T_ID, align 8
    %T_NUMBER = alloca i64, align 8
    store i64 61, i64* %T_NUMBER, align 8
    %T_PLUS = alloca i64, align 8
    store i64 37, i64* %T_PLUS, align 8
    %T_GT = alloca i64, align 8
    store i64 45, i64* %T_GT, align 8
    %T_ASSIGN = alloca i64, align 8
    store i64 8, i64* %T_ASSIGN, align 8
    %T_SWITCH = alloca i64, align 8
    store i64 18, i64* %T_SWITCH, align 8
    %T_CASE = alloca i64, align 8
    store i64 19, i64* %T_CASE, align 8
    %T_DEFAULT = alloca i64, align 8
    store i64 25, i64* %T_DEFAULT, align 8
    %T_COLON = alloca i64, align 8
    store i64 56, i64* %T_COLON, align 8
    %T_FOR = alloca i64, align 8
    store i64 7, i64* %T_FOR, align 8
    %T_FROM = alloca i64, align 8
    store i64 43, i64* %T_FROM, align 8
    %T_TO = alloca i64, align 8
    store i64 44, i64* %T_TO, align 8
    %T_LBRACKET = alloca i64, align 8
    store i64 53, i64* %T_LBRACKET, align 8
    %T_RBRACKET = alloca i64, align 8
    store i64 54, i64* %T_RBRACKET, align 8
    %passed = alloca i64, align 8
    store i64 0, i64* %passed, align 8
    %failed = alloca i64, align 8
    store i64 0, i64* %failed, align 8
    %tmp1 = getelementptr inbounds [25 x i8], [25 x i8]* @.str.1, i64 0, i64 0
    %tmp2 = getelementptr inbounds [5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0
    call i32 (i8*, ...) @printf(i8* %tmp2, i64 %tmp1)
    %tmp3 = getelementptr inbounds [19 x i8], [19 x i8]* @.str.2, i64 0, i64 0
    %tmp4 = getelementptr inbounds [5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0
    call i32 (i8*, ...) @printf(i8* %tmp4, i64 %tmp3)
    %tmp5 = getelementptr inbounds [1 x i8], [1 x i8]* @.str.3, i64 0, i64 0
    %tmp6 = getelementptr inbounds [5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0
    call i32 (i8*, ...) @printf(i8* %tmp6, i64 %tmp5)
}

; String Constants
@.str.1 = private unnamed_addr constant [25 x i8] c"Test 1: Import Statement\00", align 1
@.str.2 = private unnamed_addr constant [19 x i8] c"Code: import lexer\00", align 1
@.str.3 = private unnamed_addr constant [1 x i8] c"\00", align 1

