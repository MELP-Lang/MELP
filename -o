; MELP Program - Generated LLVM IR
; Compiler: MELP Stage 0 with LLVM Backend
; Date: 13 AralÄ±k 2025

; Type definitions
%sto_value = type { i8, i64 }

; MLP Standard Library - I/O Functions
; void mlp_println_numeric(void* value, uint8_t sto_type)
declare void @mlp_println_numeric(i8*, i8)
; void mlp_println_string(const char* str)
declare void @mlp_println_string(i8*)

; C Standard Library - Memory Allocation
; void* malloc(size_t size)
declare i8* @malloc(i64)

; MLP Standard Library - String Functions (Task 0.2 + 0.3)
; char* mlp_string_concat(const char* str1, const char* str2)
declare i8* @mlp_string_concat(i8*, i8*)
; char* mlp_string_char_at(const char* str, size_t index)
declare i8* @mlp_string_char_at(i8*, i64)

; MLP Standard Library - List Functions (YZ_200)
; MelpList* melp_list_create(size_t element_size)
declare i8* @melp_list_create(i64)
; int melp_list_append(MelpList* list, void* element)
declare i32 @melp_list_append(i8*, i8*)
; int melp_list_prepend(MelpList* list, void* element)
declare i32 @melp_list_prepend(i8*, i8*)
; size_t melp_list_length(MelpList* list)
declare i64 @melp_list_length(i8*)
; void* melp_list_get(MelpList* list, size_t index)
declare i8* @melp_list_get(i8*, i64)
; int melp_list_set(MelpList* list, size_t index, void* element)
declare i32 @melp_list_set(i8*, i64, i8*)

; MLP Standard Library - Map Functions (YZ_201)
; MelpMap* melp_map_create(size_t value_size)
declare i8* @melp_map_create(i64)
; int melp_map_insert(MelpMap* map, const char* key, const void* value)
declare i32 @melp_map_insert(i8*, i8*, i8*)
; void* melp_map_get(MelpMap* map, const char* key)
declare i8* @melp_map_get(i8*, i8*)
; int melp_map_remove(MelpMap* map, const char* key)
declare i32 @melp_map_remove(i8*, i8*)
; int melp_map_has_key(MelpMap* map, const char* key)
declare i32 @melp_map_has_key(i8*, i8*)
; size_t melp_map_length(MelpMap* map)
declare i64 @melp_map_length(i8*)


; Function: add
define i64 @add(i64 %a, i64 %b) {
entry:
    %tmp1 = add nsw i64 %a, %b
    ret i64 %tmp1
}

; Function: multiply
define i64 @multiply(i64 %x, i64 %y) {
entry:
    %tmp2 = mul nsw i64 %x, %y
    ret i64 %tmp2
}

; Function: calculate
define i64 @calculate() {
entry:
    %a = alloca i64, align 8
    store i64 10, i64* %a, align 8
    %b = alloca i64, align 8
    store i64 20, i64* %b, align 8
    %sum = alloca i64, align 8
    store i64 0, i64* %sum, align 8
    %product = alloca i64, align 8
    store i64 0, i64* %product, align 8
    %tmp3 = load i64, i64* %a, align 8
    %tmp4 = load i64, i64* %b, align 8
    %tmp5 = call i64 @add(i64 %tmp3, i64 %tmp4)
    store i64 %tmp5, i64* %sum, align 8
    %tmp6 = load i64, i64* %a, align 8
    %tmp7 = load i64, i64* %b, align 8
    %tmp8 = call i64 @multiply(i64 %tmp6, i64 %tmp7)
    store i64 %tmp8, i64* %product, align 8
    %tmp9 = load i64, i64* %sum, align 8
    %tmp10 = load i64, i64* %product, align 8
    %tmp11 = add nsw i64 %tmp9, %tmp10
    ret i64 %tmp11
}

; Function: main
define i64 @main() {
entry:
    %result = alloca i64, align 8
    store i64 0, i64* %result, align 8
    %tmp12 = call i64 @calculate()
    store i64 %tmp12, i64* %result, align 8
    %tmp13 = load i64, i64* %result, align 8
    ret i64 %tmp13
}
