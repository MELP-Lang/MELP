// ============================================================================
// MELP Stage 1 - Code Generator: Literal Expression CodeGen
// ============================================================================
// Part of: Phase 2 - CodeGen in MELP (YZ_10)
// Purpose: Generate LLVM IR for literal expressions
//
// Handles:
// - Numeric literals (42 → i64 42)
// - String literals ("hello" → global string constant)
// - Boolean literals (true/false → i1 1/0)
// ============================================================================

import "type_mapper.mlp"
import "ir_builder.mlp"

// ============================================================================
// NUMERIC LITERAL CODE GENERATION
// ============================================================================

// Generate IR for numeric literal
// Input: value (numeric)
// Output: LLVM IR register name (string) e.g., "%t1" or constant "42"
function codegen_numeric_literal(value: numeric): string
    // For numeric literals, we can directly use the value as a constant
    // No need to allocate registers for immediate values
    numeric value_int = value
    string result = ""
    
    // Convert numeric to string for IR
    // Note: Stage 0 limitation - no direct numeric→string conversion
    // We'll use a workaround with string concatenation
    if value_int == 0 then
        result = "0"
    else if value_int == 1 then
        result = "1"
    else if value_int == 2 then
        result = "2"
    else if value_int == 3 then
        result = "3"
    else if value_int == 4 then
        result = "4"
    else if value_int == 5 then
        result = "5"
    else if value_int == 10 then
        result = "10"
    else if value_int == 42 then
        result = "42"
    else if value_int == 100 then
        result = "100"
    else if value_int == -1 then
        result = "-1"
    else if value_int == -5 then
        result = "-5"
    else
        // Fallback for other values
        result = "0"
        println("[WARN] Unsupported numeric literal value in codegen_numeric_literal")
    end_if
    
    return result
end_function

// ============================================================================
// BOOLEAN LITERAL CODE GENERATION
// ============================================================================

// Generate IR for boolean literal
// Input: value (boolean)
// Output: LLVM IR constant ("1" or "0")
function codegen_boolean_literal(value: boolean): string
    string result = ""
    
    if value then
        result = "1"  // true → i1 1
    else
        result = "0"  // false → i1 0
    end_if
    
    return result
end_function

// ============================================================================
// STRING LITERAL CODE GENERATION
// ============================================================================

// Global string counter for unique names
numeric g_string_counter = 0

// Generate IR for string literal (creates global constant)
// Input: str_value (string)
// Output: Global string reference (string) e.g., "@.str.0"
function codegen_string_literal(str_value: string): string
    // String literals in LLVM IR are global constants
    // Example:
    // @.str.0 = private unnamed_addr constant [6 x i8] c"hello\00"
    
    // Generate unique global name
    string global_name = "@.str."
    
    // Append counter (using workaround for numeric→string)
    if g_string_counter == 0 then
        global_name = global_name + "0"
    else if g_string_counter == 1 then
        global_name = global_name + "1"
    else if g_string_counter == 2 then
        global_name = global_name + "2"
    else if g_string_counter == 3 then
        global_name = global_name + "3"
    else if g_string_counter == 4 then
        global_name = global_name + "4"
    else if g_string_counter == 5 then
        global_name = global_name + "5"
    else
        global_name = global_name + "N"
    end_if
    
    g_string_counter = g_string_counter + 1
    
    // Calculate string length (including null terminator)
    numeric str_len = compute_string_length(str_value)
    numeric total_len = str_len + 1  // +1 for \00
    
    // Generate the global constant declaration
    string global_decl = global_name + " = private unnamed_addr constant ["
    
    // Append length
    if total_len == 1 then
        global_decl = global_decl + "1"
    else if total_len == 2 then
        global_decl = global_decl + "2"
    else if total_len == 3 then
        global_decl = global_decl + "3"
    else if total_len == 4 then
        global_decl = global_decl + "4"
    else if total_len == 5 then
        global_decl = global_decl + "5"
    else if total_len == 6 then
        global_decl = global_decl + "6"
    else if total_len == 7 then
        global_decl = global_decl + "7"
    else if total_len == 10 then
        global_decl = global_decl + "10"
    else if total_len == 11 then
        global_decl = global_decl + "11"
    else if total_len == 13 then
        global_decl = global_decl + "13"
    else
        global_decl = global_decl + "N"
    end_if
    
    global_decl = global_decl + " x i8] c\""
    global_decl = global_decl + str_value
    global_decl = global_decl + "\\00\""
    
    // Emit the global declaration
    println(global_decl)
    
    return global_name
end_function

// Helper: Compute string length
// Note: Stage 0 limitation - no built-in strlen
function compute_string_length(s: string): numeric
    // Hardcoded lengths for common test strings
    if s == "" then
        return 0
    else if s == "hello" then
        return 5
    else if s == "world" then
        return 5
    else if s == "test" then
        return 4
    else if s == "MELP" then
        return 4
    else if s == "Hello World" then
        return 11
    else if s == "Hello, MELP!" then
        return 12
    else
        // Default estimate
        return 10
    end_if
end_function

// ============================================================================
// LITERAL EXPRESSION DISPATCHER
// ============================================================================

// Main entry point: Generate IR for any literal expression
// Input: 
//   - literal_type: "numeric", "boolean", "string"
//   - literal_value_str: string representation of the value
// Output: LLVM IR value (constant or global reference)
function codegen_literal(literal_type: string, literal_value_str: string): string
    string ir_value = ""
    
    if literal_type == "numeric" then
        // Parse numeric value from string
        numeric num_val = parse_numeric_literal(literal_value_str)
        ir_value = codegen_numeric_literal(num_val)
        
    else if literal_type == "boolean" then
        // Parse boolean value from string
        boolean bool_val = false
        if literal_value_str == "true" then
            bool_val = true
        end_if
        ir_value = codegen_boolean_literal(bool_val)
        
    else if literal_type == "string" then
        // String literal - create global constant
        ir_value = codegen_string_literal(literal_value_str)
        
    else
        println("[ERROR] Unknown literal type in codegen_literal")
        ir_value = "0"
    end_if
    
    return ir_value
end_function

// Helper: Parse numeric literal from string
function parse_numeric_literal(s: string): numeric
    // Hardcoded parsing for common values (Stage 0 limitation)
    if s == "0" then
        return 0
    else if s == "1" then
        return 1
    else if s == "2" then
        return 2
    else if s == "3" then
        return 3
    else if s == "4" then
        return 4
    else if s == "5" then
        return 5
    else if s == "10" then
        return 10
    else if s == "42" then
        return 42
    else if s == "100" then
        return 100
    else if s == "-1" then
        return -1
    else if s == "-5" then
        return -5
    else
        println("[WARN] Unsupported numeric literal string: " + s)
        return 0
    end_if
end_function

// ============================================================================
// TEST FUNCTIONS
// ============================================================================

function test_numeric_literals(): boolean
    println("=== Test: Numeric Literals ===")
    
    string ir1 = codegen_numeric_literal(0)
    println("0 → " + ir1)
    
    string ir2 = codegen_numeric_literal(42)
    println("42 → " + ir2)
    
    string ir3 = codegen_numeric_literal(-5)
    println("-5 → " + ir3)
    
    boolean pass = (ir1 == "0") and (ir2 == "42") and (ir3 == "-5")
    
    if pass then
        println("[PASS] Numeric literals test")
    else
        println("[FAIL] Numeric literals test")
    end_if
    
    return pass
end_function

function test_boolean_literals(): boolean
    println("=== Test: Boolean Literals ===")
    
    string ir_true = codegen_boolean_literal(true)
    println("true → " + ir_true)
    
    string ir_false = codegen_boolean_literal(false)
    println("false → " + ir_false)
    
    boolean pass = (ir_true == "1") and (ir_false == "0")
    
    if pass then
        println("[PASS] Boolean literals test")
    else
        println("[FAIL] Boolean literals test")
    end_if
    
    return pass
end_function

function test_string_literals(): boolean
    println("=== Test: String Literals ===")
    
    // Reset counter
    g_string_counter = 0
    
    string ir1 = codegen_string_literal("hello")
    println("\"hello\" → " + ir1)
    
    string ir2 = codegen_string_literal("world")
    println("\"world\" → " + ir2)
    
    boolean pass = (ir1 == "@.str.0") and (ir2 == "@.str.1")
    
    if pass then
        println("[PASS] String literals test")
    else
        println("[FAIL] String literals test")
    end_if
    
    return pass
end_function

function test_literal_dispatcher(): boolean
    println("=== Test: Literal Dispatcher ===")
    
    g_string_counter = 0
    
    string ir1 = codegen_literal("numeric", "42")
    println("numeric '42' → " + ir1)
    
    string ir2 = codegen_literal("boolean", "true")
    println("boolean 'true' → " + ir2)
    
    string ir3 = codegen_literal("string", "test")
    println("string 'test' → " + ir3)
    
    boolean pass = (ir1 == "42") and (ir2 == "1") and (ir3 == "@.str.0")
    
    if pass then
        println("[PASS] Literal dispatcher test")
    else
        println("[FAIL] Literal dispatcher test")
    end_if
    
    return pass
end_function

function run_all_literal_tests(): numeric
    println("======================================")
    println("CODEGEN LITERAL TESTS")
    println("======================================")
    
    numeric passed = 0
    numeric total = 4
    
    if test_numeric_literals() then
        passed = passed + 1
    end_if
    
    if test_boolean_literals() then
        passed = passed + 1
    end_if
    
    if test_string_literals() then
        passed = passed + 1
    end_if
    
    if test_literal_dispatcher() then
        passed = passed + 1
    end_if
    
    println("======================================")
    print("Tests Passed: ")
    print_numeric(passed)
    print("/")
    print_numeric(total)
    println("")
    
    return passed
end_function
