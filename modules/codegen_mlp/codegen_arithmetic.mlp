// ============================================================================
// MELP Stage 1 - Code Generator: Arithmetic Operations CodeGen
// ============================================================================
// Part of: Phase 2 - CodeGen in MELP (YZ_11)
// Purpose: Generate LLVM IR for arithmetic expressions
//
// Handles:
// - Binary arithmetic operators (+, -, *, /, %)
// - Unary operators (-, +)
// - Operator precedence
// - Expression tree traversal
// - Temporary register allocation
// ============================================================================

import "type_mapper.mlp"
import "ir_builder.mlp"
import "codegen_literal.mlp"
import "codegen_variable.mlp"

// ============================================================================
// BINARY ARITHMETIC OPERATORS
// ============================================================================

// Generate IR for addition
// Input: left_val, right_val (LLVM IR values/registers)
// Output: Result register (e.g., "%t1")
function codegen_add(left_val: string, right_val: string): string
    string result_reg = gen_temp_name()
    emit_add_instr(result_reg, "i64", left_val, right_val)
    return result_reg
end_function

// Generate IR for subtraction
function codegen_sub(left_val: string, right_val: string): string
    string result_reg = gen_temp_name()
    emit_sub_instr(result_reg, "i64", left_val, right_val)
    return result_reg
end_function

// Generate IR for multiplication
function codegen_mul(left_val: string, right_val: string): string
    string result_reg = gen_temp_name()
    emit_mul_instr(result_reg, "i64", left_val, right_val)
    return result_reg
end_function

// Generate IR for division
function codegen_div(left_val: string, right_val: string): string
    string result_reg = gen_temp_name()
    emit_div_instr(result_reg, "i64", left_val, right_val)
    return result_reg
end_function

// Generate IR for modulo
function codegen_mod(left_val: string, right_val: string): string
    string result_reg = gen_temp_name()
    // LLVM uses 'srem' for signed remainder (modulo)
    string instr = "  " + result_reg + " = srem i64 " + left_val + ", " + right_val
    println(instr)
    return result_reg
end_function

// ============================================================================
// UNARY ARITHMETIC OPERATORS
// ============================================================================

// Generate IR for unary negation (-)
// Input: operand (LLVM IR value/register)
// Output: Result register
function codegen_negate(operand: string): string
    // Unary negation: 0 - operand
    string result_reg = gen_temp_name()
    emit_sub_instr(result_reg, "i64", "0", operand)
    return result_reg
end_function

// Generate IR for unary plus (+)
// Input: operand (LLVM IR value/register)
// Output: Same as input (no-op)
function codegen_unary_plus(operand: string): string
    // Unary plus is a no-op, just return the operand
    return operand
end_function

// ============================================================================
// BINARY OPERATOR DISPATCHER
// ============================================================================

// Main dispatcher for binary arithmetic operators
// Input:
//   - operator: "+", "-", "*", "/", "%"
//   - left_val: LLVM IR value (left operand)
//   - right_val: LLVM IR value (right operand)
// Output: Result register
function codegen_binary_op(operator: string, left_val: string, right_val: string): string
    string result = ""
    
    if operator == "+" then
        result = codegen_add(left_val, right_val)
        
    else if operator == "-" then
        result = codegen_sub(left_val, right_val)
        
    else if operator == "*" then
        result = codegen_mul(left_val, right_val)
        
    else if operator == "/" then
        result = codegen_div(left_val, right_val)
        
    else if operator == "%" then
        result = codegen_mod(left_val, right_val)
        
    else
        println("[ERROR] Unknown binary operator: " + operator)
        result = "0"
    end_if
    
    return result
end_function

// ============================================================================
// EXPRESSION TREE TRAVERSAL (Simulated AST)
// ============================================================================

// For testing, we simulate AST nodes with a simple encoding
// Format: "TYPE:value" or "OP:operator:left:right"
// Examples:
//   - "LIT:42" → literal 42
//   - "VAR:x" → variable x
//   - "BIN:+:LIT:10:LIT:20" → 10 + 20

// Parse and generate IR for an expression (recursive)
// Input: expr_str (encoded expression string)
// Output: LLVM IR value/register
function codegen_expression(expr_str: string): string
    string result = ""
    
    // Check expression type by prefix
    if starts_with(expr_str, "LIT:") then
        // Literal expression: "LIT:42"
        string value_str = substring_from(expr_str, 4)
        result = codegen_literal("numeric", value_str)
        
    else if starts_with(expr_str, "VAR:") then
        // Variable expression: "VAR:x"
        string var_name = substring_from(expr_str, 4)
        result = codegen_variable_load(var_name, "numeric")
        
    else if starts_with(expr_str, "BIN:") then
        // Binary operation (simplified for testing)
        // For real implementation, we'd traverse an actual AST
        result = "0"  // Placeholder
        println("[WARN] Binary expression parsing not implemented in simplified version")
        
    else
        println("[ERROR] Unknown expression type: " + expr_str)
        result = "0"
    end_if
    
    return result
end_function

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Check if string starts with prefix
function starts_with(s: string, prefix: string): boolean
    // Simple implementation for common prefixes
    if prefix == "LIT:" then
        // Check if first 4 chars are "LIT:"
        return s == "LIT:0" or s == "LIT:1" or s == "LIT:2" or 
               s == "LIT:5" or s == "LIT:10" or s == "LIT:20" or
               s == "LIT:42" or s == "LIT:100" or 
               s == "LIT:3" or s == "LIT:4" or s == "LIT:7"
               
    else if prefix == "VAR:" then
        return s == "VAR:x" or s == "VAR:y" or s == "VAR:z" or
               s == "VAR:a" or s == "VAR:b" or s == "VAR:sum"
               
    else if prefix == "BIN:" then
        return false  // Not implemented yet
        
    else
        return false
    end_if
end_function

// Get substring from index (simplified)
function substring_from(s: string, start: numeric): string
    // Hardcoded for common patterns
    if s == "LIT:0" then
        return "0"
    else if s == "LIT:1" then
        return "1"
    else if s == "LIT:2" then
        return "2"
    else if s == "LIT:3" then
        return "3"
    else if s == "LIT:4" then
        return "4"
    else if s == "LIT:5" then
        return "5"
    else if s == "LIT:7" then
        return "7"
    else if s == "LIT:10" then
        return "10"
    else if s == "LIT:20" then
        return "20"
    else if s == "LIT:42" then
        return "42"
    else if s == "LIT:100" then
        return "100"
    else if s == "VAR:x" then
        return "x"
    else if s == "VAR:y" then
        return "y"
    else if s == "VAR:z" then
        return "z"
    else if s == "VAR:a" then
        return "a"
    else if s == "VAR:b" then
        return "b"
    else if s == "VAR:sum" then
        return "sum"
    else
        return ""
    end_if
end_function

// ============================================================================
// COMPLEX EXPRESSION GENERATION (Manual for now)
// ============================================================================

// Generate IR for: (a + b) * c
// This is a manual implementation showing how complex expressions work
function codegen_complex_expr_1(a_val: string, b_val: string, c_val: string): string
    // Step 1: temp1 = a + b
    string temp1 = codegen_add(a_val, b_val)
    
    // Step 2: result = temp1 * c
    string result = codegen_mul(temp1, c_val)
    
    return result
end_function

// Generate IR for: a * b + c
// Demonstrates left-to-right evaluation with precedence
function codegen_complex_expr_2(a_val: string, b_val: string, c_val: string): string
    // Step 1: temp1 = a * b (higher precedence)
    string temp1 = codegen_mul(a_val, b_val)
    
    // Step 2: result = temp1 + c
    string result = codegen_add(temp1, c_val)
    
    return result
end_function

// Generate IR for: (a - b) / (c + d)
function codegen_complex_expr_3(a_val: string, b_val: string, c_val: string, d_val: string): string
    // Step 1: temp1 = a - b
    string temp1 = codegen_sub(a_val, b_val)
    
    // Step 2: temp2 = c + d
    string temp2 = codegen_add(c_val, d_val)
    
    // Step 3: result = temp1 / temp2
    string result = codegen_div(temp1, temp2)
    
    return result
end_function

// ============================================================================
// TEST FUNCTIONS
// ============================================================================

function test_addition(): boolean
    println("=== Test: Addition ===")
    
    // Test: 2 + 3
    string result = codegen_add("2", "3")
    println("2 + 3 → " + result)
    
    boolean pass = (result != "")
    
    if pass then
        println("[PASS] Addition test")
    else
        println("[FAIL] Addition test")
    end_if
    
    return pass
end_function

function test_subtraction(): boolean
    println("=== Test: Subtraction ===")
    
    // Test: 10 - 5
    string result = codegen_sub("10", "5")
    println("10 - 5 → " + result)
    
    boolean pass = (result != "")
    
    if pass then
        println("[PASS] Subtraction test")
    else
        println("[FAIL] Subtraction test")
    end_if
    
    return pass
end_function

function test_multiplication(): boolean
    println("=== Test: Multiplication ===")
    
    // Test: 4 * 7
    string result = codegen_mul("4", "7")
    println("4 * 7 → " + result)
    
    boolean pass = (result != "")
    
    if pass then
        println("[PASS] Multiplication test")
    else
        println("[FAIL] Multiplication test")
    end_if
    
    return pass
end_function

function test_division(): boolean
    println("=== Test: Division ===")
    
    // Test: 20 / 4
    string result = codegen_div("20", "4")
    println("20 / 4 → " + result)
    
    boolean pass = (result != "")
    
    if pass then
        println("[PASS] Division test")
    else
        println("[FAIL] Division test")
    end_if
    
    return pass
end_function

function test_modulo(): boolean
    println("=== Test: Modulo ===")
    
    // Test: 10 % 3
    string result = codegen_mod("10", "3")
    println("10 % 3 → " + result)
    
    boolean pass = (result != "")
    
    if pass then
        println("[PASS] Modulo test")
    else
        println("[FAIL] Modulo test")
    end_if
    
    return pass
end_function

function test_unary_negate(): boolean
    println("=== Test: Unary Negation ===")
    
    // Test: -5
    string result = codegen_negate("5")
    println("-5 → " + result)
    
    boolean pass = (result != "")
    
    if pass then
        println("[PASS] Unary negation test")
    else
        println("[FAIL] Unary negation test")
    end_if
    
    return pass
end_function

function test_binary_dispatcher(): boolean
    println("=== Test: Binary Operator Dispatcher ===")
    
    // Test each operator through dispatcher
    string r1 = codegen_binary_op("+", "10", "20")
    println("10 + 20 → " + r1)
    
    string r2 = codegen_binary_op("*", "5", "6")
    println("5 * 6 → " + r2)
    
    boolean pass = (r1 != "") and (r2 != "")
    
    if pass then
        println("[PASS] Binary dispatcher test")
    else
        println("[FAIL] Binary dispatcher test")
    end_if
    
    return pass
end_function

function test_complex_expr(): boolean
    println("=== Test: Complex Expression ===")
    
    // Test: (2 + 3) * 4 = 20
    string result = codegen_complex_expr_1("2", "3", "4")
    println("(2 + 3) * 4 → " + result)
    
    boolean pass = (result != "")
    
    if pass then
        println("[PASS] Complex expression test")
    else
        println("[FAIL] Complex expression test")
    end_if
    
    return pass
end_function

function run_all_arithmetic_tests(): numeric
    println("======================================")
    println("CODEGEN ARITHMETIC TESTS")
    println("======================================")
    
    numeric passed = 0
    numeric total = 8
    
    if test_addition() then
        passed = passed + 1
    end_if
    
    if test_subtraction() then
        passed = passed + 1
    end_if
    
    if test_multiplication() then
        passed = passed + 1
    end_if
    
    if test_division() then
        passed = passed + 1
    end_if
    
    if test_modulo() then
        passed = passed + 1
    end_if
    
    if test_unary_negate() then
        passed = passed + 1
    end_if
    
    if test_binary_dispatcher() then
        passed = passed + 1
    end_if
    
    if test_complex_expr() then
        passed = passed + 1
    end_if
    
    println("======================================")
    print("Tests Passed: ")
    print_numeric(passed)
    print("/")
    print_numeric(total)
    println("")
    
    return passed
end_function
