-- ============================================================================
-- MELP Self-Hosting: Identifier & Keyword Recognition
-- File: modules/lexer_mlp/tokenize_identifiers.mlp
-- Author: YZ_47
-- Date: 12 AralÄ±k 2025
-- Purpose: Scan identifiers and recognize keywords from source code
-- ============================================================================

-- Dependencies:
-- - token.mlp: create_token(), token type constants
-- - char_utils.mlp: is_alpha(), is_alphanumeric()

-- ============================================================================
-- Token Type Constants (from token.mlp)
-- ============================================================================
-- Keywords (1-19):
--   FUNCTION=1, END=2, IF=3, ELSE=4, ELSEIF=5, WHILE=6, FOR=7
--   EACH=8, IN=9, TO=10, DOWNTO=11, EXIT=12, RETURN=13, IMPORT=14
--   STRUCT=15, TRY=16, CATCH=17, FINALLY=18, THROW=19
-- Type Keywords (20-24):
--   NUMERIC=20, TEXT=21, BOOLEAN=22, VOID=23, ANY=24
-- Compound Keywords (25-29):
--   RETURNS=25, THEN=26, AND=27, OR=28, NOT=29
-- Literals:
--   IDENTIFIER=32, TRUE=33, FALSE=34
-- Special:
--   LIST=35, TUPLE=36, ARRAY=37

-- ============================================================================
-- Keyword Lookup Table
-- ============================================================================

-- Returns token type for keyword, or 0 if not a keyword
-- This is the core keyword recognition function
function get_keyword_type(string word) returns numeric
    -- Control flow keywords
    if word == "function" then return 1 end if
    if word == "end" then return 2 end if
    if word == "if" then return 3 end if
    if word == "else" then return 4 end if
    if word == "elseif" then return 5 end if
    if word == "while" then return 6 end if
    if word == "for" then return 7 end if
    if word == "each" then return 8 end if
    if word == "in" then return 9 end if
    if word == "to" then return 10 end if
    if word == "downto" then return 11 end if
    if word == "exit" then return 12 end if
    if word == "return" then return 13 end if
    if word == "import" then return 14 end if
    
    -- Struct/Exception keywords
    if word == "struct" then return 15 end if
    if word == "try" then return 16 end if
    if word == "catch" then return 17 end if
    if word == "finally" then return 18 end if
    if word == "throw" then return 19 end if
    
    -- Type keywords
    if word == "numeric" then return 20 end if
    if word == "text" then return 21 end if
    if word == "string" then return 21 end if
    if word == "boolean" then return 22 end if
    if word == "void" then return 23 end if
    if word == "any" then return 24 end if
    
    -- Compound keywords
    if word == "returns" then return 25 end if
    if word == "then" then return 26 end if
    if word == "and" then return 27 end if
    if word == "or" then return 28 end if
    if word == "not" then return 29 end if
    
    -- Boolean literals
    if word == "true" then return 33 end if
    if word == "false" then return 34 end if
    
    -- Collection type keywords
    if word == "list" then return 35 end if
    if word == "tuple" then return 36 end if
    if word == "array" then return 37 end if
    
    -- Not a keyword
    return 0
end function

-- ============================================================================
-- Check if word is a keyword
-- ============================================================================

function is_keyword(string word) returns boolean
    numeric token_type = get_keyword_type(word)
    if token_type > 0 then
        return true
    end if
    return false
end function

-- ============================================================================
-- Identifier Scanning
-- ============================================================================

-- Scan an identifier from source starting at position pos
-- Pattern: [a-zA-Z_][a-zA-Z0-9_]*
-- Returns: list [token, new_position]
-- Token type is keyword type if keyword, else IDENTIFIER (32)
function scan_identifier(string source, numeric pos) returns list
    numeric start_pos = pos
    numeric source_len = length(source)
    string ident_str = ""
    
    -- Check if we have valid starting character (letter or underscore)
    if pos >= source_len then
        return (0; pos;)
    end if
    
    string first_char = substring(source, pos, 1)
    if is_alpha(first_char) == false then
        return (0; pos;)
    end if
    
    -- Collect identifier characters
    while pos < source_len
        string current_char = substring(source, pos, 1)
        if is_alphanumeric(current_char) then
            ident_str = ident_str + current_char
            pos = pos + 1
        else
            exit while
        end if
    end while
    
    -- Check if it's a keyword
    numeric keyword_type = get_keyword_type(ident_str)
    numeric token_type = 32
    
    if keyword_type > 0 then
        token_type = keyword_type
    end if
    
    -- Create token: [type, value, line, column]
    list token = (token_type; ident_str; 1; start_pos;)
    
    return (token; pos;)
end function

-- ============================================================================
-- Helper: Check if character can start an identifier
-- ============================================================================

function is_identifier_start(string c) returns boolean
    return is_alpha(c)
end function

-- ============================================================================
-- Helper: Check if character can continue an identifier
-- ============================================================================

function is_identifier_continue(string c) returns boolean
    return is_alphanumeric(c)
end function

-- ============================================================================
-- Compound Keyword Support (PMPL - end_if, end_function, etc.)
-- ============================================================================

-- MELP uses PMPL (Pragmatic MLP) where "end if" becomes single token "end_if"
-- This is handled by the lexer's token merging, but we can also support it here

-- Check if we have a compound keyword starting with "end"
-- Returns: compound token type or 0
function check_compound_end(string next_word) returns numeric
    if next_word == "if" then return 31 end if
    if next_word == "function" then return 34 end if
    if next_word == "while" then return 38 end if
    if next_word == "for" then return 39 end if
    
    return 0
end function

-- Check if we have a compound keyword starting with "exit"
function check_compound_exit(string next_word) returns numeric
    if next_word == "if" then return 40 end if
    if next_word == "function" then return 41 end if
    if next_word == "while" then return 42 end if
    if next_word == "for" then return 43 end if
    
    return 0
end function

-- ============================================================================
-- Reserved Word Categories
-- ============================================================================

-- Check if word is a type keyword
function is_type_keyword(string word) returns boolean
    if word == "numeric" then return true end if
    if word == "text" then return true end if
    if word == "string" then return true end if
    if word == "boolean" then return true end if
    if word == "void" then return true end if
    if word == "any" then return true end if
    if word == "list" then return true end if
    if word == "tuple" then return true end if
    if word == "array" then return true end if
    return false
end function

-- Check if word is a control flow keyword
function is_control_keyword(string word) returns boolean
    if word == "if" then return true end if
    if word == "else" then return true end if
    if word == "elseif" then return true end if
    if word == "while" then return true end if
    if word == "for" then return true end if
    if word == "each" then return true end if
    if word == "return" then return true end if
    if word == "exit" then return true end if
    return false
end function

-- Check if word is a boolean keyword
function is_boolean_keyword(string word) returns boolean
    if word == "true" then return true end if
    if word == "false" then return true end if
    if word == "and" then return true end if
    if word == "or" then return true end if
    if word == "not" then return true end if
    return false
end function

-- ============================================================================
-- Token Name Helper (for debugging)
-- ============================================================================

function keyword_to_string(numeric token_type) returns string
    if token_type == 1 then return "FUNCTION" end if
    if token_type == 2 then return "END" end if
    if token_type == 3 then return "IF" end if
    if token_type == 4 then return "ELSE" end if
    if token_type == 5 then return "ELSEIF" end if
    if token_type == 6 then return "WHILE" end if
    if token_type == 7 then return "FOR" end if
    if token_type == 8 then return "EACH" end if
    if token_type == 9 then return "IN" end if
    if token_type == 10 then return "TO" end if
    if token_type == 11 then return "DOWNTO" end if
    if token_type == 12 then return "EXIT" end if
    if token_type == 13 then return "RETURN" end if
    if token_type == 14 then return "IMPORT" end if
    if token_type == 20 then return "NUMERIC" end if
    if token_type == 21 then return "TEXT" end if
    if token_type == 22 then return "BOOLEAN" end if
    if token_type == 25 then return "RETURNS" end if
    if token_type == 26 then return "THEN" end if
    if token_type == 27 then return "AND" end if
    if token_type == 28 then return "OR" end if
    if token_type == 29 then return "NOT" end if
    if token_type == 32 then return "IDENTIFIER" end if
    if token_type == 33 then return "TRUE" end if
    if token_type == 34 then return "FALSE" end if
    return "UNKNOWN"
end function

-- ============================================================================
-- Test Entry Point
-- ============================================================================

function main() returns numeric
    -- Test keyword recognition
    string test1 = "function"
    numeric type1 = get_keyword_type(test1)
    -- type1 should be 1 (FUNCTION)
    
    -- Test identifier scanning
    string test2 = "myVariable + 10"
    list result2 = scan_identifier(test2, 0)
    -- result2(0) should be token with type 32 (IDENTIFIER), value "myVariable"
    -- result2(1) should be 10 (position after identifier)
    
    -- Test keyword scanning
    string test3 = "if condition then"
    list result3 = scan_identifier(test3, 0)
    -- result3(0) should be token with type 3 (IF), value "if"
    
    -- Test type keywords
    boolean is_type = is_type_keyword("numeric")
    -- is_type should be true
    
    -- Return success
    return 0
end function
