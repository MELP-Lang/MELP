-- ===
-- MELP Minimal Self-Hosting Compiler
-- ===
-- File: modules/compiler_minimal.mlp
-- Author: YZ_01
-- Date: 23 AralÄ±k 2025
-- Purpose: Minimal working compiler for self-hosting test
-- ===

-- ===
-- CHARACTER CLASSIFICATION
-- ===

function is_digit(string ch) returns boolean
    if ch == "0" then return 1 end_if
    if ch == "1" then return 1 end_if
    if ch == "2" then return 1 end_if
    if ch == "3" then return 1 end_if
    if ch == "4" then return 1 end_if
    if ch == "5" then return 1 end_if
    if ch == "6" then return 1 end_if
    if ch == "7" then return 1 end_if
    if ch == "8" then return 1 end_if
    if ch == "9" then return 1 end_if
    return 0
end_function

function is_alpha(string ch) returns boolean
    if ch == "a" then return 1 end_if
    if ch == "b" then return 1 end_if
    if ch == "c" then return 1 end_if
    if ch == "d" then return 1 end_if
    if ch == "e" then return 1 end_if
    if ch == "f" then return 1 end_if
    if ch == "g" then return 1 end_if
    if ch == "h" then return 1 end_if
    if ch == "i" then return 1 end_if
    if ch == "j" then return 1 end_if
    if ch == "k" then return 1 end_if
    if ch == "l" then return 1 end_if
    if ch == "m" then return 1 end_if
    if ch == "n" then return 1 end_if
    if ch == "o" then return 1 end_if
    if ch == "p" then return 1 end_if
    if ch == "q" then return 1 end_if
    if ch == "r" then return 1 end_if
    if ch == "s" then return 1 end_if
    if ch == "t" then return 1 end_if
    if ch == "u" then return 1 end_if
    if ch == "v" then return 1 end_if
    if ch == "w" then return 1 end_if
    if ch == "x" then return 1 end_if
    if ch == "y" then return 1 end_if
    if ch == "z" then return 1 end_if
    return 0
end_function

function is_whitespace(string ch) returns boolean
    if ch == " " then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- ===
-- SIMPLE TOKENIZER
-- ===

function tokenize_simple(string source) returns list
    list tokens = []
    numeric pos = 0
    numeric len = length(source)
    string current_token = ""
    string ch = ""
    boolean is_ws = 0
    boolean is_dig = 0
    boolean is_al = 0
    
    while pos < len
        ch = substring(source; pos; 1)
        is_ws = is_whitespace(ch)
        
        if is_ws then
            if current_token == "" then
                pos = pos + 1
            else
                tokens = tokens + [current_token]
                current_token = ""
                pos = pos + 1
            end_if
        else
            is_dig = is_digit(ch)
            is_al = is_alpha(ch)
            
            if is_dig then
                current_token = current_token + ch
                pos = pos + 1
            else
                if is_al then
                    current_token = current_token + ch
                    pos = pos + 1
                else
                    if current_token == "" then
                        numeric dummy = 0
                    else
                        tokens = tokens + [current_token]
                        current_token = ""
                    end_if
                    
                    if ch == "(" then tokens = tokens + ["("] end_if
                    if ch == ")" then tokens = tokens + [")"] end_if
                    
                    pos = pos + 1
                end_if
            end_if
        end_if
    end_while
    
    tokens = tokens + [current_token]
    
    return tokens
end_function


function parse_simple(list tokens) returns list
    numeric idx = 0
    numeric token_count = length(tokens)
    string token = ""
    string func_name = ""
    string return_value = ""
    
    while idx < token_count
        token = tokens[idx]
        if token == "function" then
            idx = idx + 1
            func_name = tokens[idx]
            exit_while
        end_if
        idx = idx + 1
    end_while
    
    idx = 0
    while idx < token_count
        token = tokens[idx]
        if token == "return" then
            idx = idx + 1
            return_value = tokens[idx]
            exit_while
        end_if
        idx = idx + 1
    end_while
    
    return [func_name; return_value]
end_function

-- ===
-- ===

function codegen_simple(list ast) returns string
    string func_name = ast[0]
    string return_value = ast[1]
    
    string ir = ""
    
    ir = ir + "; LLVM IR Generated by MELP Compiler\n"
    ir = ir + "\n"
    ir = ir + "define i64 @" + func_name + "() {\n"
    ir = ir + "entry:\n"
    ir = ir + "  ret i64 " + return_value + "\n"
    ir = ir + "}\n"
    
    return ir
end_function

-- ===
-- ===

function compile_source(string source_code) returns string
    list tokens = tokenize_simple(source_code)
    list ast = parse_simple(tokens)
    string llvm_ir = codegen_simple(ast)
    return llvm_ir
end_function

-- ===
-- ===

function read_source_file(string filename) returns string
    string content = mlp_read_file(filename)
    return content
end_function

function write_output_file(string filename; string content) returns numeric
    numeric result = mlp_write_file(filename, content)
    return result
end_function

-- ===
-- ===

function compile_file(string input_file; string output_file) returns numeric
    string source_code = read_source_file(input_file)
    
    if source_code == "" then
        return 1
    end_if
    
    string llvm_ir = compile_source(source_code)
    
    if llvm_ir == "" then
        return 1
    end_if
    
    numeric write_result = write_output_file(output_file, llvm_ir)
    
    if write_result == 0 then
        return 0
    else
        return 1
    end_if
end_function

function main() returns numeric
    string input_file = "test.mlp"
    string output_file = "test.ll"
    
    numeric result = compile_file(input_file, output_file)
    
    return result
end_function
