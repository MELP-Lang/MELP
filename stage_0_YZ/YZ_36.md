# YZ_36: Ã‡oklu else_if Chain DesteÄŸi

**Tarih:** 19 AralÄ±k 2025  
**Durum:** âœ… TAMAMLANDI  
**Dal:** `stage1_while_body_YZ_30`

---

## ğŸ¯ Hedef

PMPL sÃ¶zdiziminde sÄ±nÄ±rsÄ±z sayÄ±da `else_if` chain'i desteklemek.

```pmpl
if x == 1 then
    return 1
else_if x == 2 then
    return 2
else_if x == 3 then
    return 3
else_if x == 4 then
    return 4
else
    return 0
end_if
```

---

## ğŸ› Sorun

**Belirti:** 2+ `else_if` iÃ§eren kodda:
- Sadece ilk fonksiyon parse ediliyordu
- "Expected 'function' keyword" hatasÄ± (sonraki fonksiyonlarda)
- Ä°kinci `else_if`'ten sonra token stream bozuluyordu

**KÃ¶k Neden:**
1. TOKEN_ELSE_IF tek token olarak geliyor (lexer'dan)
2. Statement parser TOKEN_ELSE_IF'i gÃ¶rÃ¼nce synthetic TOKEN_ELSE yaratÄ±yordu
3. AMA: TOKEN_IF lexer'a geri konmuyordu!
4. SonuÃ§: Parser TOKEN_IF'i atlÄ±yor, token stream bozuluyor

---

## âœ… Ã‡Ã¶zÃ¼m

### 1. Helper Functions (Code Reuse)

**parse_statement_list()**: Statement listesi parse eder
```c
static Statement* parse_statement_list(Parser* parser) {
    Statement* head = NULL;
    Statement* tail = NULL;
    
    while (1) {
        Statement* stmt = statement_parse(parser);
        if (!stmt) break;
        
        if (!head) {
            head = stmt;
            tail = stmt;
        } else {
            tail->next = stmt;
            tail = stmt;
        }
    }
    
    return head;
}
```

**parse_else_chain()**: Recursive else/else_if chain handler
```c
static Statement* parse_else_chain(Parser* parser) {
    // Check if current_token has ELSE (set by parent)
    Token* check = parser->current_token;
    if (!check || check->type != TOKEN_ELSE) {
        return NULL;  // No else/else_if
    }
    
    // Consume ELSE token
    parser->current_token = NULL;
    token_free(check);
    
    // Peek: is it else_if?
    Token* peek = lexer_next_token(parser->lexer);
    
    if (peek && peek->type == TOKEN_IF) {
        // This is else_if! Create nested if
        IfStatement* nested_if = control_flow_parse_if(parser->lexer, peek);
        token_free(peek);
        
        if (!nested_if) {
            return NULL;
        }
        
        // Parse then body
        nested_if->then_body = parse_statement_list(parser);
        
        // RECURSIVE: Check for more else_if in the chain
        Statement* nested_else = parse_else_chain(parser);  // ğŸ”„ Recursive!
        if (nested_else) {
            nested_if->has_else = 1;
            nested_if->else_body = nested_else;
        }
        
        // Wrap nested if as statement
        Statement* stmt = statement_create(STMT_IF);
        stmt->data = nested_if;
        stmt->next = NULL;
        return stmt;
        
    } else {
        // Normal else - no if following
        if (peek) {
            lexer_unget_token(parser->lexer, peek);
        }
        
        // Parse else body
        return parse_statement_list(parser);
    }
}
```

### 2. TOKEN_ELSE_IF Handling Fix

**Ã–NCE (YANLIÅ):**
```c
if (tok->type == TOKEN_ELSE_IF) {
    token_free(tok);
    
    Token* else_tok = malloc(sizeof(Token));
    else_tok->type = TOKEN_ELSE;
    // ...
    parser->current_token = else_tok;
    
    return NULL;  // âŒ IF token lexer'da kayboldu!
}
```

**SONRA (DOÄRU):**
```c
if (tok->type == TOKEN_ELSE_IF) {
    token_free(tok);
    
    // Create synthetic IF token and push to lexer
    Token* if_tok = malloc(sizeof(Token));
    if_tok->type = TOKEN_IF;
    if_tok->value = strdup("if");
    if_tok->line = parser->lexer->line;
    if_tok->has_leading_whitespace = 0;
    lexer_unget_token(parser->lexer, if_tok);  // âœ… IF geri konuyor!
    
    // Create synthetic ELSE token for parent
    Token* else_tok = malloc(sizeof(Token));
    else_tok->type = TOKEN_ELSE;
    else_tok->value = strdup("else");
    else_tok->line = parser->lexer->line;
    else_tok->has_leading_whitespace = 0;
    parser->current_token = else_tok;
    
    return NULL;
}
```

### 3. If Statement Parsing Simplification

**Ã–NCE:** 150+ satÄ±r nested if-else logic, code duplication

**SONRA:**
```c
if (tok->type == TOKEN_IF) {
    IfStatement* if_data = control_flow_parse_if(parser->lexer, tok);
    token_free(tok);
    tok = NULL;
    
    if (if_data) {
        stmt = statement_create(STMT_IF);
        stmt->data = if_data;
        stmt->next = NULL;
        
        // Parse then body using helper
        if_data->then_body = parse_statement_list(parser);
        
        // Check for ELSE/ELSE_IF chain using recursive helper!
        Statement* else_body = parse_else_chain(parser);  // ğŸ¯ Clean!
        if (else_body) {
            if_data->has_else = 1;
            if_data->else_body = else_body;
        }
    }
    
    return stmt;  // âœ… 15 satÄ±r!
}
```

---

## ğŸ“Š Test SonuÃ§larÄ±

### Test 1: Basit else_if (x=3)
```pmpl
function main() as numeric
    numeric x = 3
    if x == 1 then
        return 10
    else_if x == 2 then
        return 20
    else_if x == 3 then
        return 30
    else
        return 99
    end_if
end_function
```
**SonuÃ§:** âœ… Return code: 30

### Test 2: 5 Seviye else_if (x=4)
```pmpl
function test4() as numeric
    numeric x = 4
    if x == 1 then
        return 1
    else_if x == 2 then
        return 2
    else_if x == 3 then
        return 3
    else_if x == 4 then
        return 4
    else_if x == 5 then
        return 5
    else
        return 0
    end_if
end_function

function main() as numeric
    return test4()
end_function
```
**SonuÃ§:** âœ… 5 functions parsed, Return code: 4

### Test Coverage

| Test Case | Durum |
|-----------|-------|
| 1 else_if + else | âœ… PASS |
| 2 else_if + else | âœ… PASS |
| 3 else_if + else | âœ… PASS |
| 5 else_if + else | âœ… PASS |
| else_if without final else | âœ… PASS |
| Nested if iÃ§inde else_if | âœ… PASS (zaten destekliyordu) |
| Multiple functions with else_if | âœ… PASS |

---

## ğŸ† BaÅŸarÄ±lar

1. **SÄ±nÄ±rsÄ±z else_if:** Recursive design sayesinde else_if sayÄ±sÄ± sÄ±nÄ±rsÄ±z
2. **Clean Code:** 150+ satÄ±r â†’ 15 satÄ±r (helper functions)
3. **No Duplication:** parse_statement_list() tÃ¼m body parsing'de kullanÄ±lÄ±yor
4. **Modular:** Merkezi dosya yok, her modÃ¼l kendi iÅŸini yapÄ±yor
5. **PMPL Uyumlu:** Tek `end_if` (tÃ¼m chain iÃ§in)

---

## ğŸ“ DeÄŸiÅŸen Dosyalar

**compiler/stage0/modules/statement/statement_parser.c**
- Helper functions: parse_statement_list(), parse_else_chain()
- TOKEN_ELSE_IF handling dÃ¼zeltildi
- If statement parsing basitleÅŸtirildi

---

## ğŸ” Teknik Detaylar

### AST YapÄ±sÄ±

Her `else_if` â†’ nested if statement olarak temsil edilir:

```
IfStatement (x == 1)
â”œâ”€ then_body: [return 10]
â””â”€ else_body:
   â””â”€ IfStatement (x == 2)  â† nested if (else_if olarak)
      â”œâ”€ then_body: [return 20]
      â””â”€ else_body:
         â””â”€ IfStatement (x == 3)  â† nested if (else_if olarak)
            â”œâ”€ then_body: [return 30]
            â””â”€ else_body: [return 99]  â† final else
```

### Token Flow

```
Input:  if x==1 then R1 else_if x==2 then R2 else_if x==3 then R3 else R0 end_if

Lexer:  IF x==1 THEN R1 ELSE_IF x==2 THEN R2 ELSE_IF x==3 THEN R3 ELSE R0 END_IF

Parser: 
1. Parse IF x==1
2. Parse then body â†’ R1
3. See ELSE_IF â†’ Split to ELSE + IF
4. Parse nested IF x==2
5. Parse then body â†’ R2
6. See ELSE_IF â†’ Split to ELSE + IF (recursive!)
7. Parse nested IF x==3
8. Parse then body â†’ R3
9. See ELSE â†’ Parse else body â†’ R0
10. See END_IF â†’ End all nested ifs (shared terminator)
```

---

## ğŸ“ Ã–ÄŸrendiklerimiz

1. **Recursive Parsing:** KarmaÅŸÄ±k syntax'lar iÃ§in recursive helper functions gÃ¼Ã§lÃ¼
2. **Token Splitting:** Tek token (ELSE_IF) â†’ multiple tokens (ELSE + IF) split edilebilir
3. **lexer_unget_token:** Token stream'e geri token koyma kritik
4. **Helper Functions:** Code reuse â†’ maintainability
5. **PMPL Syntax:** Tek `end_if` tÃ¼m chain iÃ§in (Python-style deÄŸil, MELP-style)

---

## ğŸš€ Sonraki AdÄ±mlar

YZ_36 tamamlandÄ±! Sonraki:

**YZ_37:** Function Call Argument Parsing Bug
- Sorun: `classify(3)` Ã§aÄŸrÄ±sÄ±nda argument push edilmiyor
- Dosya: `arithmetic_parser.c`, `functions_codegen.c`
- Ã–ncelik: YÃœKSEK (temel iÅŸlevsellik)

---

*YZ_36 - 19 AralÄ±k 2025*
