# YZ_41 - Negative Numbers Support + Critical Bug Fixes

**Tarih:** 11 AralÄ±k 2025  
**SÃ¼re:** ~45 dakika  
**Durum:** âœ… TamamlandÄ±  
**Dal:** `bug_fix_function_calls_YZ_40`

## ğŸ¯ Hedef

HIGH PRIORITY gÃ¶rev: Negatif sayÄ± desteÄŸini eklemek
- Problem: `numeric x = -15` parse error veriyordu
- Ã‡Ã¶zÃ¼m: Unary minus operator implementasyonu

## âœ… Tamamlanan Ä°ÅŸler

### 1. Unary Minus Operator (45 dakika)

**Problem Analizi:**
- `numeric x = -15` â†’ Parse error
- `-` token'Ä± operatÃ¶r olarak gÃ¶rÃ¼lÃ¼yordu ama unary minus olarak deÄŸil
- Expression baÅŸÄ±nda `-` gelebilmesi gerekiyordu

**DeÄŸiÅŸiklikler:**

1. **arithmetic_parser.c** - Primary Expression Parsing
   ```c
   // TOKEN_MINUS iÃ§in unary minus desteÄŸi eklendi
   } else if (current->type == TOKEN_MINUS) {
       token_free(current);
       Token* operand_tok = lexer_next_token(lexer);
       ArithmeticExpr* operand = parse_primary_stateless(lexer, operand_tok);
       if (!operand) {
           token_free(operand_tok);
           return NULL;
       }
       token_free(operand_tok);
       
       // Wrap in unary minus (0 - operand)
       expr = arithmetic_create_expr(OP_SUBTRACT);
       expr->left = arithmetic_create_literal("0");
       expr->right = operand;
   }
   ```

2. **variable_parser.c** - Variable Assignment
   ```c
   // Expression start token'larÄ±na TOKEN_MINUS eklendi
   if (tok->type == TOKEN_IDENTIFIER ||
       tok->type == TOKEN_NUMBER ||
       tok->type == TOKEN_STRING ||
       tok->type == TOKEN_LPAREN ||
       tok->type == TOKEN_LANGLE ||
       tok->type == TOKEN_NOT ||
       tok->type == TOKEN_MINUS) {  // YZ_41: Negative numbers
   ```

3. **comparison_parser.c** - Comparison Operands
   - Sol operand iÃ§in TOKEN_MINUS desteÄŸi
   - SaÄŸ operand iÃ§in TOKEN_MINUS desteÄŸi
   ```c
   } else if (first_token->type == TOKEN_MINUS) {
       // Negative number
       Token* num_tok = lexer_next_token(lexer);
       if (!num_tok || num_tok->type != TOKEN_NUMBER) {
           token_free(num_tok);
           free(expr);
           return NULL;
       }
       char negative_buf[256];
       snprintf(negative_buf, sizeof(negative_buf), "-%s", num_tok->value);
       expr->left_value = strdup(negative_buf);
       expr->left_is_literal = 1;
       token_free(num_tok);
   }
   ```

### 2. Lexer Bug Fix - Infinite Loop (10 dakika)

**Problem:**
- Comment iÃ§inde `#` karakteri varsa sonsuz dÃ¶ngÃ¼
- Lexer unknown character gÃ¶rdÃ¼ÄŸÃ¼nde pos ilerletmiyordu
- `TOKEN_ERROR` dÃ¶ndÃ¼rÃ¼lÃ¼yordu ama aynÄ± karakteri tekrar okuyordu

**Ã‡Ã¶zÃ¼m:**
```c
// YZ_41: Unknown character - advance position to avoid infinite loop
lexer->pos++;
char error_msg[100];
snprintf(error_msg, sizeof(error_msg), "Unexpected character '%c' (0x%02X) at line %d", 
         c, (unsigned char)c, lexer->line);
return make_token_ws(TOKEN_ERROR, error_msg, lexer->line, had_whitespace);
```

### 3. Return Statement Bug Fix - Critical (5 dakika)

**Problem:**
- Return statement function'dan Ã§Ä±kmÄ±yordu
- Return value set edildikten sonra execution devam ediyordu
- Ä°f iÃ§indeki return'den sonra bile kod Ã§alÄ±ÅŸÄ±yordu

**Ã–rnek Sorun:**
```mlp
if a == -10 then
    return 100  -- Return value set ediliyordu
end if
return 0  -- Ama burasÄ± da Ã§alÄ±ÅŸÄ±yordu! Return deÄŸeri 0 oluyordu!
```

**Ã‡Ã¶zÃ¼m:**
```c
// YZ_41: Jump to function epilogue
fprintf(output, "    jmp .L%s_return\n", func->name);
```

## ğŸ§ª Test SonuÃ§larÄ±

### Test 1: Basic Negative Assignment
```mlp
numeric x = -10
return x  -- Exit code: 246 (256-10=246) âœ…
```

### Test 2: Arithmetic Operations
```mlp
numeric a = -10
numeric b = 5
numeric sum = a + b      -- -5 âœ…
numeric diff = a - b     -- -15 âœ…
numeric prod = a * b     -- -50 âœ…
```

### Test 3: Comparison with Negatives
```mlp
if a == -10 then         -- TRUE âœ…
    if sum == -5 then    -- TRUE âœ…
        if diff == -15 then  -- TRUE âœ…
            if prod == -50 then  -- TRUE âœ…
                return 1
            end if
        end if
    end if
end if
return 0
-- Exit code: 1 (All tests passed!) âœ…
```

### Test 4: Return Statement Fix
```mlp
if a == -10 then
    return 100
end if
return 0
-- Exit code: 100 (Return Ã§alÄ±ÅŸÄ±yor!) âœ…
```

## ğŸ“Š DeÄŸiÅŸiklik Ä°statistikleri

```
5 files changed, 96 insertions(+), 3 deletions(-)

DeÄŸiÅŸtirilen Dosyalar:
- compiler/stage0/modules/arithmetic/arithmetic_parser.c
- compiler/stage0/modules/comparison/comparison_parser.c
- compiler/stage0/modules/variable/variable_parser.c
- compiler/stage0/modules/lexer/lexer.c
- compiler/stage0/modules/statement/statement_codegen.c
```

## ğŸ› Tespit Edilen Buglar ve Ã‡Ã¶zÃ¼mleri

### Bug #1: Lexer Infinite Loop
- **Severity:** Critical
- **Impact:** Unknown character (Ã¶rn. `#`) sonsuz dÃ¶ngÃ¼ye sokuyor
- **Root Cause:** `lexer->pos` ilerletilmiyordu
- **Fix:** Unknown character'da pos++ eklendi

### Bug #2: Return Statement Doesn't Exit
- **Severity:** Critical
- **Impact:** Return statement iÅŸe yaramÄ±yordu
- **Root Cause:** Function epilogue'a jump eksikti
- **Fix:** `jmp .Lfunc_return` eklendi

### Bug #3: Negative Numbers Not Supported
- **Severity:** High Priority
- **Impact:** Negatif literal sayÄ±lar kullanÄ±lamÄ±yordu
- **Root Cause:** Unary minus operator implementasyonu yoktu
- **Fix:** 3 modÃ¼lde TOKEN_MINUS desteÄŸi eklendi

## ğŸ“ Notlar

1. **Comment Syntax HatasÄ±:**
   - Test sÄ±rasÄ±nda `#` ile comment yazmaya Ã§alÄ±ÅŸtÄ±k
   - MLP'de comment `--` ile baÅŸlar, `#` deÄŸil!
   - Bu lexer bug'Ä±nÄ± ortaya Ã§Ä±kardÄ± (silver lining)

2. **Return Bug'Ä±:**
   - Bu bug YZ_40'ta da vardÄ± ama fark edilmemiÅŸti
   - Ã‡Ã¼nkÃ¼ test programlarÄ± tek bir return kullanÄ±yordu
   - If iÃ§inde return ile ortaya Ã§Ä±ktÄ±

3. **Assembly DoÄŸruluÄŸu:**
   - Negatif sayÄ±lar two's complement olarak doÄŸru kodlanÄ±yor
   - `movq $-10, %r8` â†’ 0xFFFFFFFFFFFFFFF6
   - Comparison'lar signed olarak Ã§alÄ±ÅŸÄ±yor

## ğŸ“ Ã–ÄŸrenilen Dersler

1. **Test-Driven Development:**
   - Ã–nce test yaz, sonra kodu dÃ¼zelt
   - Her test bir bug daha buldu

2. **Edge Case Testing:**
   - Unknown character handling test edilmeliydi
   - Return statement multiple return ile test edilmeliydi

3. **Incremental Testing:**
   - If olmadan test â†’ Ã‡alÄ±ÅŸtÄ± âœ…
   - If ile test â†’ Sonsuz dÃ¶ngÃ¼ âŒ
   - Comment bug'Ä±nÄ± buldu

## ğŸ”„ Sonraki AdÄ±mlar

1. **Module Caching - Part 3** (TODO.md'de)
   - Module dependency tracking
   - Timestamp-based caching
   - Cache invalidation

2. **Test Coverage:**
   - Negative numbers iÃ§in unit test ekle
   - Return statement iÃ§in regression test

3. **Code Review:**
   - BaÅŸka kritik bug'lar var mÄ±?
   - Edge case'ler test edilmiÅŸ mi?

## ğŸ“¦ Commit Bilgisi

```
Commit: 26d4a79
Branch: bug_fix_function_calls_YZ_40
Message: YZ_41: Add negative numbers support + critical bug fixes
```

---

**Toplam SÃ¼re:** 45 dakika  
**KarmaÅŸÄ±klÄ±k:** Orta (3 modÃ¼l + 2 critical bug fix)  
**BaÅŸarÄ± OranÄ±:** %100 - TÃ¼m testler PASSED! ğŸ‰
