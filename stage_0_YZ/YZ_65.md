# YZ_65: Phase 17 - String Variable Arguments

**Tarih:** 13 AralÄ±k 2025  
**Durum:** âœ… TAMAMLANDI  
**SÃ¼re:** ~2 saat  
**Branch:** `phase17-string-support_YZ_61`  
**Commit:** `52ce79b`

---

## ğŸ“‹ Ã–zet

YZ_64'te string **literal** argÃ¼manlar Ã§alÄ±ÅŸÄ±r hale gelmiÅŸti. YZ_65'te string **deÄŸiÅŸken** argÃ¼manlarÄ±nÄ± da Ã§alÄ±ÅŸtÄ±rdÄ±k. ArtÄ±k hem `greet("Hello")` hem de `greet(message)` syntax'larÄ± Ã§alÄ±ÅŸÄ±yor!

---

## ğŸ¯ Hedef

**Problem:** String deÄŸiÅŸken argÃ¼manlarÄ± function call'larda Ã§alÄ±ÅŸmÄ±yordu.

```mlp
function greet(string msg) returns numeric
    print(msg)
    return 0
end

function main() returns numeric
    string message = "MELP string variable"
    greet(message)  # âŒ Bu Ã§alÄ±ÅŸmÄ±yordu!
    return 0
end
```

**Hatalar:**
1. Parser function call'Ä± statement olarak tanÄ±mÄ±yordu
2. LLVM backend'de LocalVariable registry populate edilmiyordu
3. Variable type lookup eksikti

---

## ğŸ”§ Uygulanan Ã‡Ã¶zÃ¼mler

### 1. Statement Parser - Function Call Support

**Dosya:** `compiler/stage0/modules/statement/statement_parser.c`

**Sorun:** Statement parser `TOKEN_IDENTIFIER` gÃ¶rÃ¼nce sadece assignment (`=`) veya array indexing (`[`) kontrol ediyordu. Function call iÃ§in `(` kontrolÃ¼ yoktu.

**Ã‡Ã¶zÃ¼m:**

```c
// YZ_65: Check for function call: func(args)
if (next_tok && next_tok->type == TOKEN_LPAREN) {
    // Function call as statement (return value ignored)
    // Put the '(' back, arithmetic parser will consume it
    lexer_unget_token(parser->lexer, next_tok);
    
    // Parse function call using arithmetic parser
    ArithmeticExpr* call_expr = arithmetic_parse_expression_stateless(parser->lexer, tok);
    
    if (!call_expr) {
        token_free(tok);
        error_parser(0, "Failed to parse function call");
        return NULL;
    }
    
    // tok is now owned by call_expr, don't free it
    
    // Create expression statement
    stmt = statement_create(STMT_EXPRESSION);
    stmt->data = call_expr;
    stmt->next = NULL;
    return stmt;
}
```

**SonuÃ§:** Function call'lar artÄ±k statement olarak parse ediliyor ve arithmetic parser'a delegate ediliyor.

---

### 2. LLVM Backend - LocalVariable Registry Population

**Dosya:** `compiler/stage0/modules/functions/functions_codegen_llvm.c`

**Sorun:** LLVM backend'de `LocalVariable` registry hiÃ§ populate edilmiyordu. X86_64 backend'de `scan_statement_for_variables()` vardÄ± ama LLVM'de yoktu.

**Ã‡Ã¶zÃ¼m:**

```c
// YZ_65: Scan statements to populate local_vars registry
static void scan_statement_for_variables(FunctionDeclaration* func, Statement* stmt) {
    if (!stmt) return;
    
    // Register variable declaration
    if (stmt->type == STMT_VARIABLE_DECL) {
        VariableDeclaration* decl = (VariableDeclaration*)stmt->data;
        if (decl && decl->name) {
            // Register with type flag (1=numeric, 0=string)
            int is_numeric = (decl->type != VAR_STRING) ? 1 : 0;
            function_register_local_var_with_type(func, decl->name, is_numeric);
        }
    }
    
    // Recursively scan nested blocks (if/while)
    if (stmt->type == STMT_IF) {
        IfStatement* if_stmt = (IfStatement*)stmt->data;
        if (if_stmt) {
            Statement* nested = if_stmt->then_body;
            while (nested) {
                scan_statement_for_variables(func, nested);
                nested = nested->next;
            }
            if (if_stmt->has_else) {
                nested = if_stmt->else_body;
                while (nested) {
                    scan_statement_for_variables(func, nested);
                    nested = nested->next;
                }
            }
        }
    }
    
    if (stmt->type == STMT_WHILE) {
        WhileStatement* while_stmt = (WhileStatement*)stmt->data;
        if (while_stmt) {
            Statement* nested = while_stmt->body;
            while (nested) {
                scan_statement_for_variables(func, nested);
                nested = nested->next;
            }
        }
    }
    
    // Scan next statement
    if (stmt->next) {
        scan_statement_for_variables(func, stmt->next);
    }
}
```

**Function codegen'de kullanÄ±m:**

```c
void function_generate_declaration_llvm(FunctionLLVMContext* ctx, FunctionDeclaration* func) {
    if (!func) return;
    
    ctx->current_func = func;
    
    // YZ_65: First pass - scan for local variables to populate registry
    Statement* scan_stmt = func->body;
    while (scan_stmt) {
        scan_statement_for_variables(func, scan_stmt);
        scan_stmt = scan_stmt->next;
    }
    
    // ... rest of codegen
}
```

**SonuÃ§:** Registry artÄ±k codegen'den Ã¶nce populate ediliyor. Variable declarations tÃ¼m nested block'larda da bulunuyor.

---

### 3. Variable Type Tracking

**Dosya:** `compiler/stage0/modules/functions/functions_codegen_llvm.c`

**Mevcut kod zaten vardÄ± (YZ_64)**, ama registry boÅŸ olduÄŸu iÃ§in Ã§alÄ±ÅŸmÄ±yordu:

```c
// YZ_65: Local variable - check if string or numeric
// Look up variable type from local_vars registry
int is_string_var = 0;
LocalVariable* local = ctx->current_func->local_vars;

while (local) {
    if (strcmp(local->name, arith->value) == 0) {
        is_string_var = !local->is_numeric;  // is_numeric=0 means string
        break;
    }
    local = local->next;
}

if (is_string_var || arith->is_string) {
    // String variable: load i8* from i8**
    LLVMValue* loaded = malloc(sizeof(LLVMValue));
    loaded->name = llvm_new_temp(ctx->llvm_ctx);
    loaded->is_constant = 0;
    loaded->type = LLVM_TYPE_I8_PTR;
    
    fprintf(ctx->llvm_ctx->output, "    %s = load i8*, i8** %%%s_ptr, align 8\n",
            loaded->name, arith->value);
    
    return loaded;
}
```

**SonuÃ§:** Registry populate edildikten sonra bu kod Ã§alÄ±ÅŸmaya baÅŸladÄ± ve doÄŸru tip bilgisini buldu.

---

## ğŸ“Š Test SonuÃ§larÄ±

### Test 1: String Variable Argument

**Dosya:** `test_string_param_var.mlp`

```mlp
function greet(string msg) returns numeric
    print(msg)
    return 0
end

function main() returns numeric
    string message = "MELP string variable"
    greet(message)
    return 0
end
```

**LLVM IR:**

```llvm
define i64 @main() {
entry:
  %message_ptr = alloca i8*, align 8
  %tmp1 = getelementptr inbounds [21 x i8], [21 x i8]* @.str.1, i64 0, i64 0
  store i8* %tmp1, i8** %message_ptr, align 8
  %tmp2 = load i8*, i8** %message_ptr, align 8  # âœ… Correct i8* load
  %tmp3 = call i64 @greet(i8* %tmp2)            # âœ… Correct i8* argument
  ret i64 0
}
```

**Ã‡Ä±ktÄ±:**

```bash
MELP string variable
```

âœ… **BAÅARILI!**

---

### Test 2: Multiple String Arguments

**Dosya:** `test_string_param_multiple.mlp`

```mlp
function show(string msg1, string msg2) returns numeric
    print(msg1)
    print(msg2)
    return 0
end

function main() returns numeric
    string first = "First message"
    string second = "Second message"
    
    show("Test 1:", "Literal params")
    show(first, second)
    show("Mixed:", first)
    
    return 0
end
```

**Ã‡Ä±ktÄ±:**

```bash
Test 1:
Literal params
First message
Second message
Mixed:
First message
```

âœ… **BAÅARILI!** TÃ¼m senaryolar Ã§alÄ±ÅŸÄ±yor:
- Pure literal arguments âœ…
- Pure variable arguments âœ…
- Mixed literal + variable âœ…

---

### Test 3: Regression Test

**Dosya:** `test_string_param_literal.mlp`

```mlp
function greet(string msg) returns numeric
    print(msg)
    return 0
end

function main() returns numeric
    numeric result = greet("Hello from string parameter!")
    return result
end
```

**Ã‡Ä±ktÄ±:**

```bash
Hello from string parameter!
```

âœ… **BAÅARILI!** YZ_64'teki literal arguments hala Ã§alÄ±ÅŸÄ±yor.

---

## ğŸ” Teknik Detaylar

### LocalVariable Registry YapÄ±sÄ±

```c
typedef struct LocalVariable {
    char* name;
    int is_numeric;      // 1 = numeric/boolean, 0 = string
    int is_array;
    int array_length;
    int is_tuple;
    int tuple_length;
    int is_list;
    int list_length;
    int stack_offset;
    struct LocalVariable* next;
} LocalVariable;
```

**Tip mapping:**
- `VAR_STRING` â†’ `is_numeric = 0`
- `VAR_NUMERIC` â†’ `is_numeric = 1`
- `VAR_BOOLEAN` â†’ `is_numeric = 1`

### LLVM IR Pattern - String Variable

**Declaration:**
```llvm
%varname_ptr = alloca i8*, align 8
%tmp1 = getelementptr inbounds [N x i8], [N x i8]* @.str.X, i64 0, i64 0
store i8* %tmp1, i8** %varname_ptr, align 8
```

**Usage (as argument):**
```llvm
%tmp2 = load i8*, i8** %varname_ptr, align 8
%tmp3 = call i64 @func(i8* %tmp2)
```

### Statement Parser Flow

```
TOKEN_IDENTIFIER
    â†“
Look ahead: TOKEN_LPAREN?
    â†“ YES
Put '(' back
    â†“
Call arithmetic_parse_expression_stateless()
    â†“
Parse function call with arguments
    â†“
Create STMT_EXPRESSION
```

---

## ğŸ› KarÅŸÄ±laÅŸÄ±lan Sorunlar ve Ã‡Ã¶zÃ¼mler

### Problem 1: Parser function call'Ä± gÃ¶rmÃ¼yor

**Hata:**
```
test_string_param_var.mlp:8: error [Parser]: Expected 'function' keyword
    8 |     greet(message)
```

**Ã‡Ã¶zÃ¼m:** Statement parser'a `TOKEN_LPAREN` kontrolÃ¼ eklendi.

---

### Problem 2: LocalVariable registry boÅŸ

**Debug output:**
```
[DEBUG] Looking up variable 'message' in registry:
[DEBUG]   (empty)
```

**Ã‡Ã¶zÃ¼m:** `scan_statement_for_variables()` fonksiyonu eklendi ve function codegen'den Ã¶nce Ã§aÄŸrÄ±ldÄ±.

---

### Problem 3: Token ownership

**Ä°lk deneme:** Token'Ä± manuel oluÅŸturup free etmeye Ã§alÄ±ÅŸtÄ±k, ama Token struct'Ä±nda `next` field'Ä± yoktu.

**Ã‡Ã¶zÃ¼m:** `lexer_unget_token()` kullanÄ±p arithmetic parser'a token'Ä± geÃ§tik. Parser token ownership'ini aldÄ±.

---

## ğŸ“ˆ Ä°lerleme Ã–zeti

### YZ_64 â†’ YZ_65

| Ã–zellik | YZ_64 | YZ_65 |
|---------|-------|-------|
| String literal arguments | âœ… | âœ… |
| String variable arguments | âŒ | âœ… |
| Multiple arguments | Partial | âœ… |
| Mixed literal+variable | âŒ | âœ… |
| Function calls as statements | âŒ | âœ… |
| LocalVariable registry (LLVM) | âŒ | âœ… |

### Phase 17 Progress

- **Ã–nce:** 75% (YZ_64)
- **Åimdi:** 85% (YZ_65)
- **Kalan:** String concatenation, comparison, methods

---

## ğŸ¯ Sonraki AdÄ±mlar

### YakÄ±n Gelecek (Phase 17)

1. **String concatenation** - `x + " world"`
2. **String comparison** - `x == "test"`
3. **String methods** - `length(x)`, `substring(x, 0, 5)`

### Uzun Vadeli

- Memory management (heap allocation)
- STO string type integration
- String escape sequences (geniÅŸletilmiÅŸ)
- Unicode support (geniÅŸletilmiÅŸ)

---

## ğŸ“ Notlar

### Neden Parser DeÄŸil de Codegen?

Ä°ki yaklaÅŸÄ±m vardÄ±:
- **Option A:** Parser'da variable type lookup (NEXT_AI Ã¶nerisi)
- **Option B:** Codegen'de registry population (TODO.md Ã¶nerisi)

**SeÃ§im:** Ä°kisinin hibridini kullandÄ±k:
1. Statement parser'a function call support eklendi (parser)
2. Registry population codegen'de yapÄ±ldÄ± (codegen)

**Neden bu daha iyi:**
- Parser stateless kalÄ±yor (no context gerekmiyor)
- Codegen zaten FunctionDeclaration context'ine sahip
- Registry management tek yerde toplanmÄ±ÅŸ (functions.c)
- X86_64 backend ile tutarlÄ±lÄ±k

### Debug Technique

Registry iÃ§eriÄŸini gÃ¶rmek iÃ§in geÃ§ici debug print'ler kullandÄ±k:

```c
fprintf(stderr, "[DEBUG] Looking up variable '%s' in registry:\n", arith->value);
LocalVariable* debug_local = ctx->current_func->local_vars;
while (debug_local) {
    fprintf(stderr, "[DEBUG]   - %s: is_numeric=%d\n", 
            debug_local->name, debug_local->is_numeric);
    debug_local = debug_local->next;
}
```

Bu, registry'nin boÅŸ olduÄŸunu hemen gÃ¶sterdi ve `scan_statement_for_variables()` eklemek gerektiÄŸini kanÄ±tladÄ±.

---

## âœ… Checklist

- [x] Statement parser'a function call support eklendi
- [x] LLVM backend iÃ§in scan_statement_for_variables() implementasyonu
- [x] Registry population before codegen
- [x] Variable type lookup Ã§alÄ±ÅŸÄ±yor
- [x] test_string_param_var.mlp âœ… PASSING
- [x] test_string_param_multiple.mlp âœ… PASSING
- [x] test_string_param_literal.mlp âœ… PASSING (regression)
- [x] TODO.md gÃ¼ncellendi (85%)
- [x] Commit ve push yapÄ±ldÄ±
- [x] YZ_65.md dÃ¶kÃ¼mantasyonu tamamlandÄ±

---

**YZ_65 BaÅŸarÄ±yla TamamlandÄ±! ğŸ‰**

**Toplam SÃ¼re:** ~2 saat (tahmin: 2.5-3 saat)  
**Kod Kalitesi:** âœ… Temiz, iyi dÃ¶kÃ¼mante edilmiÅŸ  
**Test Coverage:** âœ… Comprehensive (3 test dosyasÄ±)  
**Git:** âœ… Committed & Pushed
