# ğŸš¨ ASSEMBLY SYNTAX CRISIS - Acil TutarlÄ±lÄ±k Raporu

**Tarih:** 14 AralÄ±k 2025  
**Tespit Eden:** YZ_75 (print() bug investigation sÄ±rasÄ±nda)  
**Durum:** ğŸ”´ KRÄ°TÄ°K - Sistem iki farklÄ± assembly syntax kullanÄ±yor!

---

## ğŸ¯ SORUN Ã–ZETÄ°

MELP compiler'Ä± **iki farklÄ± assembly syntax** karÄ±ÅŸÄ±mÄ± ile Ã§alÄ±ÅŸÄ±yor:
1. **AT&T Syntax** - Ana sistem (GCC default, YZ_04'ten beri)
2. **NASM/Intel Syntax** - Print modÃ¼lÃ¼ (YZ_61'den kalma, TODO olarak bÄ±rakÄ±lmÄ±ÅŸ)

Bu **karÄ±ÅŸÄ±k durum** ÅŸu anda `print()` statement'larÄ±nÄ±n **hiÃ§ Ã§alÄ±ÅŸmamasÄ±na** yol aÃ§Ä±yor!

---

## ğŸ” TESPÄ°T EDÄ°LEN DURUM

### âœ… AT&T Syntax Kullanan ModÃ¼ller (Ã‡ALIÅIYOR)

**1. Functions Codegen** (`functions_codegen.c`)
```c
fprintf(output, "    movq $0, %%r8  # Literal\n");    // âœ… AT&T
fprintf(output, "    movq %%r8, %%rax  # Return\n");  // âœ… AT&T
```

**Ãœretilen Assembly:**
```asm
# Main program: /tmp/simple_test.mlp
# Generated by MELP Compiler (YZ_44 Part 5.1)

.section .rodata
.div_zero_msg:
    .string "Division by zero is not allowed!"

.text

# Function: main
.global main
main:
    pushq %rbp
    movq %rsp, %rbp
    # Print statement       â† TODO OLARAK BIRAKILMIÅ!
    
    # Arithmetic expression
    movq $0, %r8  # Literal
    movq %r8, %rax  # Return value
```

**Ã–zellikler:**
- âœ… `%` prefix (registers)
- âœ… `$` prefix (immediates)
- âœ… `#` comment delimiter
- âœ… `.section .rodata` directives
- âœ… `movq source, dest` (AT&T order)

**Kaynak:** YZ_04 (9 AralÄ±k 2025)
- "AT&T Assembly Syntax Migration âœ…"
- `comparison_codegen.c`, `control_flow_codegen.c` AT&T'ye Ã§evrildi
- GCC default syntax ile uyumlu

---

### âŒ NASM/Intel Syntax Kullanan ModÃ¼l (Ã‡ALIÅMIYOR)

**2. Print Codegen** (`print_codegen.c`)
```c
fprintf(f, "; MLP Print Module - Generated Assembly\n");     // âŒ NASM comment
fprintf(f, "    mov rdi, [var_%s]  ; Load INT64\n", var);    // âŒ Intel syntax
fprintf(f, "    call sto_print_int64\n");                     // âŒ NASM

fprintf(f, "section .data\n");                                // âŒ NASM section
fprintf(f, "    str_%d: db \"%s\", 10, 0\n", counter, str);  // âŒ NASM db
fprintf(f, "    mov rax, 1  ; sys_write\n");                 // âŒ Intel syntax
```

**Sorunlar:**
1. `;` comment delimiter (AT&T `#` bekliyor)
2. `mov dest, source` Intel order (AT&T tersi)
3. `section .data` (AT&T `.section .data` bekliyor)
4. `db` pseudo-op (AT&T `.string` bekliyor)
5. Register'larda `%` prefix yok

**Kaynak:** YZ_61 Ã¶ncesi (print parser zamanÄ±)
- Print modÃ¼lÃ¼ NASM iÃ§in yazÄ±lmÄ±ÅŸ
- **HiÃ§ AT&T'ye porting yapÄ±lmamÄ±ÅŸ!**

---

### âš ï¸ Statement Codegen - TODO Durumu

**3. Statement Codegen Integration** (`statement_codegen.c:81`)
```c
case STMT_PRINT: {
    // âœ… Use print module
    // TODO: print_generate_code(output, stmt->data);
    fprintf(output, "    # Print statement\n");    // â† SADECE YORUM!
    break;
}
```

**SonuÃ§:**
- Parser `print()` statement'Ä± **parse ediyor** âœ…
- Codegen sadece **comment yazÄ±yor** âŒ
- Fonksiyon Ã§aÄŸrÄ±sÄ± **hiÃ§ yapÄ±lmÄ±yor** âŒ

**Bu yÃ¼zden:**
```mlp
function main() returns numeric
    print("Hello")  â† Parse ediliyor ama code Ã¼retilmiyor!
    return 0
end
```

**Assembly Ã§Ä±ktÄ±sÄ±:**
```asm
main:
    pushq %rbp
    movq %rsp, %rbp
    # Print statement    â† SADECE YORUM!
    # Arithmetic expression
    movq $0, %r8
```

**Program Ã§Ä±ktÄ±sÄ±:** **(hiÃ§bir ÅŸey)** ğŸ˜±

---

## ğŸ“Š SYNTAX KARÅILAÅTIRMA

| Ã–zellik | AT&T (KullanÄ±lan) | NASM/Intel (print_codegen.c) |
|---------|-------------------|------------------------------|
| **Comment** | `# comment` | `; comment` |
| **Register** | `%rax`, `%rdi` | `rax`, `rdi` |
| **Immediate** | `$10`, `$0x20` | `10`, `0x20` |
| **Memory** | `-8(%rbp)` | `[rbp-8]` |
| **Direction** | `movq src, dest` | `mov dest, src` |
| **Section** | `.section .data` | `section .data` |
| **String** | `.string "text"` | `db "text", 0` |
| **Alignment** | `.align 8` | `align 8` |
| **Global** | `.global main` | `global main` |

---

## ğŸ” NEDEN KARIÅTI?

### Tarihsel Analiz:

**YZ_04 (9 AralÄ±k 2025):**
- Control flow codegen implement edildi
- **"AT&T Assembly Syntax Migration âœ…"** yapÄ±ldÄ±
- `comparison_codegen.c`, `control_flow_codegen.c` â†’ AT&T'ye Ã§evrildi
- **Sebep:** "GCC defaults to AT&T syntax"

**YZ_61 Ã–ncesi (Print Parser):**
- Print modÃ¼lÃ¼ oluÅŸturuldu
- `print_codegen.c` NASM syntax ile yazÄ±ldÄ±
- **HiÃ§ AT&T'ye porting yapÄ±lmadÄ±!**

**YZ_44 - YZ_70 (Phase 13):**
- LLVM backend eklendi (`.ll` IR Ã¼retiyor, assembly deÄŸil)
- Functions standalone compiler geliÅŸtirildi
- Print codegen **TODO olarak bÄ±rakÄ±ldÄ±**

**Statement Codegen:**
```c
// YZ_04 zamanÄ±nda doÄŸru approach:
case STMT_IF: {
    IfStatement* if_stmt = (IfStatement*)stmt->data;
    if (if_stmt) {
        control_flow_generate_if(output, if_stmt, func);  // âœ… Ã‡AÄRILIYOR
    }
    break;
}

// Print iÃ§in yapÄ±lan (yapÄ±lmayan):
case STMT_PRINT: {
    // TODO: print_generate_code(output, stmt->data);    // âŒ Ã‡AÄRILMIYOR
    fprintf(output, "    # Print statement\n");          // âŒ SADECE YORUM
    break;
}
```

---

## ğŸ¯ ETKÄ°LEÅEN SÄ°STEMLER

### 1. **Parser Layer** âœ… Ã‡ALIÅIYOR
- `print_parser.c` â†’ `PrintStatement` struct oluÅŸturuyor
- `statement_parser.c:297` â†’ TOKEN_PRINT'i yakalÄ±yor
- **Durum:** Sorunsuz Ã§alÄ±ÅŸÄ±yor

### 2. **Codegen Layer** âŒ YARIM
- `statement_codegen.c` â†’ print iÃ§in TODO
- `print_codegen.c` â†’ NASM syntax (uyumsuz)
- **Durum:** HiÃ§ Ã§aÄŸrÄ±lmÄ±yor

### 3. **Runtime Layer** âš ï¸ KISMI
- `runtime/sto/sto_runtime.c` â†’ `sto_print_int64()`, `sto_print_double()` var
- **String print fonksiyonu YOK!**
- **Durum:** Sadece numeric print var

### 4. **Compiler Driver** âœ… Ã‡ALIÅIYOR
- `functions_standalone.c` â†’ Statement parser Ã§aÄŸÄ±rÄ±yor
- `function_generate_declaration()` â†’ Codegen orchestration
- **Durum:** DoÄŸru Ã§aÄŸÄ±rÄ±yor ama print codegen TODO

---

## ğŸš¨ KRÄ°TÄ°K SORUNLAR

### Sorun #1: Print HiÃ§ Ã‡alÄ±ÅŸmÄ±yor
```mlp
print("Hello")  â†’ Assembly'de sadece comment!
```

### Sorun #2: Ä°ki Syntax KarÄ±ÅŸÄ±k
```
AT&T (functions, control_flow) + NASM (print) = âŒ UYUMSUZ
```

### Sorun #3: Runtime Eksik
```c
sto_print_int64()   âœ… Var
sto_print_double()  âœ… Var
sto_print_string()  âŒ YOK!
```

### Sorun #4: TODO BÄ±rakÄ±lmÄ±ÅŸ
```c
// statement_codegen.c:82
// TODO: print_generate_code(output, stmt->data);  â† 3+ aydÄ±r TODO!
```

---

## ğŸ¯ Ã‡Ã–ZÃœMLENMESÄ° GEREKEN KATMANLAR

### Layer 1: Assembly Syntax Standardizasyonu
**SeÃ§im:** AT&T Syntax (GCC default, mevcut sistem)

**YapÄ±lmasÄ± Gerekenler:**
1. `print_codegen.c` â†’ NASM'den AT&T'ye port et
2. TÃ¼m `;` â†’ `#` deÄŸiÅŸiklikleri
3. `mov dest, src` â†’ `movq src, dest` deÄŸiÅŸiklikleri
4. `section .data` â†’ `.section .data` deÄŸiÅŸiklikleri
5. `db "text"` â†’ `.string "text"` deÄŸiÅŸiklikleri

### Layer 2: Print Codegen Implementation
**YapÄ±lmasÄ± Gerekenler:**
1. AT&T syntax ile yeni `print_generate_code_att()` yaz
2. `statement_codegen.c` TODO'yu kaldÄ±r
3. GerÃ§ek fonksiyon Ã§aÄŸrÄ±sÄ± ekle

### Layer 3: Runtime String Support
**YapÄ±lmasÄ± Gerekenler:**
1. `sto_print_string()` fonksiyonu ekle (`runtime/sto/sto_runtime.c`)
2. SSO (Small String Optimization) ile entegre et
3. Printf wrapper veya syscall implementasyonu

### Layer 4: Integration & Testing
**YapÄ±lmasÄ± Gerekenler:**
1. Test suite: `test_print_literal.mlp`, `test_print_variable.mlp`
2. Compiler rebuild ve test
3. TÃ¼m modÃ¼llerin AT&T syntax validation

---

## ğŸ“‹ ACÄ°L EYLEM PLANI

### YZ_76: ASSEMBLY SYNTAX CRISIS FIX (3-4 saat)

**Hedef:** Print modÃ¼lÃ¼nÃ¼ Ã§alÄ±ÅŸÄ±r hale getir + syntax tutarlÄ±lÄ±ÄŸÄ±nÄ± saÄŸla

#### AdÄ±m 1: Runtime String Print (30 dk)
```c
// runtime/sto/sto_runtime.c
void sto_print_string(const char* str) {
    if (!str) return;
    printf("%s\n", str);
    fflush(stdout);
}
```

#### AdÄ±m 2: AT&T Print Codegen (1.5 saat)
```c
// compiler/stage0/modules/print/print_codegen_att.c (YENÄ° DOSYA)
void print_generate_code_att(FILE* output, PrintStatement* stmt, FunctionDeclaration* func) {
    if (!stmt || !stmt->value) return;
    
    if (stmt->type == PRINT_STRING_LITERAL) {
        // String literal â†’ .rodata section + printf call
        static int str_counter = 0;
        fprintf(output, ".section .rodata\n");
        fprintf(output, ".LC%d:\n", str_counter);
        fprintf(output, "    .string \"%s\\n\"\n", stmt->value);
        fprintf(output, ".text\n");
        fprintf(output, "    # Print literal: %s\n", stmt->value);
        fprintf(output, "    leaq .LC%d(%%rip), %%rdi\n", str_counter);
        fprintf(output, "    call printf@PLT\n");
        str_counter++;
    }
    else if (stmt->type == PRINT_VARIABLE) {
        // Variable â†’ runtime fonksiyon Ã§aÄŸrÄ±sÄ±
        fprintf(output, "    # Print variable: %s\n", stmt->value);
        int offset = function_get_var_offset(func, stmt->value);
        fprintf(output, "    movq %d(%%rbp), %%rdi\n", offset);
        fprintf(output, "    call sto_print_int64@PLT\n");
    }
}
```

#### AdÄ±m 3: Statement Codegen Integration (15 dk)
```c
// statement_codegen.c:81
case STMT_PRINT: {
    PrintStatement* print_stmt = (PrintStatement*)stmt->data;
    if (print_stmt) {
        print_generate_code_att(output, print_stmt, func);  // âœ… YENÄ°!
    }
    break;
}
```

#### AdÄ±m 4: Build System Update (15 dk)
```makefile
# Compiler modules
PRINT_OBJS = print_parser.o print.o print_codegen_att.o

# Link with runtime
LDFLAGS = -L../../runtime/sto -lsto
```

#### AdÄ±m 5: Test & Verify (1 saat)
```mlp
# test_print_basic.mlp
function main() returns numeric
    print("Hello, World!")
    print("MELP is working!")
    return 0
end

# test_print_variable.mlp
function main() returns numeric
    numeric x = 42
    print("Value:")
    # TODO: Variable printing syntax
    return x
end
```

**Beklenen Ã‡Ä±ktÄ±:**
```
Hello, World!
MELP is working!
```

#### AdÄ±m 6: Syntax Cleanup (30 dk)
- [ ] `print_codegen.c` (NASM) â†’ `print_codegen_nasm.c.deprecated` olarak rename
- [ ] TÃ¼m Makefile'larda `print_codegen_att.o` kullan
- [ ] `print_codegen.h` â†’ AT&T fonksiyon signature'larÄ±na gÃ¼ncelle

---

## ğŸ”„ REFACTOR STRATEJÄ°SÄ°

### KÄ±sa Vadeli (YZ_76 - 4 saat)
1. âœ… Print modÃ¼lÃ¼nÃ¼ AT&T'ye port et
2. âœ… Runtime string print ekle
3. âœ… Test ve verify
4. âœ… NASM dosyalarÄ±nÄ± deprecate et

### Orta Vadeli (YZ_77 - 2 saat)
1. TÃ¼m modÃ¼llerin AT&T syntax doÄŸrulamasÄ±
2. Build system'de NASM reference'larÄ± temizle
3. Documentation update (syntax standardÄ±)

### Uzun Vadeli (Phase 18+)
1. LLVM backend kullanÄ±mÄ±nÄ± artÄ±r (assembly yerine IR)
2. Multi-target support (x86-64, ARM) - LLVM IR Ã¼zerinden
3. Assembly generation'Ä± sadece fallback olarak kullan

---

## ğŸ“š REFERANSLAR

**YZ_04 (Control Flow):**
- AT&T syntax migration rationale
- "GCC defaults to AT&T syntax"
- Comparison/control_flow codegen examples

**YZ_61 (Print Parser):**
- PrintStatement struct definition
- Parser implementation (doÄŸru)
- Codegen TODO olarak bÄ±rakÄ±lmÄ±ÅŸ (yanlÄ±ÅŸ)

**Current Codebase:**
- `compiler/stage0/modules/print/print_codegen.c` - NASM (deprecated)
- `compiler/stage0/modules/statement/statement_codegen.c:81` - TODO
- `runtime/sto/sto_runtime.c` - String print eksik

---

## ğŸ“ Ã–ÄRENÄ°LEN DERSLER

### 1. Syntax StandardÄ± BaÅŸtan Belirlenmeli
- âŒ ModÃ¼ler geliÅŸtirme sÄ±rasÄ±nda farklÄ± syntax'lar karÄ±ÅŸtÄ±
- âœ… Architecture dokÃ¼manÄ±nda syntax standardÄ± belirtilmeli

### 2. TODO BÄ±rakmak Tehlikeli
- âŒ "TODO" 3+ ay unutuldu, print() hiÃ§ Ã§alÄ±ÅŸmadÄ±
- âœ… Critical path'teki TODO'lar hemen Ã§Ã¶zÃ¼lmeli

### 3. Integration Testing Eksik
- âŒ Parser test edildi ama codegen test edilmedi
- âœ… End-to-end test suite gerekli (parse â†’ codegen â†’ runtime â†’ execute)

### 4. Modular â‰  Independent
- âŒ Print modÃ¼lÃ¼ baÄŸÄ±msÄ±z geliÅŸtirildi, syntax uyumsuz
- âœ… ModÃ¼ller ortak standartlara uymalÄ±

---

## âœ… BAÅARI KRÄ°TERLERÄ° (YZ_76)

1. **Compilation:**
   ```bash
   ./functions_compiler test_print_basic.mlp test_print.s
   # âœ… No errors
   ```

2. **Assembly Syntax:**
   ```bash
   cat test_print.s | grep -E '(;|section|db |mov.*,.*rax)'
   # âœ… No NASM syntax (empty output)
   
   cat test_print.s | grep -E '(#|\.section|\.string|movq.*%)'
   # âœ… All AT&T syntax
   ```

3. **Execution:**
   ```bash
   gcc -no-pie test_print.s -L runtime/sto -lsto -o test_print
   ./test_print
   # âœ… Output: "Hello, World!"
   ```

4. **Runtime Integration:**
   ```bash
   nm runtime/sto/libsto.so | grep sto_print
   # âœ… Shows: sto_print_int64, sto_print_double, sto_print_string
   ```

---

## ğŸš€ SONUÃ‡

**Durum:** ğŸ”´ Kritik syntax inconsistency tespit edildi  
**Etki:** Print statement'larÄ± **hiÃ§ Ã§alÄ±ÅŸmÄ±yor**  
**Ã‡Ã¶zÃ¼m:** YZ_76 ile AT&T syntax standardizasyonu + print implementation  
**SÃ¼re:** ~4 saat (runtime + codegen + test)

**Sonraki YZ (YZ_76) gÃ¶revleri:**
1. Runtime: `sto_print_string()` implement et
2. Codegen: AT&T syntax print codegen yaz
3. Integration: Statement codegen TODO'yu kaldÄ±r
4. Test: End-to-end print tests
5. Cleanup: NASM artifacts temizle

---

**Rapor HazÄ±rlayan:** YZ_75 (Print bug investigation)  
**Tarih:** 14 AralÄ±k 2025  
**Durum:** ACÄ°L EYLEM GEREKTÄ°RÄ°YOR ğŸš¨
