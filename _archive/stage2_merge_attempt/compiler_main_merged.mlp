-- lang: en-US
-- syntax: mlp
-- MLP Stage2 Compiler - Main Entry Point
-- Integration of all Stage2 modules: lexer, parser, codegen, codegen_advanced, type_system
-- 6 Esas Compliant: MODULAR (<300), STATELESS, STRUCT+FUNC
-- Target: Self-hosting MLP compiler (MLP → C → Binary)

-- BEGIN IMPORT: lexer.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Lexer Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 lexer.mlp (635 → ~450 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- =============================================================================
-- TOKEN TYPES
-- =============================================================================

Numeric TOKEN_EOF = 0
Numeric TOKEN_IDENTIFIER = 1
Numeric TOKEN_NUMBER = 2
Numeric TOKEN_STRING = 3
Numeric TOKEN_INTERPOLATED_STRING = 4

-- Keywords (10-26)
Numeric TOKEN_FUNCTION = 10
Numeric TOKEN_END_FUNCTION = 11
Numeric TOKEN_STRUCT = 12
Numeric TOKEN_END_STRUCT = 13
Numeric TOKEN_IF = 14
Numeric TOKEN_THEN = 15
Numeric TOKEN_ELSE = 16
Numeric TOKEN_END_IF = 17
Numeric TOKEN_WHILE = 18
Numeric TOKEN_END = 19
Numeric TOKEN_RETURN = 20
Numeric TOKEN_IMPORT = 21
Numeric TOKEN_AS = 22
Numeric TOKEN_BREAK = 23
Numeric TOKEN_CONTINUE = 24
Numeric TOKEN_MODULE = 25
Numeric TOKEN_ENUM = 26

-- Types (30-34)
Numeric TOKEN_TYPE_STRING = 30
Numeric TOKEN_TYPE_NUMERIC = 31
Numeric TOKEN_TYPE_LIST = 32
Numeric TOKEN_TYPE_I32 = 33
Numeric TOKEN_TYPE_F64 = 34

-- Operators (40-54)
Numeric TOKEN_PLUS = 40
Numeric TOKEN_MINUS = 41
Numeric TOKEN_STAR = 42
Numeric TOKEN_DIV = 43
Numeric TOKEN_MOD = 44
Numeric TOKEN_ASSIGN = 45
Numeric TOKEN_EQ = 46
Numeric TOKEN_NEQ = 47
Numeric TOKEN_LT = 48
Numeric TOKEN_GT = 49
Numeric TOKEN_LTE = 50
Numeric TOKEN_GTE = 51
Numeric TOKEN_AND = 52
Numeric TOKEN_OR = 53
Numeric TOKEN_NOT = 54

-- Delimiters (60-67)
Numeric TOKEN_LEFT_PAREN = 60
Numeric TOKEN_RIGHT_PAREN = 61
Numeric TOKEN_LEFT_BRACKET = 62
Numeric TOKEN_RIGHT_BRACKET = 63
Numeric TOKEN_COMMA = 64
Numeric TOKEN_SEMICOLON = 65
Numeric TOKEN_DOT = 66
Numeric TOKEN_COLON = 67

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct Token then
    Numeric type
    String value
    Numeric line
    Numeric column
    list interpolation_parts
end_struct

struct LexerState then
    String source_code
    Numeric position
    Numeric length
    Numeric line
    Numeric column
    Numeric eof_reached
end_struct

-- =============================================================================
-- FACTORY & STATE MANAGEMENT
-- =============================================================================

function make_token(token_type, value, line, column)
    Token token
    token.type = token_type
    token.value = value
    token.line = line
    token.column = column
    token.interpolation_parts = list()
    return token
end_function

function lexer_state_create(source_code)
    LexerState state
    state.source_code = source_code
    state.position = 0
    state.length = string_length(source_code)
    state.line = 1
    state.column = 1
    state.eof_reached = 0
    return state
end_function

-- =============================================================================
-- CHARACTER HELPERS & CLASSIFICATION
-- =============================================================================

function char_at(state, offset)
    Numeric pos = state.position + offset
    if pos >= state.length then return "" end_if
    return string_substring(state.source_code, pos, 1)
end_function

function current_char(state)
    return char_at(state, 0)
end_function

function peek_char(state, offset)
    return char_at(state, offset)
end_function

function is_eof(state)
    if state.position >= state.length then return 1 end_if
    return 0
end_function

function advance(state)
    if is_eof(state) == 1 then return state end_if
    String ch = current_char(state)
    if ch == "\n" then
        state.line = state.line + 1
        state.column = 1
    else
        state.column = state.column + 1
    end_if
    state.position = state.position + 1
    return state
end_function

function is_digit(ch)
    if ch >= "0" then if ch <= "9" then return 1 end_if end_if
    return 0
end_function

function is_alpha(ch)
    if ch >= "a" then if ch <= "z" then return 1 end_if end_if
    if ch >= "A" then if ch <= "Z" then return 1 end_if end_if
    if ch == "_" then return 1 end_if
    return 0
end_function

function is_alnum(ch)
    if is_alpha(ch) == 1 then return 1 end_if
    if is_digit(ch) == 1 then return 1 end_if
    return 0
end_function

function is_whitespace(ch)
    if ch == " " then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- =============================================================================
-- WHITESPACE, COMMENTS & NUMBER/STRING READING
-- =============================================================================

function skip_whitespace(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_whitespace(ch) == 0 then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_line_comment(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == "\n" then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_whitespace_and_comments(state)
    while is_eof(state) == 0
        state = skip_whitespace(state)
        if is_eof(state) == 1 then break end_if
        String ch = current_char(state)
        String next = peek_char(state, 1)
        if ch == "-" then
            if next == "-" then
                state = skip_line_comment(state)
            else
                break
            end_if
        else
            break
        end_if
    end
    return state
end_function

function read_number(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_digit(ch) == 0 then
            if ch == "," then
                state = advance(state)
                continue
            end_if
            break
        end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    value = string_replace(value, ",", ".")
    Token token
    token = make_token(TOKEN_NUMBER, value, state.line, state.column)
    return token
end_function

function read_string(state, delimiter)
    state = advance(state)
    Numeric start = state.position
    list parts = list()
    String current_part = ""
    
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == delimiter then
            if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
            state = advance(state)
            break
        end_if
        if ch == "{" then
            if string_length(current_part) > 0 then
                mlp_list_add(parts, current_part)
                current_part = ""
            end_if
            state = advance(state)
            Numeric var_start = state.position
            while is_eof(state) == 0
                String vch = current_char(state)
                if vch == "}" then break end_if
                state = advance(state)
            end
            Numeric var_len = state.position - var_start
            String var_name = string_substring(state.source_code, var_start, var_len)
            mlp_list_add(parts, "{" + var_name + "}")
            state = advance(state)
        else
            current_part = current_part + ch
            state = advance(state)
        end_if
    end
    if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
    Numeric part_count = mlp_list_length(parts)
    if part_count > 1 then
        Token token
        token = make_token(TOKEN_INTERPOLATED_STRING, "", state.line, state.column)
        token.interpolation_parts = parts
        return token
    end_if
    if part_count == 1 then
        String final_value = mlp_list_get(parts, 0)
        return make_token(TOKEN_STRING, final_value, state.line, state.column)
    end_if
    return make_token(TOKEN_STRING, "", state.line, state.column)
end_function

-- =============================================================================
-- IDENTIFIER, OPERATOR READING & MAIN TOKENIZER
-- =============================================================================

function keyword_type(value)
    if value == "function" then return TOKEN_FUNCTION end_if
    if value == "end_function" then return TOKEN_END_FUNCTION end_if
    if value == "struct" then return TOKEN_STRUCT end_if
    if value == "end_struct" then return TOKEN_END_STRUCT end_if
    if value == "if" then return TOKEN_IF end_if
    if value == "then" then return TOKEN_THEN end_if
    if value == "else" then return TOKEN_ELSE end_if
    if value == "end_if" then return TOKEN_END_IF end_if
    if value == "while" then return TOKEN_WHILE end_if
    if value == "end" then return TOKEN_END end_if
    if value == "return" then return TOKEN_RETURN end_if
    if value == "import" then return TOKEN_IMPORT end_if
    if value == "as" then return TOKEN_AS end_if
    if value == "break" then return TOKEN_BREAK end_if
    if value == "continue" then return TOKEN_CONTINUE end_if
    if value == "module" then return TOKEN_MODULE end_if
    if value == "enum" then return TOKEN_ENUM end_if
    if value == "String" then return TOKEN_TYPE_STRING end_if
    if value == "Numeric" then return TOKEN_TYPE_NUMERIC end_if
    if value == "list" then return TOKEN_TYPE_LIST end_if
    if value == "i32" then return TOKEN_TYPE_I32 end_if
    if value == "f64" then return TOKEN_TYPE_F64 end_if
    return TOKEN_IDENTIFIER
end_function

function read_identifier(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_alnum(ch) == 0 then break end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    Numeric type = keyword_type(value)
    Token token
    token = make_token(type, value, state.line, state.column)
    return token
end_function

function read_operator(state)
    String ch = current_char(state)
    String next = peek_char(state, 1)
    
    -- Two-character operators
    if ch == "=" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_EQ, "==", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_ASSIGN, "=", state.line, state.column)
    end_if
    
    if ch == "!" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_NEQ, "!=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_NOT, "!", state.line, state.column)
    end_if
    
    if ch == "<" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_LTE, "<=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_LT, "<", state.line, state.column)
    end_if
    
    if ch == ">" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_GTE, ">=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_GT, ">", state.line, state.column)
    end_if
    
    if ch == "&" then
        if next == "&" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_AND, "&&", state.line, state.column)
        end_if
    end_if
    
    if ch == "|" then
        if next == "|" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_OR, "||", state.line, state.column)
        end_if
    end_if
    
    -- Single-character operators
    if ch == "+" then state = advance(state)
        return make_token(TOKEN_PLUS, "+", state.line, state.column) end_if
    if ch == "-" then state = advance(state)
        return make_token(TOKEN_MINUS, "-", state.line, state.column) end_if
    if ch == "*" then state = advance(state)
        return make_token(TOKEN_STAR, "*", state.line, state.column) end_if
    if ch == "/" then state = advance(state)
        return make_token(TOKEN_DIV, "/", state.line, state.column) end_if
    if ch == "%" then state = advance(state)
        return make_token(TOKEN_MOD, "%", state.line, state.column) end_if
    
    -- Delimiters
    if ch == "(" then state = advance(state)
        return make_token(TOKEN_LEFT_PAREN, "(", state.line, state.column) end_if
    if ch == ")" then state = advance(state)
        return make_token(TOKEN_RIGHT_PAREN, ")", state.line, state.column) end_if
    if ch == "[" then state = advance(state)
        return make_token(TOKEN_LEFT_BRACKET, "[", state.line, state.column) end_if
    if ch == "]" then state = advance(state)
        return make_token(TOKEN_RIGHT_BRACKET, "]", state.line, state.column) end_if
    if ch == "," then state = advance(state)
        return make_token(TOKEN_COMMA, ",", state.line, state.column) end_if
    if ch == ";" then state = advance(state)
        return make_token(TOKEN_SEMICOLON, ";", state.line, state.column) end_if
    if ch == "." then state = advance(state)
        return make_token(TOKEN_DOT, ".", state.line, state.column) end_if
    if ch == ":" then state = advance(state)
        return make_token(TOKEN_COLON, ":", state.line, state.column) end_if
    
    -- Unknown character
    state = advance(state)
    return make_token(TOKEN_EOF, "", state.line, state.column)
end_function

function get_next_token(state)
    if state.eof_reached == 1 then
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    state = skip_whitespace_and_comments(state)
    if is_eof(state) == 1 then
        state.eof_reached = 1
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    String ch = current_char(state)
    if is_digit(ch) == 1 then return read_number(state) end_if
    if ch == "\"" then return read_string(state, "\"") end_if
    if ch == "'" then return read_string(state, "'") end_if
    if is_alpha(ch) == 1 then return read_identifier(state) end_if
    return read_operator(state)
end_function

function tokenize(source_code)
    LexerState state
    state = lexer_state_create(source_code)
    list tokens = list()
    while state.eof_reached == 0
        Token token
        token = get_next_token(state)
        mlp_list_add(tokens, token)
        if token.type == TOKEN_EOF then break end_if
    end
    return tokens
end_function

-- =============================================================================
-- UTILITY: Token to String (for debugging)
-- =============================================================================

function token_type_name(type)
    if type == TOKEN_EOF then return "EOF" end_if
    if type == TOKEN_IDENTIFIER then return "IDENTIFIER" end_if
    if type == TOKEN_NUMBER then return "NUMBER" end_if
    if type == TOKEN_STRING then return "STRING" end_if
    if type == TOKEN_FUNCTION then return "FUNCTION" end_if
    return "UNKNOWN"
end_function
-- END IMPORT: lexer.mlp
-- BEGIN IMPORT: parser.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Parser Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 parser.mlp (661 → <500 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- BEGIN IMPORT: lexer.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Lexer Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 lexer.mlp (635 → ~450 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- =============================================================================
-- TOKEN TYPES
-- =============================================================================

Numeric TOKEN_EOF = 0
Numeric TOKEN_IDENTIFIER = 1
Numeric TOKEN_NUMBER = 2
Numeric TOKEN_STRING = 3
Numeric TOKEN_INTERPOLATED_STRING = 4

-- Keywords (10-26)
Numeric TOKEN_FUNCTION = 10
Numeric TOKEN_END_FUNCTION = 11
Numeric TOKEN_STRUCT = 12
Numeric TOKEN_END_STRUCT = 13
Numeric TOKEN_IF = 14
Numeric TOKEN_THEN = 15
Numeric TOKEN_ELSE = 16
Numeric TOKEN_END_IF = 17
Numeric TOKEN_WHILE = 18
Numeric TOKEN_END = 19
Numeric TOKEN_RETURN = 20
Numeric TOKEN_IMPORT = 21
Numeric TOKEN_AS = 22
Numeric TOKEN_BREAK = 23
Numeric TOKEN_CONTINUE = 24
Numeric TOKEN_MODULE = 25
Numeric TOKEN_ENUM = 26

-- Types (30-34)
Numeric TOKEN_TYPE_STRING = 30
Numeric TOKEN_TYPE_NUMERIC = 31
Numeric TOKEN_TYPE_LIST = 32
Numeric TOKEN_TYPE_I32 = 33
Numeric TOKEN_TYPE_F64 = 34

-- Operators (40-54)
Numeric TOKEN_PLUS = 40
Numeric TOKEN_MINUS = 41
Numeric TOKEN_STAR = 42
Numeric TOKEN_DIV = 43
Numeric TOKEN_MOD = 44
Numeric TOKEN_ASSIGN = 45
Numeric TOKEN_EQ = 46
Numeric TOKEN_NEQ = 47
Numeric TOKEN_LT = 48
Numeric TOKEN_GT = 49
Numeric TOKEN_LTE = 50
Numeric TOKEN_GTE = 51
Numeric TOKEN_AND = 52
Numeric TOKEN_OR = 53
Numeric TOKEN_NOT = 54

-- Delimiters (60-67)
Numeric TOKEN_LEFT_PAREN = 60
Numeric TOKEN_RIGHT_PAREN = 61
Numeric TOKEN_LEFT_BRACKET = 62
Numeric TOKEN_RIGHT_BRACKET = 63
Numeric TOKEN_COMMA = 64
Numeric TOKEN_SEMICOLON = 65
Numeric TOKEN_DOT = 66
Numeric TOKEN_COLON = 67

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct Token then
    Numeric type
    String value
    Numeric line
    Numeric column
    list interpolation_parts
end_struct

struct LexerState then
    String source_code
    Numeric position
    Numeric length
    Numeric line
    Numeric column
    Numeric eof_reached
end_struct

-- =============================================================================
-- FACTORY & STATE MANAGEMENT
-- =============================================================================

function make_token(token_type, value, line, column)
    Token token
    token.type = token_type
    token.value = value
    token.line = line
    token.column = column
    token.interpolation_parts = list()
    return token
end_function

function lexer_state_create(source_code)
    LexerState state
    state.source_code = source_code
    state.position = 0
    state.length = string_length(source_code)
    state.line = 1
    state.column = 1
    state.eof_reached = 0
    return state
end_function

-- =============================================================================
-- CHARACTER HELPERS & CLASSIFICATION
-- =============================================================================

function char_at(state, offset)
    Numeric pos = state.position + offset
    if pos >= state.length then return "" end_if
    return string_substring(state.source_code, pos, 1)
end_function

function current_char(state)
    return char_at(state, 0)
end_function

function peek_char(state, offset)
    return char_at(state, offset)
end_function

function is_eof(state)
    if state.position >= state.length then return 1 end_if
    return 0
end_function

function advance(state)
    if is_eof(state) == 1 then return state end_if
    String ch = current_char(state)
    if ch == "\n" then
        state.line = state.line + 1
        state.column = 1
    else
        state.column = state.column + 1
    end_if
    state.position = state.position + 1
    return state
end_function

function is_digit(ch)
    if ch >= "0" then if ch <= "9" then return 1 end_if end_if
    return 0
end_function

function is_alpha(ch)
    if ch >= "a" then if ch <= "z" then return 1 end_if end_if
    if ch >= "A" then if ch <= "Z" then return 1 end_if end_if
    if ch == "_" then return 1 end_if
    return 0
end_function

function is_alnum(ch)
    if is_alpha(ch) == 1 then return 1 end_if
    if is_digit(ch) == 1 then return 1 end_if
    return 0
end_function

function is_whitespace(ch)
    if ch == " " then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- =============================================================================
-- WHITESPACE, COMMENTS & NUMBER/STRING READING
-- =============================================================================

function skip_whitespace(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_whitespace(ch) == 0 then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_line_comment(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == "\n" then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_whitespace_and_comments(state)
    while is_eof(state) == 0
        state = skip_whitespace(state)
        if is_eof(state) == 1 then break end_if
        String ch = current_char(state)
        String next = peek_char(state, 1)
        if ch == "-" then
            if next == "-" then
                state = skip_line_comment(state)
            else
                break
            end_if
        else
            break
        end_if
    end
    return state
end_function

function read_number(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_digit(ch) == 0 then
            if ch == "," then
                state = advance(state)
                continue
            end_if
            break
        end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    value = string_replace(value, ",", ".")
    Token token
    token = make_token(TOKEN_NUMBER, value, state.line, state.column)
    return token
end_function

function read_string(state, delimiter)
    state = advance(state)
    Numeric start = state.position
    list parts = list()
    String current_part = ""
    
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == delimiter then
            if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
            state = advance(state)
            break
        end_if
        if ch == "{" then
            if string_length(current_part) > 0 then
                mlp_list_add(parts, current_part)
                current_part = ""
            end_if
            state = advance(state)
            Numeric var_start = state.position
            while is_eof(state) == 0
                String vch = current_char(state)
                if vch == "}" then break end_if
                state = advance(state)
            end
            Numeric var_len = state.position - var_start
            String var_name = string_substring(state.source_code, var_start, var_len)
            mlp_list_add(parts, "{" + var_name + "}")
            state = advance(state)
        else
            current_part = current_part + ch
            state = advance(state)
        end_if
    end
    if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
    Numeric part_count = mlp_list_length(parts)
    if part_count > 1 then
        Token token
        token = make_token(TOKEN_INTERPOLATED_STRING, "", state.line, state.column)
        token.interpolation_parts = parts
        return token
    end_if
    if part_count == 1 then
        String final_value = mlp_list_get(parts, 0)
        return make_token(TOKEN_STRING, final_value, state.line, state.column)
    end_if
    return make_token(TOKEN_STRING, "", state.line, state.column)
end_function

-- =============================================================================
-- IDENTIFIER, OPERATOR READING & MAIN TOKENIZER
-- =============================================================================

function keyword_type(value)
    if value == "function" then return TOKEN_FUNCTION end_if
    if value == "end_function" then return TOKEN_END_FUNCTION end_if
    if value == "struct" then return TOKEN_STRUCT end_if
    if value == "end_struct" then return TOKEN_END_STRUCT end_if
    if value == "if" then return TOKEN_IF end_if
    if value == "then" then return TOKEN_THEN end_if
    if value == "else" then return TOKEN_ELSE end_if
    if value == "end_if" then return TOKEN_END_IF end_if
    if value == "while" then return TOKEN_WHILE end_if
    if value == "end" then return TOKEN_END end_if
    if value == "return" then return TOKEN_RETURN end_if
    if value == "import" then return TOKEN_IMPORT end_if
    if value == "as" then return TOKEN_AS end_if
    if value == "break" then return TOKEN_BREAK end_if
    if value == "continue" then return TOKEN_CONTINUE end_if
    if value == "module" then return TOKEN_MODULE end_if
    if value == "enum" then return TOKEN_ENUM end_if
    if value == "String" then return TOKEN_TYPE_STRING end_if
    if value == "Numeric" then return TOKEN_TYPE_NUMERIC end_if
    if value == "list" then return TOKEN_TYPE_LIST end_if
    if value == "i32" then return TOKEN_TYPE_I32 end_if
    if value == "f64" then return TOKEN_TYPE_F64 end_if
    return TOKEN_IDENTIFIER
end_function

function read_identifier(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_alnum(ch) == 0 then break end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    Numeric type = keyword_type(value)
    Token token
    token = make_token(type, value, state.line, state.column)
    return token
end_function

function read_operator(state)
    String ch = current_char(state)
    String next = peek_char(state, 1)
    
    -- Two-character operators
    if ch == "=" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_EQ, "==", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_ASSIGN, "=", state.line, state.column)
    end_if
    
    if ch == "!" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_NEQ, "!=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_NOT, "!", state.line, state.column)
    end_if
    
    if ch == "<" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_LTE, "<=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_LT, "<", state.line, state.column)
    end_if
    
    if ch == ">" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_GTE, ">=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_GT, ">", state.line, state.column)
    end_if
    
    if ch == "&" then
        if next == "&" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_AND, "&&", state.line, state.column)
        end_if
    end_if
    
    if ch == "|" then
        if next == "|" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_OR, "||", state.line, state.column)
        end_if
    end_if
    
    -- Single-character operators
    if ch == "+" then state = advance(state)
        return make_token(TOKEN_PLUS, "+", state.line, state.column) end_if
    if ch == "-" then state = advance(state)
        return make_token(TOKEN_MINUS, "-", state.line, state.column) end_if
    if ch == "*" then state = advance(state)
        return make_token(TOKEN_STAR, "*", state.line, state.column) end_if
    if ch == "/" then state = advance(state)
        return make_token(TOKEN_DIV, "/", state.line, state.column) end_if
    if ch == "%" then state = advance(state)
        return make_token(TOKEN_MOD, "%", state.line, state.column) end_if
    
    -- Delimiters
    if ch == "(" then state = advance(state)
        return make_token(TOKEN_LEFT_PAREN, "(", state.line, state.column) end_if
    if ch == ")" then state = advance(state)
        return make_token(TOKEN_RIGHT_PAREN, ")", state.line, state.column) end_if
    if ch == "[" then state = advance(state)
        return make_token(TOKEN_LEFT_BRACKET, "[", state.line, state.column) end_if
    if ch == "]" then state = advance(state)
        return make_token(TOKEN_RIGHT_BRACKET, "]", state.line, state.column) end_if
    if ch == "," then state = advance(state)
        return make_token(TOKEN_COMMA, ",", state.line, state.column) end_if
    if ch == ";" then state = advance(state)
        return make_token(TOKEN_SEMICOLON, ";", state.line, state.column) end_if
    if ch == "." then state = advance(state)
        return make_token(TOKEN_DOT, ".", state.line, state.column) end_if
    if ch == ":" then state = advance(state)
        return make_token(TOKEN_COLON, ":", state.line, state.column) end_if
    
    -- Unknown character
    state = advance(state)
    return make_token(TOKEN_EOF, "", state.line, state.column)
end_function

function get_next_token(state)
    if state.eof_reached == 1 then
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    state = skip_whitespace_and_comments(state)
    if is_eof(state) == 1 then
        state.eof_reached = 1
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    String ch = current_char(state)
    if is_digit(ch) == 1 then return read_number(state) end_if
    if ch == "\"" then return read_string(state, "\"") end_if
    if ch == "'" then return read_string(state, "'") end_if
    if is_alpha(ch) == 1 then return read_identifier(state) end_if
    return read_operator(state)
end_function

function tokenize(source_code)
    LexerState state
    state = lexer_state_create(source_code)
    list tokens = list()
    while state.eof_reached == 0
        Token token
        token = get_next_token(state)
        mlp_list_add(tokens, token)
        if token.type == TOKEN_EOF then break end_if
    end
    return tokens
end_function

-- =============================================================================
-- UTILITY: Token to String (for debugging)
-- =============================================================================

function token_type_name(type)
    if type == TOKEN_EOF then return "EOF" end_if
    if type == TOKEN_IDENTIFIER then return "IDENTIFIER" end_if
    if type == TOKEN_NUMBER then return "NUMBER" end_if
    if type == TOKEN_STRING then return "STRING" end_if
    if type == TOKEN_FUNCTION then return "FUNCTION" end_if
    return "UNKNOWN"
end_function
-- END IMPORT: lexer.mlp

-- =============================================================================
-- AST NODE TYPES
-- =============================================================================

Numeric AST_PROGRAM = 0
Numeric AST_FUNCTION = 1
Numeric AST_STRUCT = 2
Numeric AST_VARIABLE_DECL = 3
Numeric AST_ASSIGNMENT = 4
Numeric AST_IF_STMT = 5
Numeric AST_WHILE_STMT = 6
Numeric AST_RETURN_STMT = 7
Numeric AST_BLOCK = 8
Numeric AST_BINARY_OP = 9
Numeric AST_UNARY_OP = 10
Numeric AST_CALL = 11
Numeric AST_IDENTIFIER = 12
Numeric AST_NUMBER = 13
Numeric AST_STRING = 14
Numeric AST_IMPORT = 15
Numeric AST_PRINT = 16

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct ASTNode then
    Numeric node_type
    String value
    list children
    Numeric line
    Numeric column
end_struct

struct ParserState then
    list tokens
    Numeric position
    Numeric scope_level
end_struct

-- =============================================================================
-- FACTORY FUNCTIONS
-- =============================================================================

function make_ast_node(node_type, value, line, column)
    ASTNode node
    node.node_type = node_type
    node.value = value
    node.children = list()
    node.line = line
    node.column = column
    return node
end_function

function make_parser_state(tokens)
    ParserState state
    state.tokens = tokens
    state.position = 0
    state.scope_level = 0
    return state
end_function

-- =============================================================================
-- TOKEN NAVIGATION
-- =============================================================================

function current_token(state)
    Numeric pos = state.position
    Numeric length = mlp_list_length(state.tokens)
    if pos >= length then
        Token eof_token = make_token(TOKEN_EOF, "", 0, 0)
        return eof_token
    end_if
    return mlp_list_get(state.tokens, pos)
end_function

function peek_token(state, offset)
    Numeric pos = state.position + offset
    Numeric length = mlp_list_length(state.tokens)
    if pos >= length then
        Token eof_token = make_token(TOKEN_EOF, "", 0, 0)
        return eof_token
    end_if
    return mlp_list_get(state.tokens, pos)
end_function

function advance_token(state)
    state.position = state.position + 1
    return state
end_function

function expect_token(state, expected_type)
    Token token = current_token(state)
    if token.type != expected_type then
        print "Parser error at line " print token.line
    end_if
    return advance_token(state)
end_function

function match_token(state, token_type)
    Token token = current_token(state)
    if token.type == token_type then
        return 1
    end_if
    return 0
end_function

-- =============================================================================
-- PRECEDENCE TABLE
-- =============================================================================

function get_precedence(token_type)
    if token_type == TOKEN_OR then return 10 end_if
    if token_type == TOKEN_AND then return 20 end_if
    if token_type == TOKEN_EQ then return 30 end_if
    if token_type == TOKEN_NEQ then return 30 end_if
    if token_type == TOKEN_LT then return 40 end_if
    if token_type == TOKEN_GT then return 40 end_if
    if token_type == TOKEN_LTE then return 40 end_if
    if token_type == TOKEN_GTE then return 40 end_if
    if token_type == TOKEN_PLUS then return 50 end_if
    if token_type == TOKEN_MINUS then return 50 end_if
    if token_type == TOKEN_STAR then return 60 end_if
    if token_type == TOKEN_DIV then return 60 end_if
    if token_type == TOKEN_MOD then return 60 end_if
    return 0
end_function

-- =============================================================================
-- EXPRESSION PARSING (PRATT STYLE)
-- =============================================================================

function parse_primary(state)
    Token token = current_token(state)
    
    -- Number literal
    if token.type == TOKEN_NUMBER then
        ASTNode node = make_ast_node(AST_NUMBER, token.value, token.line, token.column)
        state = advance_token(state)
        return node
    end_if
    
    -- String literal
    if token.type == TOKEN_STRING then
        ASTNode node = make_ast_node(AST_STRING, token.value, token.line, token.column)
        state = advance_token(state)
        return node
    end_if
    
    -- Identifier or function call
    if token.type == TOKEN_IDENTIFIER then
        ASTNode node = make_ast_node(AST_IDENTIFIER, token.value, token.line, token.column)
        state = advance_token(state)
        
        -- Check for function call
        Token next_token = current_token(state)
        if next_token.type == TOKEN_LEFT_PAREN then
            node.node_type = AST_CALL
            state = advance_token(state)
            
            -- Parse arguments
            if match_token(state, TOKEN_RIGHT_PAREN) == 0 then
                while 1 == 1
                    ASTNode arg = parse_expression(state, 0)
                    mlp_list_add(node.children, arg)
                    
                    Token comma_token = current_token(state)
                    if comma_token.type != TOKEN_COMMA then
                        break
                    end_if
                    state = advance_token(state)
                end
            end_if
            
            state = expect_token(state, TOKEN_RIGHT_PAREN)
        end_if
        
        return node
    end_if
    
    -- Parenthesized expression
    if token.type == TOKEN_LEFT_PAREN then
        state = advance_token(state)
        ASTNode expr = parse_expression(state, 0)
        state = expect_token(state, TOKEN_RIGHT_PAREN)
        return expr
    end_if
    
    -- Unary operators
    if token.type == TOKEN_MINUS then
        ASTNode node = make_ast_node(AST_UNARY_OP, "-", token.line, token.column)
        state = advance_token(state)
        mlp_list_add(node.children, parse_primary(state))
        return node
    end_if
    
    if token.type == TOKEN_NOT then
        ASTNode node = make_ast_node(AST_UNARY_OP, "!", token.line, token.column)
        state = advance_token(state)
        mlp_list_add(node.children, parse_primary(state))
        return node
    end_if
    
    -- Error
    print "Parser error at line " print token.line
    ASTNode error_node = make_ast_node(AST_NUMBER, "0", token.line, token.column)
    return error_node
end_function

function parse_expression(state, min_precedence)
    ASTNode left = parse_primary(state)
    
    while 1 == 1
        Token op_token = current_token(state)
        Numeric op_prec = get_precedence(op_token.type)
        
        if op_prec == 0 then break end_if
        if op_prec < min_precedence then break end_if
        
        String op_value = op_token.value
        Numeric op_line = op_token.line
        Numeric op_col = op_token.column
        state = advance_token(state)
        
        ASTNode right = parse_expression(state, op_prec + 1)
        
        ASTNode binary_node = make_ast_node(AST_BINARY_OP, op_value, op_line, op_col)
        mlp_list_add(binary_node.children, left)
        mlp_list_add(binary_node.children, right)
        
        left = binary_node
    end
    
    return left
end_function

-- =============================================================================
-- STATEMENT PARSING
-- =============================================================================

function parse_import_statement(state)
    Token import_token = current_token(state)
    state = expect_token(state, TOKEN_IMPORT)
    
    Token module_token = current_token(state)
    state = expect_token(state, TOKEN_STRING)
    
    ASTNode node = make_ast_node(AST_IMPORT, module_token.value, import_token.line, import_token.column)
    return node
end_function

function parse_print_statement(state)
    Token print_token = current_token(state)
    state = expect_token(state, TOKEN_PRINT)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_PRINT, "", print_token.line, print_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_return_statement(state)
    Token return_token = current_token(state)
    state = expect_token(state, TOKEN_RETURN)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_RETURN_STMT, "", return_token.line, return_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_variable_declaration(state)
    Token type_token = current_token(state)
    state = advance_token(state)
    
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    
    ASTNode node = make_ast_node(AST_VARIABLE_DECL, name_token.value, type_token.line, type_token.column)
    node.value = type_token.value + ":" + name_token.value
    
    -- Check for assignment
    Token assign_token = current_token(state)
    if assign_token.type == TOKEN_ASSIGN then
        state = advance_token(state)
        ASTNode init_expr = parse_expression(state, 0)
        mlp_list_add(node.children, init_expr)
    end_if
    
    return node
end_function

function parse_assignment(state)
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    state = expect_token(state, TOKEN_ASSIGN)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_ASSIGNMENT, name_token.value, name_token.line, name_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_if_statement(state)
    Token if_token = current_token(state)
    state = expect_token(state, TOKEN_IF)
    
    ASTNode condition = parse_expression(state, 0)
    state = expect_token(state, TOKEN_THEN)
    
    ASTNode then_block = parse_block(state, TOKEN_END_IF)
    
    ASTNode node = make_ast_node(AST_IF_STMT, "", if_token.line, if_token.column)
    mlp_list_add(node.children, condition)
    mlp_list_add(node.children, then_block)
    
    -- Check for else
    Token next_token = current_token(state)
    if next_token.type == TOKEN_ELSE then
        state = advance_token(state)
        ASTNode else_block = parse_block(state, TOKEN_END_IF)
        mlp_list_add(node.children, else_block)
    end_if
    
    state = expect_token(state, TOKEN_END_IF)
    return node
end_function

function parse_while_statement(state)
    Token while_token = current_token(state)
    state = expect_token(state, TOKEN_WHILE)
    
    ASTNode condition = parse_expression(state, 0)
    ASTNode body = parse_block(state, TOKEN_END)
    
    state = expect_token(state, TOKEN_END)
    
    ASTNode node = make_ast_node(AST_WHILE_STMT, "", while_token.line, while_token.column)
    mlp_list_add(node.children, condition)
    mlp_list_add(node.children, body)
    return node
end_function

function parse_function_declaration(state)
    Token func_token = current_token(state)
    state = expect_token(state, TOKEN_FUNCTION)
    
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    
    ASTNode node = make_ast_node(AST_FUNCTION, name_token.value, func_token.line, func_token.column)
    
    state = expect_token(state, TOKEN_LEFT_PAREN)
    
    -- Parse parameters
    if match_token(state, TOKEN_RIGHT_PAREN) == 0 then
        while 1 == 1
            Token param_name = current_token(state)
            state = expect_token(state, TOKEN_IDENTIFIER)
            
            ASTNode param_node = make_ast_node(AST_IDENTIFIER, param_name.value, param_name.line, param_name.column)
            mlp_list_add(node.children, param_node)
            
            Token comma_token = current_token(state)
            if comma_token.type != TOKEN_COMMA then
                break
            end_if
            state = advance_token(state)
        end
    end_if
    
    state = expect_token(state, TOKEN_RIGHT_PAREN)
    
    -- Parse function body
    ASTNode body = parse_block(state, TOKEN_END_FUNCTION)
    mlp_list_add(node.children, body)
    
    state = expect_token(state, TOKEN_END_FUNCTION)
    return node
end_function

function parse_statement(state)
    Token token = current_token(state)
    
    if token.type == TOKEN_IMPORT then
        return parse_import_statement(state)
    end_if
     return parse_import_statement(state) end_if
    if token.type == TOKEN_FUNCTION then return parse_function_declaration(state) end_if
    if token.type == TOKEN_PRINT then return parse_print_statement(state) end_if
    if token.type == TOKEN_RETURN then return parse_return_statement(state) end_if
    if token.type == TOKEN_IF then return parse_if_statement(state) end_if
    if token.type == TOKEN_WHILE then return parse_while_statement(state) end_if
    if token.type == TOKEN_TYPE_NUMERIC then return parse_variable_declaration(state) end_if
    if token.type == TOKEN_TYPE_STRING then return parse_variable_declaration(state) end_if
    if token.type == TOKEN_IDENTIFIER then return parse_assignment(state) end_if
    
    print "Parser error at line "_function

function parse_block(state, end_token_type)
    list statements = list()
    
    while 1 == 1
        Token token = current_token(state)
        
        if token.type == TOKEN_EOF then
            break
        end_if
        
        if token.type == end_token_type then
            break
        end_if
        
        ASTNode stmt = parse_statement(state)
        mlp_list_add(statements, stmt)
    end
    
    Token block_token = current_token(state)
    ASTNode block_node = make_ast_node(AST_BLOCK, "", block_token.line, block_token.column)
    block_node.children = statements
    return block_node
end_function

-- =============================================================================
-- TOP-LEVEL PARSER
-- =============================================================================

function parse(tokens)
    ParserState state = make_parser_state(tokens)
    ASTNode root = parse_block(state, TOKEN_EOF)
    root.node_type = AST_PROGRAM
    return root
end_function

function ast_to_string(node, indent)
    String result = ""
    
    -- Add indentation
    Numeric i = 0
    while i < indent
        result = result + "  "
        i = i + 1
    end
    
    -- Node type
    if node.node_type == AST_PROGRAM then result = result + "PROGRAM" end_if
    if node.node_type == AST_FUNCTION then result = result + "FUNCTION " + node.value end_if
    if node.node_type == AST_VARIABLE_DECL then result = result + "VAR_DECL " + node.value end_if
    if node.node_type == AST_ASSIGNMENT then result = result + "ASSIGN " + node.value end_if
    if node.node_type == AST_IF_STMT then result = result + "IF" end_if
    if node.node_type == AST_WHILE_STMT then result = result + "WHILE" end_if
    if node.node_type == AST_RETURN_STMT then result = result + "RETURN" end_if
    if node.node_type == AST_BLOCK then result = result + "BLOCK" end_if
    if node.node_type == AST_BINARY_OP then result = result + "BINARY_OP " + node.value end_if
    if node.node_type == AST_UNARY_OP then result = result + "UNARY_OP " + node.value end_if
    if node.node_type == AST_CALL then result = result + "CALL " + node.value end_if
    if node.node_type == AST_IDENTIFIER then result = result + "ID " + node.value end_if
    if node.node_type == AST_NUMBER then result = result + "NUM " + node.value end_if
    if node.node_type == AST_STRING then result = result + "STR " + node.value end_if
    if node.node_type == AST_IMPORT then result = result + "IMPORT " + node.value end_if
    if node.node_type == AST_PRINT then result = result + "PRINT" end_if
    
    result = result + "\n"
    
    -- Children
    Numeric child_count = mlp_list_length(node.children)
    Numeric j = 0
    while j < child_count
        ASTNode child = mlp_list_get(node.children, j)
        result = result + ast_to_string(child, indent + 1)
        j = j + 1
    end
    
    return result
end_function
-- END IMPORT: lexer.mlp
-- BEGIN IMPORT: codegen.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Codegen Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 codegen.mlp (810 → <600 lines)
-- 6 Esas Compliant: MODULAR (<600), STATELESS, STRUCT+FUNC
-- Target: C code generation (GCC backend)

-- BEGIN IMPORT: lexer.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Lexer Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 lexer.mlp (635 → ~450 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- =============================================================================
-- TOKEN TYPES
-- =============================================================================

Numeric TOKEN_EOF = 0
Numeric TOKEN_IDENTIFIER = 1
Numeric TOKEN_NUMBER = 2
Numeric TOKEN_STRING = 3
Numeric TOKEN_INTERPOLATED_STRING = 4

-- Keywords (10-26)
Numeric TOKEN_FUNCTION = 10
Numeric TOKEN_END_FUNCTION = 11
Numeric TOKEN_STRUCT = 12
Numeric TOKEN_END_STRUCT = 13
Numeric TOKEN_IF = 14
Numeric TOKEN_THEN = 15
Numeric TOKEN_ELSE = 16
Numeric TOKEN_END_IF = 17
Numeric TOKEN_WHILE = 18
Numeric TOKEN_END = 19
Numeric TOKEN_RETURN = 20
Numeric TOKEN_IMPORT = 21
Numeric TOKEN_AS = 22
Numeric TOKEN_BREAK = 23
Numeric TOKEN_CONTINUE = 24
Numeric TOKEN_MODULE = 25
Numeric TOKEN_ENUM = 26

-- Types (30-34)
Numeric TOKEN_TYPE_STRING = 30
Numeric TOKEN_TYPE_NUMERIC = 31
Numeric TOKEN_TYPE_LIST = 32
Numeric TOKEN_TYPE_I32 = 33
Numeric TOKEN_TYPE_F64 = 34

-- Operators (40-54)
Numeric TOKEN_PLUS = 40
Numeric TOKEN_MINUS = 41
Numeric TOKEN_STAR = 42
Numeric TOKEN_DIV = 43
Numeric TOKEN_MOD = 44
Numeric TOKEN_ASSIGN = 45
Numeric TOKEN_EQ = 46
Numeric TOKEN_NEQ = 47
Numeric TOKEN_LT = 48
Numeric TOKEN_GT = 49
Numeric TOKEN_LTE = 50
Numeric TOKEN_GTE = 51
Numeric TOKEN_AND = 52
Numeric TOKEN_OR = 53
Numeric TOKEN_NOT = 54

-- Delimiters (60-67)
Numeric TOKEN_LEFT_PAREN = 60
Numeric TOKEN_RIGHT_PAREN = 61
Numeric TOKEN_LEFT_BRACKET = 62
Numeric TOKEN_RIGHT_BRACKET = 63
Numeric TOKEN_COMMA = 64
Numeric TOKEN_SEMICOLON = 65
Numeric TOKEN_DOT = 66
Numeric TOKEN_COLON = 67

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct Token then
    Numeric type
    String value
    Numeric line
    Numeric column
    list interpolation_parts
end_struct

struct LexerState then
    String source_code
    Numeric position
    Numeric length
    Numeric line
    Numeric column
    Numeric eof_reached
end_struct

-- =============================================================================
-- FACTORY & STATE MANAGEMENT
-- =============================================================================

function make_token(token_type, value, line, column)
    Token token
    token.type = token_type
    token.value = value
    token.line = line
    token.column = column
    token.interpolation_parts = list()
    return token
end_function

function lexer_state_create(source_code)
    LexerState state
    state.source_code = source_code
    state.position = 0
    state.length = string_length(source_code)
    state.line = 1
    state.column = 1
    state.eof_reached = 0
    return state
end_function

-- =============================================================================
-- CHARACTER HELPERS & CLASSIFICATION
-- =============================================================================

function char_at(state, offset)
    Numeric pos = state.position + offset
    if pos >= state.length then return "" end_if
    return string_substring(state.source_code, pos, 1)
end_function

function current_char(state)
    return char_at(state, 0)
end_function

function peek_char(state, offset)
    return char_at(state, offset)
end_function

function is_eof(state)
    if state.position >= state.length then return 1 end_if
    return 0
end_function

function advance(state)
    if is_eof(state) == 1 then return state end_if
    String ch = current_char(state)
    if ch == "\n" then
        state.line = state.line + 1
        state.column = 1
    else
        state.column = state.column + 1
    end_if
    state.position = state.position + 1
    return state
end_function

function is_digit(ch)
    if ch >= "0" then if ch <= "9" then return 1 end_if end_if
    return 0
end_function

function is_alpha(ch)
    if ch >= "a" then if ch <= "z" then return 1 end_if end_if
    if ch >= "A" then if ch <= "Z" then return 1 end_if end_if
    if ch == "_" then return 1 end_if
    return 0
end_function

function is_alnum(ch)
    if is_alpha(ch) == 1 then return 1 end_if
    if is_digit(ch) == 1 then return 1 end_if
    return 0
end_function

function is_whitespace(ch)
    if ch == " " then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- =============================================================================
-- WHITESPACE, COMMENTS & NUMBER/STRING READING
-- =============================================================================

function skip_whitespace(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_whitespace(ch) == 0 then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_line_comment(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == "\n" then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_whitespace_and_comments(state)
    while is_eof(state) == 0
        state = skip_whitespace(state)
        if is_eof(state) == 1 then break end_if
        String ch = current_char(state)
        String next = peek_char(state, 1)
        if ch == "-" then
            if next == "-" then
                state = skip_line_comment(state)
            else
                break
            end_if
        else
            break
        end_if
    end
    return state
end_function

function read_number(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_digit(ch) == 0 then
            if ch == "," then
                state = advance(state)
                continue
            end_if
            break
        end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    value = string_replace(value, ",", ".")
    Token token
    token = make_token(TOKEN_NUMBER, value, state.line, state.column)
    return token
end_function

function read_string(state, delimiter)
    state = advance(state)
    Numeric start = state.position
    list parts = list()
    String current_part = ""
    
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == delimiter then
            if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
            state = advance(state)
            break
        end_if
        if ch == "{" then
            if string_length(current_part) > 0 then
                mlp_list_add(parts, current_part)
                current_part = ""
            end_if
            state = advance(state)
            Numeric var_start = state.position
            while is_eof(state) == 0
                String vch = current_char(state)
                if vch == "}" then break end_if
                state = advance(state)
            end
            Numeric var_len = state.position - var_start
            String var_name = string_substring(state.source_code, var_start, var_len)
            mlp_list_add(parts, "{" + var_name + "}")
            state = advance(state)
        else
            current_part = current_part + ch
            state = advance(state)
        end_if
    end
    if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
    Numeric part_count = mlp_list_length(parts)
    if part_count > 1 then
        Token token
        token = make_token(TOKEN_INTERPOLATED_STRING, "", state.line, state.column)
        token.interpolation_parts = parts
        return token
    end_if
    if part_count == 1 then
        String final_value = mlp_list_get(parts, 0)
        return make_token(TOKEN_STRING, final_value, state.line, state.column)
    end_if
    return make_token(TOKEN_STRING, "", state.line, state.column)
end_function

-- =============================================================================
-- IDENTIFIER, OPERATOR READING & MAIN TOKENIZER
-- =============================================================================

function keyword_type(value)
    if value == "function" then return TOKEN_FUNCTION end_if
    if value == "end_function" then return TOKEN_END_FUNCTION end_if
    if value == "struct" then return TOKEN_STRUCT end_if
    if value == "end_struct" then return TOKEN_END_STRUCT end_if
    if value == "if" then return TOKEN_IF end_if
    if value == "then" then return TOKEN_THEN end_if
    if value == "else" then return TOKEN_ELSE end_if
    if value == "end_if" then return TOKEN_END_IF end_if
    if value == "while" then return TOKEN_WHILE end_if
    if value == "end" then return TOKEN_END end_if
    if value == "return" then return TOKEN_RETURN end_if
    if value == "import" then return TOKEN_IMPORT end_if
    if value == "as" then return TOKEN_AS end_if
    if value == "break" then return TOKEN_BREAK end_if
    if value == "continue" then return TOKEN_CONTINUE end_if
    if value == "module" then return TOKEN_MODULE end_if
    if value == "enum" then return TOKEN_ENUM end_if
    if value == "String" then return TOKEN_TYPE_STRING end_if
    if value == "Numeric" then return TOKEN_TYPE_NUMERIC end_if
    if value == "list" then return TOKEN_TYPE_LIST end_if
    if value == "i32" then return TOKEN_TYPE_I32 end_if
    if value == "f64" then return TOKEN_TYPE_F64 end_if
    return TOKEN_IDENTIFIER
end_function

function read_identifier(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_alnum(ch) == 0 then break end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    Numeric type = keyword_type(value)
    Token token
    token = make_token(type, value, state.line, state.column)
    return token
end_function

function read_operator(state)
    String ch = current_char(state)
    String next = peek_char(state, 1)
    
    -- Two-character operators
    if ch == "=" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_EQ, "==", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_ASSIGN, "=", state.line, state.column)
    end_if
    
    if ch == "!" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_NEQ, "!=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_NOT, "!", state.line, state.column)
    end_if
    
    if ch == "<" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_LTE, "<=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_LT, "<", state.line, state.column)
    end_if
    
    if ch == ">" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_GTE, ">=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_GT, ">", state.line, state.column)
    end_if
    
    if ch == "&" then
        if next == "&" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_AND, "&&", state.line, state.column)
        end_if
    end_if
    
    if ch == "|" then
        if next == "|" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_OR, "||", state.line, state.column)
        end_if
    end_if
    
    -- Single-character operators
    if ch == "+" then state = advance(state)
        return make_token(TOKEN_PLUS, "+", state.line, state.column) end_if
    if ch == "-" then state = advance(state)
        return make_token(TOKEN_MINUS, "-", state.line, state.column) end_if
    if ch == "*" then state = advance(state)
        return make_token(TOKEN_STAR, "*", state.line, state.column) end_if
    if ch == "/" then state = advance(state)
        return make_token(TOKEN_DIV, "/", state.line, state.column) end_if
    if ch == "%" then state = advance(state)
        return make_token(TOKEN_MOD, "%", state.line, state.column) end_if
    
    -- Delimiters
    if ch == "(" then state = advance(state)
        return make_token(TOKEN_LEFT_PAREN, "(", state.line, state.column) end_if
    if ch == ")" then state = advance(state)
        return make_token(TOKEN_RIGHT_PAREN, ")", state.line, state.column) end_if
    if ch == "[" then state = advance(state)
        return make_token(TOKEN_LEFT_BRACKET, "[", state.line, state.column) end_if
    if ch == "]" then state = advance(state)
        return make_token(TOKEN_RIGHT_BRACKET, "]", state.line, state.column) end_if
    if ch == "," then state = advance(state)
        return make_token(TOKEN_COMMA, ",", state.line, state.column) end_if
    if ch == ";" then state = advance(state)
        return make_token(TOKEN_SEMICOLON, ";", state.line, state.column) end_if
    if ch == "." then state = advance(state)
        return make_token(TOKEN_DOT, ".", state.line, state.column) end_if
    if ch == ":" then state = advance(state)
        return make_token(TOKEN_COLON, ":", state.line, state.column) end_if
    
    -- Unknown character
    state = advance(state)
    return make_token(TOKEN_EOF, "", state.line, state.column)
end_function

function get_next_token(state)
    if state.eof_reached == 1 then
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    state = skip_whitespace_and_comments(state)
    if is_eof(state) == 1 then
        state.eof_reached = 1
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    String ch = current_char(state)
    if is_digit(ch) == 1 then return read_number(state) end_if
    if ch == "\"" then return read_string(state, "\"") end_if
    if ch == "'" then return read_string(state, "'") end_if
    if is_alpha(ch) == 1 then return read_identifier(state) end_if
    return read_operator(state)
end_function

function tokenize(source_code)
    LexerState state
    state = lexer_state_create(source_code)
    list tokens = list()
    while state.eof_reached == 0
        Token token
        token = get_next_token(state)
        mlp_list_add(tokens, token)
        if token.type == TOKEN_EOF then break end_if
    end
    return tokens
end_function

-- =============================================================================
-- UTILITY: Token to String (for debugging)
-- =============================================================================

function token_type_name(type)
    if type == TOKEN_EOF then return "EOF" end_if
    if type == TOKEN_IDENTIFIER then return "IDENTIFIER" end_if
    if type == TOKEN_NUMBER then return "NUMBER" end_if
    if type == TOKEN_STRING then return "STRING" end_if
    if type == TOKEN_FUNCTION then return "FUNCTION" end_if
    return "UNKNOWN"
end_function
-- END IMPORT: lexer.mlp
-- BEGIN IMPORT: parser.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Parser Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 parser.mlp (661 → <500 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- BEGIN IMPORT: lexer.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Lexer Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 lexer.mlp (635 → ~450 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- =============================================================================
-- TOKEN TYPES
-- =============================================================================

Numeric TOKEN_EOF = 0
Numeric TOKEN_IDENTIFIER = 1
Numeric TOKEN_NUMBER = 2
Numeric TOKEN_STRING = 3
Numeric TOKEN_INTERPOLATED_STRING = 4

-- Keywords (10-26)
Numeric TOKEN_FUNCTION = 10
Numeric TOKEN_END_FUNCTION = 11
Numeric TOKEN_STRUCT = 12
Numeric TOKEN_END_STRUCT = 13
Numeric TOKEN_IF = 14
Numeric TOKEN_THEN = 15
Numeric TOKEN_ELSE = 16
Numeric TOKEN_END_IF = 17
Numeric TOKEN_WHILE = 18
Numeric TOKEN_END = 19
Numeric TOKEN_RETURN = 20
Numeric TOKEN_IMPORT = 21
Numeric TOKEN_AS = 22
Numeric TOKEN_BREAK = 23
Numeric TOKEN_CONTINUE = 24
Numeric TOKEN_MODULE = 25
Numeric TOKEN_ENUM = 26

-- Types (30-34)
Numeric TOKEN_TYPE_STRING = 30
Numeric TOKEN_TYPE_NUMERIC = 31
Numeric TOKEN_TYPE_LIST = 32
Numeric TOKEN_TYPE_I32 = 33
Numeric TOKEN_TYPE_F64 = 34

-- Operators (40-54)
Numeric TOKEN_PLUS = 40
Numeric TOKEN_MINUS = 41
Numeric TOKEN_STAR = 42
Numeric TOKEN_DIV = 43
Numeric TOKEN_MOD = 44
Numeric TOKEN_ASSIGN = 45
Numeric TOKEN_EQ = 46
Numeric TOKEN_NEQ = 47
Numeric TOKEN_LT = 48
Numeric TOKEN_GT = 49
Numeric TOKEN_LTE = 50
Numeric TOKEN_GTE = 51
Numeric TOKEN_AND = 52
Numeric TOKEN_OR = 53
Numeric TOKEN_NOT = 54

-- Delimiters (60-67)
Numeric TOKEN_LEFT_PAREN = 60
Numeric TOKEN_RIGHT_PAREN = 61
Numeric TOKEN_LEFT_BRACKET = 62
Numeric TOKEN_RIGHT_BRACKET = 63
Numeric TOKEN_COMMA = 64
Numeric TOKEN_SEMICOLON = 65
Numeric TOKEN_DOT = 66
Numeric TOKEN_COLON = 67

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct Token then
    Numeric type
    String value
    Numeric line
    Numeric column
    list interpolation_parts
end_struct

struct LexerState then
    String source_code
    Numeric position
    Numeric length
    Numeric line
    Numeric column
    Numeric eof_reached
end_struct

-- =============================================================================
-- FACTORY & STATE MANAGEMENT
-- =============================================================================

function make_token(token_type, value, line, column)
    Token token
    token.type = token_type
    token.value = value
    token.line = line
    token.column = column
    token.interpolation_parts = list()
    return token
end_function

function lexer_state_create(source_code)
    LexerState state
    state.source_code = source_code
    state.position = 0
    state.length = string_length(source_code)
    state.line = 1
    state.column = 1
    state.eof_reached = 0
    return state
end_function

-- =============================================================================
-- CHARACTER HELPERS & CLASSIFICATION
-- =============================================================================

function char_at(state, offset)
    Numeric pos = state.position + offset
    if pos >= state.length then return "" end_if
    return string_substring(state.source_code, pos, 1)
end_function

function current_char(state)
    return char_at(state, 0)
end_function

function peek_char(state, offset)
    return char_at(state, offset)
end_function

function is_eof(state)
    if state.position >= state.length then return 1 end_if
    return 0
end_function

function advance(state)
    if is_eof(state) == 1 then return state end_if
    String ch = current_char(state)
    if ch == "\n" then
        state.line = state.line + 1
        state.column = 1
    else
        state.column = state.column + 1
    end_if
    state.position = state.position + 1
    return state
end_function

function is_digit(ch)
    if ch >= "0" then if ch <= "9" then return 1 end_if end_if
    return 0
end_function

function is_alpha(ch)
    if ch >= "a" then if ch <= "z" then return 1 end_if end_if
    if ch >= "A" then if ch <= "Z" then return 1 end_if end_if
    if ch == "_" then return 1 end_if
    return 0
end_function

function is_alnum(ch)
    if is_alpha(ch) == 1 then return 1 end_if
    if is_digit(ch) == 1 then return 1 end_if
    return 0
end_function

function is_whitespace(ch)
    if ch == " " then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- =============================================================================
-- WHITESPACE, COMMENTS & NUMBER/STRING READING
-- =============================================================================

function skip_whitespace(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_whitespace(ch) == 0 then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_line_comment(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == "\n" then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_whitespace_and_comments(state)
    while is_eof(state) == 0
        state = skip_whitespace(state)
        if is_eof(state) == 1 then break end_if
        String ch = current_char(state)
        String next = peek_char(state, 1)
        if ch == "-" then
            if next == "-" then
                state = skip_line_comment(state)
            else
                break
            end_if
        else
            break
        end_if
    end
    return state
end_function

function read_number(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_digit(ch) == 0 then
            if ch == "," then
                state = advance(state)
                continue
            end_if
            break
        end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    value = string_replace(value, ",", ".")
    Token token
    token = make_token(TOKEN_NUMBER, value, state.line, state.column)
    return token
end_function

function read_string(state, delimiter)
    state = advance(state)
    Numeric start = state.position
    list parts = list()
    String current_part = ""
    
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == delimiter then
            if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
            state = advance(state)
            break
        end_if
        if ch == "{" then
            if string_length(current_part) > 0 then
                mlp_list_add(parts, current_part)
                current_part = ""
            end_if
            state = advance(state)
            Numeric var_start = state.position
            while is_eof(state) == 0
                String vch = current_char(state)
                if vch == "}" then break end_if
                state = advance(state)
            end
            Numeric var_len = state.position - var_start
            String var_name = string_substring(state.source_code, var_start, var_len)
            mlp_list_add(parts, "{" + var_name + "}")
            state = advance(state)
        else
            current_part = current_part + ch
            state = advance(state)
        end_if
    end
    if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
    Numeric part_count = mlp_list_length(parts)
    if part_count > 1 then
        Token token
        token = make_token(TOKEN_INTERPOLATED_STRING, "", state.line, state.column)
        token.interpolation_parts = parts
        return token
    end_if
    if part_count == 1 then
        String final_value = mlp_list_get(parts, 0)
        return make_token(TOKEN_STRING, final_value, state.line, state.column)
    end_if
    return make_token(TOKEN_STRING, "", state.line, state.column)
end_function

-- =============================================================================
-- IDENTIFIER, OPERATOR READING & MAIN TOKENIZER
-- =============================================================================

function keyword_type(value)
    if value == "function" then return TOKEN_FUNCTION end_if
    if value == "end_function" then return TOKEN_END_FUNCTION end_if
    if value == "struct" then return TOKEN_STRUCT end_if
    if value == "end_struct" then return TOKEN_END_STRUCT end_if
    if value == "if" then return TOKEN_IF end_if
    if value == "then" then return TOKEN_THEN end_if
    if value == "else" then return TOKEN_ELSE end_if
    if value == "end_if" then return TOKEN_END_IF end_if
    if value == "while" then return TOKEN_WHILE end_if
    if value == "end" then return TOKEN_END end_if
    if value == "return" then return TOKEN_RETURN end_if
    if value == "import" then return TOKEN_IMPORT end_if
    if value == "as" then return TOKEN_AS end_if
    if value == "break" then return TOKEN_BREAK end_if
    if value == "continue" then return TOKEN_CONTINUE end_if
    if value == "module" then return TOKEN_MODULE end_if
    if value == "enum" then return TOKEN_ENUM end_if
    if value == "String" then return TOKEN_TYPE_STRING end_if
    if value == "Numeric" then return TOKEN_TYPE_NUMERIC end_if
    if value == "list" then return TOKEN_TYPE_LIST end_if
    if value == "i32" then return TOKEN_TYPE_I32 end_if
    if value == "f64" then return TOKEN_TYPE_F64 end_if
    return TOKEN_IDENTIFIER
end_function

function read_identifier(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_alnum(ch) == 0 then break end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    Numeric type = keyword_type(value)
    Token token
    token = make_token(type, value, state.line, state.column)
    return token
end_function

function read_operator(state)
    String ch = current_char(state)
    String next = peek_char(state, 1)
    
    -- Two-character operators
    if ch == "=" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_EQ, "==", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_ASSIGN, "=", state.line, state.column)
    end_if
    
    if ch == "!" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_NEQ, "!=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_NOT, "!", state.line, state.column)
    end_if
    
    if ch == "<" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_LTE, "<=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_LT, "<", state.line, state.column)
    end_if
    
    if ch == ">" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_GTE, ">=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_GT, ">", state.line, state.column)
    end_if
    
    if ch == "&" then
        if next == "&" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_AND, "&&", state.line, state.column)
        end_if
    end_if
    
    if ch == "|" then
        if next == "|" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_OR, "||", state.line, state.column)
        end_if
    end_if
    
    -- Single-character operators
    if ch == "+" then state = advance(state)
        return make_token(TOKEN_PLUS, "+", state.line, state.column) end_if
    if ch == "-" then state = advance(state)
        return make_token(TOKEN_MINUS, "-", state.line, state.column) end_if
    if ch == "*" then state = advance(state)
        return make_token(TOKEN_STAR, "*", state.line, state.column) end_if
    if ch == "/" then state = advance(state)
        return make_token(TOKEN_DIV, "/", state.line, state.column) end_if
    if ch == "%" then state = advance(state)
        return make_token(TOKEN_MOD, "%", state.line, state.column) end_if
    
    -- Delimiters
    if ch == "(" then state = advance(state)
        return make_token(TOKEN_LEFT_PAREN, "(", state.line, state.column) end_if
    if ch == ")" then state = advance(state)
        return make_token(TOKEN_RIGHT_PAREN, ")", state.line, state.column) end_if
    if ch == "[" then state = advance(state)
        return make_token(TOKEN_LEFT_BRACKET, "[", state.line, state.column) end_if
    if ch == "]" then state = advance(state)
        return make_token(TOKEN_RIGHT_BRACKET, "]", state.line, state.column) end_if
    if ch == "," then state = advance(state)
        return make_token(TOKEN_COMMA, ",", state.line, state.column) end_if
    if ch == ";" then state = advance(state)
        return make_token(TOKEN_SEMICOLON, ";", state.line, state.column) end_if
    if ch == "." then state = advance(state)
        return make_token(TOKEN_DOT, ".", state.line, state.column) end_if
    if ch == ":" then state = advance(state)
        return make_token(TOKEN_COLON, ":", state.line, state.column) end_if
    
    -- Unknown character
    state = advance(state)
    return make_token(TOKEN_EOF, "", state.line, state.column)
end_function

function get_next_token(state)
    if state.eof_reached == 1 then
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    state = skip_whitespace_and_comments(state)
    if is_eof(state) == 1 then
        state.eof_reached = 1
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    String ch = current_char(state)
    if is_digit(ch) == 1 then return read_number(state) end_if
    if ch == "\"" then return read_string(state, "\"") end_if
    if ch == "'" then return read_string(state, "'") end_if
    if is_alpha(ch) == 1 then return read_identifier(state) end_if
    return read_operator(state)
end_function

function tokenize(source_code)
    LexerState state
    state = lexer_state_create(source_code)
    list tokens = list()
    while state.eof_reached == 0
        Token token
        token = get_next_token(state)
        mlp_list_add(tokens, token)
        if token.type == TOKEN_EOF then break end_if
    end
    return tokens
end_function

-- =============================================================================
-- UTILITY: Token to String (for debugging)
-- =============================================================================

function token_type_name(type)
    if type == TOKEN_EOF then return "EOF" end_if
    if type == TOKEN_IDENTIFIER then return "IDENTIFIER" end_if
    if type == TOKEN_NUMBER then return "NUMBER" end_if
    if type == TOKEN_STRING then return "STRING" end_if
    if type == TOKEN_FUNCTION then return "FUNCTION" end_if
    return "UNKNOWN"
end_function
-- END IMPORT: lexer.mlp

-- =============================================================================
-- AST NODE TYPES
-- =============================================================================

Numeric AST_PROGRAM = 0
Numeric AST_FUNCTION = 1
Numeric AST_STRUCT = 2
Numeric AST_VARIABLE_DECL = 3
Numeric AST_ASSIGNMENT = 4
Numeric AST_IF_STMT = 5
Numeric AST_WHILE_STMT = 6
Numeric AST_RETURN_STMT = 7
Numeric AST_BLOCK = 8
Numeric AST_BINARY_OP = 9
Numeric AST_UNARY_OP = 10
Numeric AST_CALL = 11
Numeric AST_IDENTIFIER = 12
Numeric AST_NUMBER = 13
Numeric AST_STRING = 14
Numeric AST_IMPORT = 15
Numeric AST_PRINT = 16

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct ASTNode then
    Numeric node_type
    String value
    list children
    Numeric line
    Numeric column
end_struct

struct ParserState then
    list tokens
    Numeric position
    Numeric scope_level
end_struct

-- =============================================================================
-- FACTORY FUNCTIONS
-- =============================================================================

function make_ast_node(node_type, value, line, column)
    ASTNode node
    node.node_type = node_type
    node.value = value
    node.children = list()
    node.line = line
    node.column = column
    return node
end_function

function make_parser_state(tokens)
    ParserState state
    state.tokens = tokens
    state.position = 0
    state.scope_level = 0
    return state
end_function

-- =============================================================================
-- TOKEN NAVIGATION
-- =============================================================================

function current_token(state)
    Numeric pos = state.position
    Numeric length = mlp_list_length(state.tokens)
    if pos >= length then
        Token eof_token = make_token(TOKEN_EOF, "", 0, 0)
        return eof_token
    end_if
    return mlp_list_get(state.tokens, pos)
end_function

function peek_token(state, offset)
    Numeric pos = state.position + offset
    Numeric length = mlp_list_length(state.tokens)
    if pos >= length then
        Token eof_token = make_token(TOKEN_EOF, "", 0, 0)
        return eof_token
    end_if
    return mlp_list_get(state.tokens, pos)
end_function

function advance_token(state)
    state.position = state.position + 1
    return state
end_function

function expect_token(state, expected_type)
    Token token = current_token(state)
    if token.type != expected_type then
        print "Parser error at line " print token.line
    end_if
    return advance_token(state)
end_function

function match_token(state, token_type)
    Token token = current_token(state)
    if token.type == token_type then
        return 1
    end_if
    return 0
end_function

-- =============================================================================
-- PRECEDENCE TABLE
-- =============================================================================

function get_precedence(token_type)
    if token_type == TOKEN_OR then return 10 end_if
    if token_type == TOKEN_AND then return 20 end_if
    if token_type == TOKEN_EQ then return 30 end_if
    if token_type == TOKEN_NEQ then return 30 end_if
    if token_type == TOKEN_LT then return 40 end_if
    if token_type == TOKEN_GT then return 40 end_if
    if token_type == TOKEN_LTE then return 40 end_if
    if token_type == TOKEN_GTE then return 40 end_if
    if token_type == TOKEN_PLUS then return 50 end_if
    if token_type == TOKEN_MINUS then return 50 end_if
    if token_type == TOKEN_STAR then return 60 end_if
    if token_type == TOKEN_DIV then return 60 end_if
    if token_type == TOKEN_MOD then return 60 end_if
    return 0
end_function

-- =============================================================================
-- EXPRESSION PARSING (PRATT STYLE)
-- =============================================================================

function parse_primary(state)
    Token token = current_token(state)
    
    -- Number literal
    if token.type == TOKEN_NUMBER then
        ASTNode node = make_ast_node(AST_NUMBER, token.value, token.line, token.column)
        state = advance_token(state)
        return node
    end_if
    
    -- String literal
    if token.type == TOKEN_STRING then
        ASTNode node = make_ast_node(AST_STRING, token.value, token.line, token.column)
        state = advance_token(state)
        return node
    end_if
    
    -- Identifier or function call
    if token.type == TOKEN_IDENTIFIER then
        ASTNode node = make_ast_node(AST_IDENTIFIER, token.value, token.line, token.column)
        state = advance_token(state)
        
        -- Check for function call
        Token next_token = current_token(state)
        if next_token.type == TOKEN_LEFT_PAREN then
            node.node_type = AST_CALL
            state = advance_token(state)
            
            -- Parse arguments
            if match_token(state, TOKEN_RIGHT_PAREN) == 0 then
                while 1 == 1
                    ASTNode arg = parse_expression(state, 0)
                    mlp_list_add(node.children, arg)
                    
                    Token comma_token = current_token(state)
                    if comma_token.type != TOKEN_COMMA then
                        break
                    end_if
                    state = advance_token(state)
                end
            end_if
            
            state = expect_token(state, TOKEN_RIGHT_PAREN)
        end_if
        
        return node
    end_if
    
    -- Parenthesized expression
    if token.type == TOKEN_LEFT_PAREN then
        state = advance_token(state)
        ASTNode expr = parse_expression(state, 0)
        state = expect_token(state, TOKEN_RIGHT_PAREN)
        return expr
    end_if
    
    -- Unary operators
    if token.type == TOKEN_MINUS then
        ASTNode node = make_ast_node(AST_UNARY_OP, "-", token.line, token.column)
        state = advance_token(state)
        mlp_list_add(node.children, parse_primary(state))
        return node
    end_if
    
    if token.type == TOKEN_NOT then
        ASTNode node = make_ast_node(AST_UNARY_OP, "!", token.line, token.column)
        state = advance_token(state)
        mlp_list_add(node.children, parse_primary(state))
        return node
    end_if
    
    -- Error
    print "Parser error at line " print token.line
    ASTNode error_node = make_ast_node(AST_NUMBER, "0", token.line, token.column)
    return error_node
end_function

function parse_expression(state, min_precedence)
    ASTNode left = parse_primary(state)
    
    while 1 == 1
        Token op_token = current_token(state)
        Numeric op_prec = get_precedence(op_token.type)
        
        if op_prec == 0 then break end_if
        if op_prec < min_precedence then break end_if
        
        String op_value = op_token.value
        Numeric op_line = op_token.line
        Numeric op_col = op_token.column
        state = advance_token(state)
        
        ASTNode right = parse_expression(state, op_prec + 1)
        
        ASTNode binary_node = make_ast_node(AST_BINARY_OP, op_value, op_line, op_col)
        mlp_list_add(binary_node.children, left)
        mlp_list_add(binary_node.children, right)
        
        left = binary_node
    end
    
    return left
end_function

-- =============================================================================
-- STATEMENT PARSING
-- =============================================================================

function parse_import_statement(state)
    Token import_token = current_token(state)
    state = expect_token(state, TOKEN_IMPORT)
    
    Token module_token = current_token(state)
    state = expect_token(state, TOKEN_STRING)
    
    ASTNode node = make_ast_node(AST_IMPORT, module_token.value, import_token.line, import_token.column)
    return node
end_function

function parse_print_statement(state)
    Token print_token = current_token(state)
    state = expect_token(state, TOKEN_PRINT)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_PRINT, "", print_token.line, print_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_return_statement(state)
    Token return_token = current_token(state)
    state = expect_token(state, TOKEN_RETURN)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_RETURN_STMT, "", return_token.line, return_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_variable_declaration(state)
    Token type_token = current_token(state)
    state = advance_token(state)
    
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    
    ASTNode node = make_ast_node(AST_VARIABLE_DECL, name_token.value, type_token.line, type_token.column)
    node.value = type_token.value + ":" + name_token.value
    
    -- Check for assignment
    Token assign_token = current_token(state)
    if assign_token.type == TOKEN_ASSIGN then
        state = advance_token(state)
        ASTNode init_expr = parse_expression(state, 0)
        mlp_list_add(node.children, init_expr)
    end_if
    
    return node
end_function

function parse_assignment(state)
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    state = expect_token(state, TOKEN_ASSIGN)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_ASSIGNMENT, name_token.value, name_token.line, name_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_if_statement(state)
    Token if_token = current_token(state)
    state = expect_token(state, TOKEN_IF)
    
    ASTNode condition = parse_expression(state, 0)
    state = expect_token(state, TOKEN_THEN)
    
    ASTNode then_block = parse_block(state, TOKEN_END_IF)
    
    ASTNode node = make_ast_node(AST_IF_STMT, "", if_token.line, if_token.column)
    mlp_list_add(node.children, condition)
    mlp_list_add(node.children, then_block)
    
    -- Check for else
    Token next_token = current_token(state)
    if next_token.type == TOKEN_ELSE then
        state = advance_token(state)
        ASTNode else_block = parse_block(state, TOKEN_END_IF)
        mlp_list_add(node.children, else_block)
    end_if
    
    state = expect_token(state, TOKEN_END_IF)
    return node
end_function

function parse_while_statement(state)
    Token while_token = current_token(state)
    state = expect_token(state, TOKEN_WHILE)
    
    ASTNode condition = parse_expression(state, 0)
    ASTNode body = parse_block(state, TOKEN_END)
    
    state = expect_token(state, TOKEN_END)
    
    ASTNode node = make_ast_node(AST_WHILE_STMT, "", while_token.line, while_token.column)
    mlp_list_add(node.children, condition)
    mlp_list_add(node.children, body)
    return node
end_function

function parse_function_declaration(state)
    Token func_token = current_token(state)
    state = expect_token(state, TOKEN_FUNCTION)
    
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    
    ASTNode node = make_ast_node(AST_FUNCTION, name_token.value, func_token.line, func_token.column)
    
    state = expect_token(state, TOKEN_LEFT_PAREN)
    
    -- Parse parameters
    if match_token(state, TOKEN_RIGHT_PAREN) == 0 then
        while 1 == 1
            Token param_name = current_token(state)
            state = expect_token(state, TOKEN_IDENTIFIER)
            
            ASTNode param_node = make_ast_node(AST_IDENTIFIER, param_name.value, param_name.line, param_name.column)
            mlp_list_add(node.children, param_node)
            
            Token comma_token = current_token(state)
            if comma_token.type != TOKEN_COMMA then
                break
            end_if
            state = advance_token(state)
        end
    end_if
    
    state = expect_token(state, TOKEN_RIGHT_PAREN)
    
    -- Parse function body
    ASTNode body = parse_block(state, TOKEN_END_FUNCTION)
    mlp_list_add(node.children, body)
    
    state = expect_token(state, TOKEN_END_FUNCTION)
    return node
end_function

function parse_statement(state)
    Token token = current_token(state)
    
    if token.type == TOKEN_IMPORT then
        return parse_import_statement(state)
    end_if
     return parse_import_statement(state) end_if
    if token.type == TOKEN_FUNCTION then return parse_function_declaration(state) end_if
    if token.type == TOKEN_PRINT then return parse_print_statement(state) end_if
    if token.type == TOKEN_RETURN then return parse_return_statement(state) end_if
    if token.type == TOKEN_IF then return parse_if_statement(state) end_if
    if token.type == TOKEN_WHILE then return parse_while_statement(state) end_if
    if token.type == TOKEN_TYPE_NUMERIC then return parse_variable_declaration(state) end_if
    if token.type == TOKEN_TYPE_STRING then return parse_variable_declaration(state) end_if
    if token.type == TOKEN_IDENTIFIER then return parse_assignment(state) end_if
    
    print "Parser error at line "_function

function parse_block(state, end_token_type)
    list statements = list()
    
    while 1 == 1
        Token token = current_token(state)
        
        if token.type == TOKEN_EOF then
            break
        end_if
        
        if token.type == end_token_type then
            break
        end_if
        
        ASTNode stmt = parse_statement(state)
        mlp_list_add(statements, stmt)
    end
    
    Token block_token = current_token(state)
    ASTNode block_node = make_ast_node(AST_BLOCK, "", block_token.line, block_token.column)
    block_node.children = statements
    return block_node
end_function

-- =============================================================================
-- TOP-LEVEL PARSER
-- =============================================================================

function parse(tokens)
    ParserState state = make_parser_state(tokens)
    ASTNode root = parse_block(state, TOKEN_EOF)
    root.node_type = AST_PROGRAM
    return root
end_function

function ast_to_string(node, indent)
    String result = ""
    
    -- Add indentation
    Numeric i = 0
    while i < indent
        result = result + "  "
        i = i + 1
    end
    
    -- Node type
    if node.node_type == AST_PROGRAM then result = result + "PROGRAM" end_if
    if node.node_type == AST_FUNCTION then result = result + "FUNCTION " + node.value end_if
    if node.node_type == AST_VARIABLE_DECL then result = result + "VAR_DECL " + node.value end_if
    if node.node_type == AST_ASSIGNMENT then result = result + "ASSIGN " + node.value end_if
    if node.node_type == AST_IF_STMT then result = result + "IF" end_if
    if node.node_type == AST_WHILE_STMT then result = result + "WHILE" end_if
    if node.node_type == AST_RETURN_STMT then result = result + "RETURN" end_if
    if node.node_type == AST_BLOCK then result = result + "BLOCK" end_if
    if node.node_type == AST_BINARY_OP then result = result + "BINARY_OP " + node.value end_if
    if node.node_type == AST_UNARY_OP then result = result + "UNARY_OP " + node.value end_if
    if node.node_type == AST_CALL then result = result + "CALL " + node.value end_if
    if node.node_type == AST_IDENTIFIER then result = result + "ID " + node.value end_if
    if node.node_type == AST_NUMBER then result = result + "NUM " + node.value end_if
    if node.node_type == AST_STRING then result = result + "STR " + node.value end_if
    if node.node_type == AST_IMPORT then result = result + "IMPORT " + node.value end_if
    if node.node_type == AST_PRINT then result = result + "PRINT" end_if
    
    result = result + "\n"
    
    -- Children
    Numeric child_count = mlp_list_length(node.children)
    Numeric j = 0
    while j < child_count
        ASTNode child = mlp_list_get(node.children, j)
        result = result + ast_to_string(child, indent + 1)
        j = j + 1
    end
    
    return result
end_function
-- END IMPORT: lexer.mlp

-- =============================================================================
-- CODEGEN STATE
-- =============================================================================

struct CodegenState then
    String output
    Numeric indent_level
    Numeric temp_counter
    Numeric label_counter
    list string_literals
end_struct

-- =============================================================================
-- FACTORY FUNCTIONS
-- =============================================================================

function make_codegen_state()
    CodegenState state
    state.output = ""
    state.indent_level = 0
    state.temp_counter = 0
    state.label_counter = 0
    state.string_literals = list()
    return state
end_function

-- =============================================================================
-- HELPER FUNCTIONS
-- =============================================================================

function indent_string(level)
    String result = ""
    Numeric i = 0
    while i < level
        result = result + "    "
        i = i + 1
    end
    return result
end_function

function emit_line(state, line)
    String indented = indent_string(state.indent_level) + line + "\n"
    state.output = state.output + indented
    return state
end_function

function emit_raw(state, text)
    state.output = state.output + text
    return state
end_function

function generate_temp_var(state)
    String temp = "_t" + mlp_numeric_to_string(state.temp_counter)
    state.temp_counter = state.temp_counter + 1
    return temp
end_function

function generate_label(state, prefix)
    String label = prefix + "_" + mlp_numeric_to_string(state.label_counter)
    state.label_counter = state.label_counter + 1
    return label
end_function

function register_string_literal(state, str_value)
    String label = "str_" + mlp_numeric_to_string(mlp_list_length(state.string_literals))
    mlp_list_add(state.string_literals, str_value)
    return label
end_function

-- =============================================================================
-- TYPE CONVERSION
-- =============================================================================

function mlp_type_to_c_type(mlp_type)
    if mlp_string_equals(mlp_type, "Numeric") then
        return "int64_t"
    end_if
    if mlp_string_equals(mlp_type, "String") then
        return "char*"
    end_if
    if mlp_string_equals(mlp_type, "i32") then
        return "int32_t"
    end_if
    if mlp_string_equals(mlp_type, "i64") then
        return "int64_t"
    end_if
    if mlp_string_equals(mlp_type, "f64") then
        return "double"
    end_if
    if mlp_string_equals(mlp_type, "list") then
        return "void*"
    end_if
    return "void*"
end_function

-- =============================================================================
-- EXPRESSION CODEGEN
-- =============================================================================

function codegen_expression(state, node)
    Numeric node_type = node.node_type
    
    -- Literal values
    if node_type == AST_NUMBER then
        return codegen_number(state, node)
    end_if
    
    if node_type == AST_STRING then
        return codegen_string(state, node)
    end_if
    
    if node_type == AST_IDENTIFIER then
        return codegen_identifier(state, node)
    end_if
    
    -- Binary operations
    if node_type == AST_BINARY_OP then
        return codegen_binary_op(state, node)
    end_if
    
    -- Unary operations
    if node_type == AST_UNARY_OP then
        return codegen_unary_op(state, node)
    end_if
    
    -- Function call
    if node_type == AST_CALL then
        return codegen_call(state, node)
    end_if
    
    return state
end_function

function codegen_number(state, node)
    state = emit_raw(state, node.value)
    return state
end_function

function codegen_string(state, node)
    String label = register_string_literal(state, node.value)
    state = emit_raw(state, label)
    return state
end_function

function codegen_identifier(state, node)
    state = emit_raw(state, node.value)
    return state
end_function

function codegen_binary_op(state, node)
    String op = node.value
    ASTNode left = mlp_list_get(node.children, 0)
    ASTNode right = mlp_list_get(node.children, 1)
    
    state = emit_raw(state, "(")
    state = codegen_expression(state, left)
    state = emit_raw(state, " " + op + " ")
    state = codegen_expression(state, right)
    state = emit_raw(state, ")")
    
    return state
end_function

function codegen_unary_op(state, node)
    String op = node.value
    ASTNode operand = mlp_list_get(node.children, 0)
    
    state = emit_raw(state, op)
    state = codegen_expression(state, operand)
    
    return state
end_function

function codegen_call(state, node)
    String func_name = node.value
    list args = node.children
    
    state = emit_raw(state, func_name + "(")
    
    Numeric i = 0
    Numeric argc = mlp_list_length(args)
    while i < argc
        ASTNode arg = mlp_list_get(args, i)
        state = codegen_expression(state, arg)
        
        if i < argc - 1 then
            state = emit_raw(state, ", ")
        end_if
        
        i = i + 1
    end
    
    state = emit_raw(state, ")")
    return state
end_function

-- =============================================================================
-- STATEMENT CODEGEN
-- =============================================================================

function codegen_statement(state, node)
    Numeric node_type = node.node_type
    
    if node_type == AST_VARIABLE_DECL then
        return codegen_variable_decl(state, node)
    end_if
    
    if node_type == AST_ASSIGNMENT then
        return codegen_assignment(state, node)
    end_if
    
    if node_type == AST_IF_STMT then
        return codegen_if_statement(state, node)
    end_if
    
    if node_type == AST_WHILE_STMT then
        return codegen_while_statement(state, node)
    end_if
    
    if node_type == AST_RETURN_STMT then
        return codegen_return_statement(state, node)
    end_if
    
    if node_type == AST_PRINT then
        return codegen_print_statement(state, node)
    end_if
    
    if node_type == AST_CALL then
        state = emit_line(state, "")
        state = codegen_expression(state, node)
        state = emit_raw(state, ";\n")
        return state
    end_if
    
    if node_type == AST_BLOCK then
        return codegen_block(state, node)
    end_if
    
    return state
end_function

function codegen_variable_decl(state, node)
    String var_name = node.value
    ASTNode init_node = mlp_list_get(node.children, 0)
    
    state = emit_line(state, "int64_t " + var_name + " = ")
    state = codegen_expression(state, init_node)
    state = emit_raw(state, ";\n")
    
    return state
end_function

function codegen_assignment(state, node)
    String var_name = node.value
    ASTNode value_node = mlp_list_get(node.children, 0)
    
    state = emit_line(state, var_name + " = ")
    state = codegen_expression(state, value_node)
    state = emit_raw(state, ";\n")
    
    return state
end_function

function codegen_if_statement(state, node)
    ASTNode condition = mlp_list_get(node.children, 0)
    ASTNode then_block = mlp_list_get(node.children, 1)
    
    state = emit_line(state, "if (")
    state = codegen_expression(state, condition)
    state = emit_raw(state, ") {\n")
    
    state.indent_level = state.indent_level + 1
    state = codegen_statement(state, then_block)
    state.indent_level = state.indent_level - 1
    
    -- Check for else block
    Numeric child_count = mlp_list_length(node.children)
    if child_count > 2 then
        ASTNode else_block = mlp_list_get(node.children, 2)
        state = emit_line(state, "} else {\n")
        
        state.indent_level = state.indent_level + 1
        state = codegen_statement(state, else_block)
        state.indent_level = state.indent_level - 1
    end_if
    
    state = emit_line(state, "}\n")
    return state
end_function

function codegen_while_statement(state, node)
    ASTNode condition = mlp_list_get(node.children, 0)
    ASTNode body = mlp_list_get(node.children, 1)
    
    state = emit_line(state, "while (")
    state = codegen_expression(state, condition)
    state = emit_raw(state, ") {\n")
    
    state.indent_level = state.indent_level + 1
    state = codegen_statement(state, body)
    state.indent_level = state.indent_level - 1
    
    state = emit_line(state, "}\n")
    return state
end_function

function codegen_return_statement(state, node)
    Numeric child_count = mlp_list_length(node.children)
    
    if child_count > 0 then
        ASTNode return_value = mlp_list_get(node.children, 0)
        state = emit_line(state, "return ")
        state = codegen_expression(state, return_value)
        state = emit_raw(state, ";\n")
    else
        state = emit_line(state, "return;\n")
    end_if
    
    return state
end_function

function codegen_print_statement(state, node)
    ASTNode arg = mlp_list_get(node.children, 0)
    
    state = emit_line(state, "printf(\"%lld\\n\", (long long)")
    state = codegen_expression(state, arg)
    state = emit_raw(state, ");\n")
    
    return state
end_function

function codegen_block(state, node)
    Numeric i = 0
    Numeric stmt_count = mlp_list_length(node.children)
    
    while i < stmt_count
        ASTNode stmt = mlp_list_get(node.children, i)
        state = codegen_statement(state, stmt)
        i = i + 1
    end
    
    return state
end_function

-- =============================================================================
-- FUNCTION & STRUCT CODEGEN
-- =============================================================================

function codegen_function(state, node)
    String func_name = node.value
    list children = node.children
    
    -- Get parameters (first n-1 children are params, last is body)
    Numeric child_count = mlp_list_length(children)
    Numeric param_count = child_count - 1
    
    -- Function signature
    state = emit_line(state, "int64_t " + func_name + "(")
    
    -- Parameters
    Numeric i = 0
    while i < param_count
        ASTNode param = mlp_list_get(children, i)
        state = emit_raw(state, "int64_t " + param.value)
        
        if i < param_count - 1 then
            state = emit_raw(state, ", ")
        end_if
        
        i = i + 1
    end
    
    state = emit_raw(state, ") {\n")
    
    -- Function body
    state.indent_level = state.indent_level + 1
    ASTNode body = mlp_list_get(children, param_count)
    state = codegen_statement(state, body)
    state.indent_level = state.indent_level - 1
    
    state = emit_line(state, "}\n")
    return state
end_function

function codegen_struct(state, node)
    String struct_name = node.value
    list fields = node.children
    
    state = emit_line(state, "typedef struct {\n")
    state.indent_level = state.indent_level + 1
    
    Numeric i = 0
    Numeric field_count = mlp_list_length(fields)
    while i < field_count
        ASTNode field = mlp_list_get(fields, i)
        state = emit_line(state, "int64_t " + field.value + ";\n")
        i = i + 1
    end
    
    state.indent_level = state.indent_level - 1
    state = emit_line(state, "} " + struct_name + ";\n")
    
    return state
end_function

function codegen_import(state, node)
    String module_name = node.value
    state = emit_line(state, "// import: " + module_name + "\n")
    return state
end_function

-- =============================================================================
-- TOP-LEVEL CODEGEN
-- =============================================================================

function codegen_program(state, node)
    list children = node.children
    
    -- Generate C header
    state = emit_line(state, "// Generated by MLP Stage2 Compiler\n")
    state = emit_line(state, "#include <stdio.h>\n")
    state = emit_line(state, "#include <stdint.h>\n")
    state = emit_line(state, "#include <stdlib.h>\n")
    state = emit_line(state, "\n")
    
    -- Process all top-level declarations
    Numeric i = 0
    Numeric decl_count = mlp_list_length(children)
    
    while i < decl_count
        ASTNode child = mlp_list_get(children, i)
        Numeric child_type = child.node_type
        
        if child_type == AST_IMPORT then
            state = codegen_import(state, child)
        end_if
        
        if child_type == AST_STRUCT then
            state = codegen_struct(state, child)
        end_if
        
        if child_type == AST_FUNCTION then
            state = codegen_function(state, child)
        end_if
        
        i = i + 1
    end
    
    -- Generate string literals section
    state = codegen_string_literals(state)
    
    return state
end_function

function codegen_string_literals(state)
    Numeric lit_count = mlp_list_length(state.string_literals)
    
    if lit_count > 0 then
        state = emit_line(state, "// String literals\n")
        
        Numeric i = 0
        while i < lit_count
            String value = mlp_list_get(state.string_literals, i)
            String label = "str_" + mlp_numeric_to_string(i)
            state = emit_line(state, "static const char " + label + "[] = \"" + value + "\";\n")
            i = i + 1
        end
        
        state = emit_line(state, "\n")
    end_if
    
    return state
end_function

-- =============================================================================
-- MAIN CODEGEN ENTRY POINT
-- =============================================================================

function codegen(ast_root)
    CodegenState state = make_codegen_state()
    
    if ast_root.node_type == AST_PROGRAM then
        state = codegen_program(state, ast_root)
    end_if
    
    return state.output
end_function

function codegen_ast_to_c(ast_root)
    return codegen(ast_root)
end_function
-- END IMPORT: lexer.mlp
-- BEGIN IMPORT: codegen_advanced.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Codegen Advanced Module - Stage2 Self-Hosting Compiler
-- Advanced features: Generics, Closures, Pattern Matching
-- Optimized from p7 codegen_lambda.mlp + codegen_structures.mlp
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC
-- Target: C code generation (GCC backend)

-- BEGIN IMPORT: lexer.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Lexer Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 lexer.mlp (635 → ~450 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- =============================================================================
-- TOKEN TYPES
-- =============================================================================

Numeric TOKEN_EOF = 0
Numeric TOKEN_IDENTIFIER = 1
Numeric TOKEN_NUMBER = 2
Numeric TOKEN_STRING = 3
Numeric TOKEN_INTERPOLATED_STRING = 4

-- Keywords (10-26)
Numeric TOKEN_FUNCTION = 10
Numeric TOKEN_END_FUNCTION = 11
Numeric TOKEN_STRUCT = 12
Numeric TOKEN_END_STRUCT = 13
Numeric TOKEN_IF = 14
Numeric TOKEN_THEN = 15
Numeric TOKEN_ELSE = 16
Numeric TOKEN_END_IF = 17
Numeric TOKEN_WHILE = 18
Numeric TOKEN_END = 19
Numeric TOKEN_RETURN = 20
Numeric TOKEN_IMPORT = 21
Numeric TOKEN_AS = 22
Numeric TOKEN_BREAK = 23
Numeric TOKEN_CONTINUE = 24
Numeric TOKEN_MODULE = 25
Numeric TOKEN_ENUM = 26

-- Types (30-34)
Numeric TOKEN_TYPE_STRING = 30
Numeric TOKEN_TYPE_NUMERIC = 31
Numeric TOKEN_TYPE_LIST = 32
Numeric TOKEN_TYPE_I32 = 33
Numeric TOKEN_TYPE_F64 = 34

-- Operators (40-54)
Numeric TOKEN_PLUS = 40
Numeric TOKEN_MINUS = 41
Numeric TOKEN_STAR = 42
Numeric TOKEN_DIV = 43
Numeric TOKEN_MOD = 44
Numeric TOKEN_ASSIGN = 45
Numeric TOKEN_EQ = 46
Numeric TOKEN_NEQ = 47
Numeric TOKEN_LT = 48
Numeric TOKEN_GT = 49
Numeric TOKEN_LTE = 50
Numeric TOKEN_GTE = 51
Numeric TOKEN_AND = 52
Numeric TOKEN_OR = 53
Numeric TOKEN_NOT = 54

-- Delimiters (60-67)
Numeric TOKEN_LEFT_PAREN = 60
Numeric TOKEN_RIGHT_PAREN = 61
Numeric TOKEN_LEFT_BRACKET = 62
Numeric TOKEN_RIGHT_BRACKET = 63
Numeric TOKEN_COMMA = 64
Numeric TOKEN_SEMICOLON = 65
Numeric TOKEN_DOT = 66
Numeric TOKEN_COLON = 67

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct Token then
    Numeric type
    String value
    Numeric line
    Numeric column
    list interpolation_parts
end_struct

struct LexerState then
    String source_code
    Numeric position
    Numeric length
    Numeric line
    Numeric column
    Numeric eof_reached
end_struct

-- =============================================================================
-- FACTORY & STATE MANAGEMENT
-- =============================================================================

function make_token(token_type, value, line, column)
    Token token
    token.type = token_type
    token.value = value
    token.line = line
    token.column = column
    token.interpolation_parts = list()
    return token
end_function

function lexer_state_create(source_code)
    LexerState state
    state.source_code = source_code
    state.position = 0
    state.length = string_length(source_code)
    state.line = 1
    state.column = 1
    state.eof_reached = 0
    return state
end_function

-- =============================================================================
-- CHARACTER HELPERS & CLASSIFICATION
-- =============================================================================

function char_at(state, offset)
    Numeric pos = state.position + offset
    if pos >= state.length then return "" end_if
    return string_substring(state.source_code, pos, 1)
end_function

function current_char(state)
    return char_at(state, 0)
end_function

function peek_char(state, offset)
    return char_at(state, offset)
end_function

function is_eof(state)
    if state.position >= state.length then return 1 end_if
    return 0
end_function

function advance(state)
    if is_eof(state) == 1 then return state end_if
    String ch = current_char(state)
    if ch == "\n" then
        state.line = state.line + 1
        state.column = 1
    else
        state.column = state.column + 1
    end_if
    state.position = state.position + 1
    return state
end_function

function is_digit(ch)
    if ch >= "0" then if ch <= "9" then return 1 end_if end_if
    return 0
end_function

function is_alpha(ch)
    if ch >= "a" then if ch <= "z" then return 1 end_if end_if
    if ch >= "A" then if ch <= "Z" then return 1 end_if end_if
    if ch == "_" then return 1 end_if
    return 0
end_function

function is_alnum(ch)
    if is_alpha(ch) == 1 then return 1 end_if
    if is_digit(ch) == 1 then return 1 end_if
    return 0
end_function

function is_whitespace(ch)
    if ch == " " then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- =============================================================================
-- WHITESPACE, COMMENTS & NUMBER/STRING READING
-- =============================================================================

function skip_whitespace(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_whitespace(ch) == 0 then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_line_comment(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == "\n" then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_whitespace_and_comments(state)
    while is_eof(state) == 0
        state = skip_whitespace(state)
        if is_eof(state) == 1 then break end_if
        String ch = current_char(state)
        String next = peek_char(state, 1)
        if ch == "-" then
            if next == "-" then
                state = skip_line_comment(state)
            else
                break
            end_if
        else
            break
        end_if
    end
    return state
end_function

function read_number(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_digit(ch) == 0 then
            if ch == "," then
                state = advance(state)
                continue
            end_if
            break
        end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    value = string_replace(value, ",", ".")
    Token token
    token = make_token(TOKEN_NUMBER, value, state.line, state.column)
    return token
end_function

function read_string(state, delimiter)
    state = advance(state)
    Numeric start = state.position
    list parts = list()
    String current_part = ""
    
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == delimiter then
            if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
            state = advance(state)
            break
        end_if
        if ch == "{" then
            if string_length(current_part) > 0 then
                mlp_list_add(parts, current_part)
                current_part = ""
            end_if
            state = advance(state)
            Numeric var_start = state.position
            while is_eof(state) == 0
                String vch = current_char(state)
                if vch == "}" then break end_if
                state = advance(state)
            end
            Numeric var_len = state.position - var_start
            String var_name = string_substring(state.source_code, var_start, var_len)
            mlp_list_add(parts, "{" + var_name + "}")
            state = advance(state)
        else
            current_part = current_part + ch
            state = advance(state)
        end_if
    end
    if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
    Numeric part_count = mlp_list_length(parts)
    if part_count > 1 then
        Token token
        token = make_token(TOKEN_INTERPOLATED_STRING, "", state.line, state.column)
        token.interpolation_parts = parts
        return token
    end_if
    if part_count == 1 then
        String final_value = mlp_list_get(parts, 0)
        return make_token(TOKEN_STRING, final_value, state.line, state.column)
    end_if
    return make_token(TOKEN_STRING, "", state.line, state.column)
end_function

-- =============================================================================
-- IDENTIFIER, OPERATOR READING & MAIN TOKENIZER
-- =============================================================================

function keyword_type(value)
    if value == "function" then return TOKEN_FUNCTION end_if
    if value == "end_function" then return TOKEN_END_FUNCTION end_if
    if value == "struct" then return TOKEN_STRUCT end_if
    if value == "end_struct" then return TOKEN_END_STRUCT end_if
    if value == "if" then return TOKEN_IF end_if
    if value == "then" then return TOKEN_THEN end_if
    if value == "else" then return TOKEN_ELSE end_if
    if value == "end_if" then return TOKEN_END_IF end_if
    if value == "while" then return TOKEN_WHILE end_if
    if value == "end" then return TOKEN_END end_if
    if value == "return" then return TOKEN_RETURN end_if
    if value == "import" then return TOKEN_IMPORT end_if
    if value == "as" then return TOKEN_AS end_if
    if value == "break" then return TOKEN_BREAK end_if
    if value == "continue" then return TOKEN_CONTINUE end_if
    if value == "module" then return TOKEN_MODULE end_if
    if value == "enum" then return TOKEN_ENUM end_if
    if value == "String" then return TOKEN_TYPE_STRING end_if
    if value == "Numeric" then return TOKEN_TYPE_NUMERIC end_if
    if value == "list" then return TOKEN_TYPE_LIST end_if
    if value == "i32" then return TOKEN_TYPE_I32 end_if
    if value == "f64" then return TOKEN_TYPE_F64 end_if
    return TOKEN_IDENTIFIER
end_function

function read_identifier(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_alnum(ch) == 0 then break end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    Numeric type = keyword_type(value)
    Token token
    token = make_token(type, value, state.line, state.column)
    return token
end_function

function read_operator(state)
    String ch = current_char(state)
    String next = peek_char(state, 1)
    
    -- Two-character operators
    if ch == "=" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_EQ, "==", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_ASSIGN, "=", state.line, state.column)
    end_if
    
    if ch == "!" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_NEQ, "!=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_NOT, "!", state.line, state.column)
    end_if
    
    if ch == "<" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_LTE, "<=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_LT, "<", state.line, state.column)
    end_if
    
    if ch == ">" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_GTE, ">=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_GT, ">", state.line, state.column)
    end_if
    
    if ch == "&" then
        if next == "&" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_AND, "&&", state.line, state.column)
        end_if
    end_if
    
    if ch == "|" then
        if next == "|" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_OR, "||", state.line, state.column)
        end_if
    end_if
    
    -- Single-character operators
    if ch == "+" then state = advance(state)
        return make_token(TOKEN_PLUS, "+", state.line, state.column) end_if
    if ch == "-" then state = advance(state)
        return make_token(TOKEN_MINUS, "-", state.line, state.column) end_if
    if ch == "*" then state = advance(state)
        return make_token(TOKEN_STAR, "*", state.line, state.column) end_if
    if ch == "/" then state = advance(state)
        return make_token(TOKEN_DIV, "/", state.line, state.column) end_if
    if ch == "%" then state = advance(state)
        return make_token(TOKEN_MOD, "%", state.line, state.column) end_if
    
    -- Delimiters
    if ch == "(" then state = advance(state)
        return make_token(TOKEN_LEFT_PAREN, "(", state.line, state.column) end_if
    if ch == ")" then state = advance(state)
        return make_token(TOKEN_RIGHT_PAREN, ")", state.line, state.column) end_if
    if ch == "[" then state = advance(state)
        return make_token(TOKEN_LEFT_BRACKET, "[", state.line, state.column) end_if
    if ch == "]" then state = advance(state)
        return make_token(TOKEN_RIGHT_BRACKET, "]", state.line, state.column) end_if
    if ch == "," then state = advance(state)
        return make_token(TOKEN_COMMA, ",", state.line, state.column) end_if
    if ch == ";" then state = advance(state)
        return make_token(TOKEN_SEMICOLON, ";", state.line, state.column) end_if
    if ch == "." then state = advance(state)
        return make_token(TOKEN_DOT, ".", state.line, state.column) end_if
    if ch == ":" then state = advance(state)
        return make_token(TOKEN_COLON, ":", state.line, state.column) end_if
    
    -- Unknown character
    state = advance(state)
    return make_token(TOKEN_EOF, "", state.line, state.column)
end_function

function get_next_token(state)
    if state.eof_reached == 1 then
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    state = skip_whitespace_and_comments(state)
    if is_eof(state) == 1 then
        state.eof_reached = 1
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    String ch = current_char(state)
    if is_digit(ch) == 1 then return read_number(state) end_if
    if ch == "\"" then return read_string(state, "\"") end_if
    if ch == "'" then return read_string(state, "'") end_if
    if is_alpha(ch) == 1 then return read_identifier(state) end_if
    return read_operator(state)
end_function

function tokenize(source_code)
    LexerState state
    state = lexer_state_create(source_code)
    list tokens = list()
    while state.eof_reached == 0
        Token token
        token = get_next_token(state)
        mlp_list_add(tokens, token)
        if token.type == TOKEN_EOF then break end_if
    end
    return tokens
end_function

-- =============================================================================
-- UTILITY: Token to String (for debugging)
-- =============================================================================

function token_type_name(type)
    if type == TOKEN_EOF then return "EOF" end_if
    if type == TOKEN_IDENTIFIER then return "IDENTIFIER" end_if
    if type == TOKEN_NUMBER then return "NUMBER" end_if
    if type == TOKEN_STRING then return "STRING" end_if
    if type == TOKEN_FUNCTION then return "FUNCTION" end_if
    return "UNKNOWN"
end_function
-- END IMPORT: lexer.mlp
-- BEGIN IMPORT: parser.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Parser Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 parser.mlp (661 → <500 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- BEGIN IMPORT: lexer.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Lexer Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 lexer.mlp (635 → ~450 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- =============================================================================
-- TOKEN TYPES
-- =============================================================================

Numeric TOKEN_EOF = 0
Numeric TOKEN_IDENTIFIER = 1
Numeric TOKEN_NUMBER = 2
Numeric TOKEN_STRING = 3
Numeric TOKEN_INTERPOLATED_STRING = 4

-- Keywords (10-26)
Numeric TOKEN_FUNCTION = 10
Numeric TOKEN_END_FUNCTION = 11
Numeric TOKEN_STRUCT = 12
Numeric TOKEN_END_STRUCT = 13
Numeric TOKEN_IF = 14
Numeric TOKEN_THEN = 15
Numeric TOKEN_ELSE = 16
Numeric TOKEN_END_IF = 17
Numeric TOKEN_WHILE = 18
Numeric TOKEN_END = 19
Numeric TOKEN_RETURN = 20
Numeric TOKEN_IMPORT = 21
Numeric TOKEN_AS = 22
Numeric TOKEN_BREAK = 23
Numeric TOKEN_CONTINUE = 24
Numeric TOKEN_MODULE = 25
Numeric TOKEN_ENUM = 26

-- Types (30-34)
Numeric TOKEN_TYPE_STRING = 30
Numeric TOKEN_TYPE_NUMERIC = 31
Numeric TOKEN_TYPE_LIST = 32
Numeric TOKEN_TYPE_I32 = 33
Numeric TOKEN_TYPE_F64 = 34

-- Operators (40-54)
Numeric TOKEN_PLUS = 40
Numeric TOKEN_MINUS = 41
Numeric TOKEN_STAR = 42
Numeric TOKEN_DIV = 43
Numeric TOKEN_MOD = 44
Numeric TOKEN_ASSIGN = 45
Numeric TOKEN_EQ = 46
Numeric TOKEN_NEQ = 47
Numeric TOKEN_LT = 48
Numeric TOKEN_GT = 49
Numeric TOKEN_LTE = 50
Numeric TOKEN_GTE = 51
Numeric TOKEN_AND = 52
Numeric TOKEN_OR = 53
Numeric TOKEN_NOT = 54

-- Delimiters (60-67)
Numeric TOKEN_LEFT_PAREN = 60
Numeric TOKEN_RIGHT_PAREN = 61
Numeric TOKEN_LEFT_BRACKET = 62
Numeric TOKEN_RIGHT_BRACKET = 63
Numeric TOKEN_COMMA = 64
Numeric TOKEN_SEMICOLON = 65
Numeric TOKEN_DOT = 66
Numeric TOKEN_COLON = 67

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct Token then
    Numeric type
    String value
    Numeric line
    Numeric column
    list interpolation_parts
end_struct

struct LexerState then
    String source_code
    Numeric position
    Numeric length
    Numeric line
    Numeric column
    Numeric eof_reached
end_struct

-- =============================================================================
-- FACTORY & STATE MANAGEMENT
-- =============================================================================

function make_token(token_type, value, line, column)
    Token token
    token.type = token_type
    token.value = value
    token.line = line
    token.column = column
    token.interpolation_parts = list()
    return token
end_function

function lexer_state_create(source_code)
    LexerState state
    state.source_code = source_code
    state.position = 0
    state.length = string_length(source_code)
    state.line = 1
    state.column = 1
    state.eof_reached = 0
    return state
end_function

-- =============================================================================
-- CHARACTER HELPERS & CLASSIFICATION
-- =============================================================================

function char_at(state, offset)
    Numeric pos = state.position + offset
    if pos >= state.length then return "" end_if
    return string_substring(state.source_code, pos, 1)
end_function

function current_char(state)
    return char_at(state, 0)
end_function

function peek_char(state, offset)
    return char_at(state, offset)
end_function

function is_eof(state)
    if state.position >= state.length then return 1 end_if
    return 0
end_function

function advance(state)
    if is_eof(state) == 1 then return state end_if
    String ch = current_char(state)
    if ch == "\n" then
        state.line = state.line + 1
        state.column = 1
    else
        state.column = state.column + 1
    end_if
    state.position = state.position + 1
    return state
end_function

function is_digit(ch)
    if ch >= "0" then if ch <= "9" then return 1 end_if end_if
    return 0
end_function

function is_alpha(ch)
    if ch >= "a" then if ch <= "z" then return 1 end_if end_if
    if ch >= "A" then if ch <= "Z" then return 1 end_if end_if
    if ch == "_" then return 1 end_if
    return 0
end_function

function is_alnum(ch)
    if is_alpha(ch) == 1 then return 1 end_if
    if is_digit(ch) == 1 then return 1 end_if
    return 0
end_function

function is_whitespace(ch)
    if ch == " " then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- =============================================================================
-- WHITESPACE, COMMENTS & NUMBER/STRING READING
-- =============================================================================

function skip_whitespace(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_whitespace(ch) == 0 then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_line_comment(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == "\n" then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_whitespace_and_comments(state)
    while is_eof(state) == 0
        state = skip_whitespace(state)
        if is_eof(state) == 1 then break end_if
        String ch = current_char(state)
        String next = peek_char(state, 1)
        if ch == "-" then
            if next == "-" then
                state = skip_line_comment(state)
            else
                break
            end_if
        else
            break
        end_if
    end
    return state
end_function

function read_number(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_digit(ch) == 0 then
            if ch == "," then
                state = advance(state)
                continue
            end_if
            break
        end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    value = string_replace(value, ",", ".")
    Token token
    token = make_token(TOKEN_NUMBER, value, state.line, state.column)
    return token
end_function

function read_string(state, delimiter)
    state = advance(state)
    Numeric start = state.position
    list parts = list()
    String current_part = ""
    
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == delimiter then
            if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
            state = advance(state)
            break
        end_if
        if ch == "{" then
            if string_length(current_part) > 0 then
                mlp_list_add(parts, current_part)
                current_part = ""
            end_if
            state = advance(state)
            Numeric var_start = state.position
            while is_eof(state) == 0
                String vch = current_char(state)
                if vch == "}" then break end_if
                state = advance(state)
            end
            Numeric var_len = state.position - var_start
            String var_name = string_substring(state.source_code, var_start, var_len)
            mlp_list_add(parts, "{" + var_name + "}")
            state = advance(state)
        else
            current_part = current_part + ch
            state = advance(state)
        end_if
    end
    if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
    Numeric part_count = mlp_list_length(parts)
    if part_count > 1 then
        Token token
        token = make_token(TOKEN_INTERPOLATED_STRING, "", state.line, state.column)
        token.interpolation_parts = parts
        return token
    end_if
    if part_count == 1 then
        String final_value = mlp_list_get(parts, 0)
        return make_token(TOKEN_STRING, final_value, state.line, state.column)
    end_if
    return make_token(TOKEN_STRING, "", state.line, state.column)
end_function

-- =============================================================================
-- IDENTIFIER, OPERATOR READING & MAIN TOKENIZER
-- =============================================================================

function keyword_type(value)
    if value == "function" then return TOKEN_FUNCTION end_if
    if value == "end_function" then return TOKEN_END_FUNCTION end_if
    if value == "struct" then return TOKEN_STRUCT end_if
    if value == "end_struct" then return TOKEN_END_STRUCT end_if
    if value == "if" then return TOKEN_IF end_if
    if value == "then" then return TOKEN_THEN end_if
    if value == "else" then return TOKEN_ELSE end_if
    if value == "end_if" then return TOKEN_END_IF end_if
    if value == "while" then return TOKEN_WHILE end_if
    if value == "end" then return TOKEN_END end_if
    if value == "return" then return TOKEN_RETURN end_if
    if value == "import" then return TOKEN_IMPORT end_if
    if value == "as" then return TOKEN_AS end_if
    if value == "break" then return TOKEN_BREAK end_if
    if value == "continue" then return TOKEN_CONTINUE end_if
    if value == "module" then return TOKEN_MODULE end_if
    if value == "enum" then return TOKEN_ENUM end_if
    if value == "String" then return TOKEN_TYPE_STRING end_if
    if value == "Numeric" then return TOKEN_TYPE_NUMERIC end_if
    if value == "list" then return TOKEN_TYPE_LIST end_if
    if value == "i32" then return TOKEN_TYPE_I32 end_if
    if value == "f64" then return TOKEN_TYPE_F64 end_if
    return TOKEN_IDENTIFIER
end_function

function read_identifier(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_alnum(ch) == 0 then break end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    Numeric type = keyword_type(value)
    Token token
    token = make_token(type, value, state.line, state.column)
    return token
end_function

function read_operator(state)
    String ch = current_char(state)
    String next = peek_char(state, 1)
    
    -- Two-character operators
    if ch == "=" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_EQ, "==", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_ASSIGN, "=", state.line, state.column)
    end_if
    
    if ch == "!" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_NEQ, "!=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_NOT, "!", state.line, state.column)
    end_if
    
    if ch == "<" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_LTE, "<=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_LT, "<", state.line, state.column)
    end_if
    
    if ch == ">" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_GTE, ">=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_GT, ">", state.line, state.column)
    end_if
    
    if ch == "&" then
        if next == "&" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_AND, "&&", state.line, state.column)
        end_if
    end_if
    
    if ch == "|" then
        if next == "|" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_OR, "||", state.line, state.column)
        end_if
    end_if
    
    -- Single-character operators
    if ch == "+" then state = advance(state)
        return make_token(TOKEN_PLUS, "+", state.line, state.column) end_if
    if ch == "-" then state = advance(state)
        return make_token(TOKEN_MINUS, "-", state.line, state.column) end_if
    if ch == "*" then state = advance(state)
        return make_token(TOKEN_STAR, "*", state.line, state.column) end_if
    if ch == "/" then state = advance(state)
        return make_token(TOKEN_DIV, "/", state.line, state.column) end_if
    if ch == "%" then state = advance(state)
        return make_token(TOKEN_MOD, "%", state.line, state.column) end_if
    
    -- Delimiters
    if ch == "(" then state = advance(state)
        return make_token(TOKEN_LEFT_PAREN, "(", state.line, state.column) end_if
    if ch == ")" then state = advance(state)
        return make_token(TOKEN_RIGHT_PAREN, ")", state.line, state.column) end_if
    if ch == "[" then state = advance(state)
        return make_token(TOKEN_LEFT_BRACKET, "[", state.line, state.column) end_if
    if ch == "]" then state = advance(state)
        return make_token(TOKEN_RIGHT_BRACKET, "]", state.line, state.column) end_if
    if ch == "," then state = advance(state)
        return make_token(TOKEN_COMMA, ",", state.line, state.column) end_if
    if ch == ";" then state = advance(state)
        return make_token(TOKEN_SEMICOLON, ";", state.line, state.column) end_if
    if ch == "." then state = advance(state)
        return make_token(TOKEN_DOT, ".", state.line, state.column) end_if
    if ch == ":" then state = advance(state)
        return make_token(TOKEN_COLON, ":", state.line, state.column) end_if
    
    -- Unknown character
    state = advance(state)
    return make_token(TOKEN_EOF, "", state.line, state.column)
end_function

function get_next_token(state)
    if state.eof_reached == 1 then
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    state = skip_whitespace_and_comments(state)
    if is_eof(state) == 1 then
        state.eof_reached = 1
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    String ch = current_char(state)
    if is_digit(ch) == 1 then return read_number(state) end_if
    if ch == "\"" then return read_string(state, "\"") end_if
    if ch == "'" then return read_string(state, "'") end_if
    if is_alpha(ch) == 1 then return read_identifier(state) end_if
    return read_operator(state)
end_function

function tokenize(source_code)
    LexerState state
    state = lexer_state_create(source_code)
    list tokens = list()
    while state.eof_reached == 0
        Token token
        token = get_next_token(state)
        mlp_list_add(tokens, token)
        if token.type == TOKEN_EOF then break end_if
    end
    return tokens
end_function

-- =============================================================================
-- UTILITY: Token to String (for debugging)
-- =============================================================================

function token_type_name(type)
    if type == TOKEN_EOF then return "EOF" end_if
    if type == TOKEN_IDENTIFIER then return "IDENTIFIER" end_if
    if type == TOKEN_NUMBER then return "NUMBER" end_if
    if type == TOKEN_STRING then return "STRING" end_if
    if type == TOKEN_FUNCTION then return "FUNCTION" end_if
    return "UNKNOWN"
end_function
-- END IMPORT: lexer.mlp

-- =============================================================================
-- AST NODE TYPES
-- =============================================================================

Numeric AST_PROGRAM = 0
Numeric AST_FUNCTION = 1
Numeric AST_STRUCT = 2
Numeric AST_VARIABLE_DECL = 3
Numeric AST_ASSIGNMENT = 4
Numeric AST_IF_STMT = 5
Numeric AST_WHILE_STMT = 6
Numeric AST_RETURN_STMT = 7
Numeric AST_BLOCK = 8
Numeric AST_BINARY_OP = 9
Numeric AST_UNARY_OP = 10
Numeric AST_CALL = 11
Numeric AST_IDENTIFIER = 12
Numeric AST_NUMBER = 13
Numeric AST_STRING = 14
Numeric AST_IMPORT = 15
Numeric AST_PRINT = 16

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct ASTNode then
    Numeric node_type
    String value
    list children
    Numeric line
    Numeric column
end_struct

struct ParserState then
    list tokens
    Numeric position
    Numeric scope_level
end_struct

-- =============================================================================
-- FACTORY FUNCTIONS
-- =============================================================================

function make_ast_node(node_type, value, line, column)
    ASTNode node
    node.node_type = node_type
    node.value = value
    node.children = list()
    node.line = line
    node.column = column
    return node
end_function

function make_parser_state(tokens)
    ParserState state
    state.tokens = tokens
    state.position = 0
    state.scope_level = 0
    return state
end_function

-- =============================================================================
-- TOKEN NAVIGATION
-- =============================================================================

function current_token(state)
    Numeric pos = state.position
    Numeric length = mlp_list_length(state.tokens)
    if pos >= length then
        Token eof_token = make_token(TOKEN_EOF, "", 0, 0)
        return eof_token
    end_if
    return mlp_list_get(state.tokens, pos)
end_function

function peek_token(state, offset)
    Numeric pos = state.position + offset
    Numeric length = mlp_list_length(state.tokens)
    if pos >= length then
        Token eof_token = make_token(TOKEN_EOF, "", 0, 0)
        return eof_token
    end_if
    return mlp_list_get(state.tokens, pos)
end_function

function advance_token(state)
    state.position = state.position + 1
    return state
end_function

function expect_token(state, expected_type)
    Token token = current_token(state)
    if token.type != expected_type then
        print "Parser error at line " print token.line
    end_if
    return advance_token(state)
end_function

function match_token(state, token_type)
    Token token = current_token(state)
    if token.type == token_type then
        return 1
    end_if
    return 0
end_function

-- =============================================================================
-- PRECEDENCE TABLE
-- =============================================================================

function get_precedence(token_type)
    if token_type == TOKEN_OR then return 10 end_if
    if token_type == TOKEN_AND then return 20 end_if
    if token_type == TOKEN_EQ then return 30 end_if
    if token_type == TOKEN_NEQ then return 30 end_if
    if token_type == TOKEN_LT then return 40 end_if
    if token_type == TOKEN_GT then return 40 end_if
    if token_type == TOKEN_LTE then return 40 end_if
    if token_type == TOKEN_GTE then return 40 end_if
    if token_type == TOKEN_PLUS then return 50 end_if
    if token_type == TOKEN_MINUS then return 50 end_if
    if token_type == TOKEN_STAR then return 60 end_if
    if token_type == TOKEN_DIV then return 60 end_if
    if token_type == TOKEN_MOD then return 60 end_if
    return 0
end_function

-- =============================================================================
-- EXPRESSION PARSING (PRATT STYLE)
-- =============================================================================

function parse_primary(state)
    Token token = current_token(state)
    
    -- Number literal
    if token.type == TOKEN_NUMBER then
        ASTNode node = make_ast_node(AST_NUMBER, token.value, token.line, token.column)
        state = advance_token(state)
        return node
    end_if
    
    -- String literal
    if token.type == TOKEN_STRING then
        ASTNode node = make_ast_node(AST_STRING, token.value, token.line, token.column)
        state = advance_token(state)
        return node
    end_if
    
    -- Identifier or function call
    if token.type == TOKEN_IDENTIFIER then
        ASTNode node = make_ast_node(AST_IDENTIFIER, token.value, token.line, token.column)
        state = advance_token(state)
        
        -- Check for function call
        Token next_token = current_token(state)
        if next_token.type == TOKEN_LEFT_PAREN then
            node.node_type = AST_CALL
            state = advance_token(state)
            
            -- Parse arguments
            if match_token(state, TOKEN_RIGHT_PAREN) == 0 then
                while 1 == 1
                    ASTNode arg = parse_expression(state, 0)
                    mlp_list_add(node.children, arg)
                    
                    Token comma_token = current_token(state)
                    if comma_token.type != TOKEN_COMMA then
                        break
                    end_if
                    state = advance_token(state)
                end
            end_if
            
            state = expect_token(state, TOKEN_RIGHT_PAREN)
        end_if
        
        return node
    end_if
    
    -- Parenthesized expression
    if token.type == TOKEN_LEFT_PAREN then
        state = advance_token(state)
        ASTNode expr = parse_expression(state, 0)
        state = expect_token(state, TOKEN_RIGHT_PAREN)
        return expr
    end_if
    
    -- Unary operators
    if token.type == TOKEN_MINUS then
        ASTNode node = make_ast_node(AST_UNARY_OP, "-", token.line, token.column)
        state = advance_token(state)
        mlp_list_add(node.children, parse_primary(state))
        return node
    end_if
    
    if token.type == TOKEN_NOT then
        ASTNode node = make_ast_node(AST_UNARY_OP, "!", token.line, token.column)
        state = advance_token(state)
        mlp_list_add(node.children, parse_primary(state))
        return node
    end_if
    
    -- Error
    print "Parser error at line " print token.line
    ASTNode error_node = make_ast_node(AST_NUMBER, "0", token.line, token.column)
    return error_node
end_function

function parse_expression(state, min_precedence)
    ASTNode left = parse_primary(state)
    
    while 1 == 1
        Token op_token = current_token(state)
        Numeric op_prec = get_precedence(op_token.type)
        
        if op_prec == 0 then break end_if
        if op_prec < min_precedence then break end_if
        
        String op_value = op_token.value
        Numeric op_line = op_token.line
        Numeric op_col = op_token.column
        state = advance_token(state)
        
        ASTNode right = parse_expression(state, op_prec + 1)
        
        ASTNode binary_node = make_ast_node(AST_BINARY_OP, op_value, op_line, op_col)
        mlp_list_add(binary_node.children, left)
        mlp_list_add(binary_node.children, right)
        
        left = binary_node
    end
    
    return left
end_function

-- =============================================================================
-- STATEMENT PARSING
-- =============================================================================

function parse_import_statement(state)
    Token import_token = current_token(state)
    state = expect_token(state, TOKEN_IMPORT)
    
    Token module_token = current_token(state)
    state = expect_token(state, TOKEN_STRING)
    
    ASTNode node = make_ast_node(AST_IMPORT, module_token.value, import_token.line, import_token.column)
    return node
end_function

function parse_print_statement(state)
    Token print_token = current_token(state)
    state = expect_token(state, TOKEN_PRINT)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_PRINT, "", print_token.line, print_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_return_statement(state)
    Token return_token = current_token(state)
    state = expect_token(state, TOKEN_RETURN)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_RETURN_STMT, "", return_token.line, return_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_variable_declaration(state)
    Token type_token = current_token(state)
    state = advance_token(state)
    
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    
    ASTNode node = make_ast_node(AST_VARIABLE_DECL, name_token.value, type_token.line, type_token.column)
    node.value = type_token.value + ":" + name_token.value
    
    -- Check for assignment
    Token assign_token = current_token(state)
    if assign_token.type == TOKEN_ASSIGN then
        state = advance_token(state)
        ASTNode init_expr = parse_expression(state, 0)
        mlp_list_add(node.children, init_expr)
    end_if
    
    return node
end_function

function parse_assignment(state)
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    state = expect_token(state, TOKEN_ASSIGN)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_ASSIGNMENT, name_token.value, name_token.line, name_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_if_statement(state)
    Token if_token = current_token(state)
    state = expect_token(state, TOKEN_IF)
    
    ASTNode condition = parse_expression(state, 0)
    state = expect_token(state, TOKEN_THEN)
    
    ASTNode then_block = parse_block(state, TOKEN_END_IF)
    
    ASTNode node = make_ast_node(AST_IF_STMT, "", if_token.line, if_token.column)
    mlp_list_add(node.children, condition)
    mlp_list_add(node.children, then_block)
    
    -- Check for else
    Token next_token = current_token(state)
    if next_token.type == TOKEN_ELSE then
        state = advance_token(state)
        ASTNode else_block = parse_block(state, TOKEN_END_IF)
        mlp_list_add(node.children, else_block)
    end_if
    
    state = expect_token(state, TOKEN_END_IF)
    return node
end_function

function parse_while_statement(state)
    Token while_token = current_token(state)
    state = expect_token(state, TOKEN_WHILE)
    
    ASTNode condition = parse_expression(state, 0)
    ASTNode body = parse_block(state, TOKEN_END)
    
    state = expect_token(state, TOKEN_END)
    
    ASTNode node = make_ast_node(AST_WHILE_STMT, "", while_token.line, while_token.column)
    mlp_list_add(node.children, condition)
    mlp_list_add(node.children, body)
    return node
end_function

function parse_function_declaration(state)
    Token func_token = current_token(state)
    state = expect_token(state, TOKEN_FUNCTION)
    
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    
    ASTNode node = make_ast_node(AST_FUNCTION, name_token.value, func_token.line, func_token.column)
    
    state = expect_token(state, TOKEN_LEFT_PAREN)
    
    -- Parse parameters
    if match_token(state, TOKEN_RIGHT_PAREN) == 0 then
        while 1 == 1
            Token param_name = current_token(state)
            state = expect_token(state, TOKEN_IDENTIFIER)
            
            ASTNode param_node = make_ast_node(AST_IDENTIFIER, param_name.value, param_name.line, param_name.column)
            mlp_list_add(node.children, param_node)
            
            Token comma_token = current_token(state)
            if comma_token.type != TOKEN_COMMA then
                break
            end_if
            state = advance_token(state)
        end
    end_if
    
    state = expect_token(state, TOKEN_RIGHT_PAREN)
    
    -- Parse function body
    ASTNode body = parse_block(state, TOKEN_END_FUNCTION)
    mlp_list_add(node.children, body)
    
    state = expect_token(state, TOKEN_END_FUNCTION)
    return node
end_function

function parse_statement(state)
    Token token = current_token(state)
    
    if token.type == TOKEN_IMPORT then
        return parse_import_statement(state)
    end_if
     return parse_import_statement(state) end_if
    if token.type == TOKEN_FUNCTION then return parse_function_declaration(state) end_if
    if token.type == TOKEN_PRINT then return parse_print_statement(state) end_if
    if token.type == TOKEN_RETURN then return parse_return_statement(state) end_if
    if token.type == TOKEN_IF then return parse_if_statement(state) end_if
    if token.type == TOKEN_WHILE then return parse_while_statement(state) end_if
    if token.type == TOKEN_TYPE_NUMERIC then return parse_variable_declaration(state) end_if
    if token.type == TOKEN_TYPE_STRING then return parse_variable_declaration(state) end_if
    if token.type == TOKEN_IDENTIFIER then return parse_assignment(state) end_if
    
    print "Parser error at line "_function

function parse_block(state, end_token_type)
    list statements = list()
    
    while 1 == 1
        Token token = current_token(state)
        
        if token.type == TOKEN_EOF then
            break
        end_if
        
        if token.type == end_token_type then
            break
        end_if
        
        ASTNode stmt = parse_statement(state)
        mlp_list_add(statements, stmt)
    end
    
    Token block_token = current_token(state)
    ASTNode block_node = make_ast_node(AST_BLOCK, "", block_token.line, block_token.column)
    block_node.children = statements
    return block_node
end_function

-- =============================================================================
-- TOP-LEVEL PARSER
-- =============================================================================

function parse(tokens)
    ParserState state = make_parser_state(tokens)
    ASTNode root = parse_block(state, TOKEN_EOF)
    root.node_type = AST_PROGRAM
    return root
end_function

function ast_to_string(node, indent)
    String result = ""
    
    -- Add indentation
    Numeric i = 0
    while i < indent
        result = result + "  "
        i = i + 1
    end
    
    -- Node type
    if node.node_type == AST_PROGRAM then result = result + "PROGRAM" end_if
    if node.node_type == AST_FUNCTION then result = result + "FUNCTION " + node.value end_if
    if node.node_type == AST_VARIABLE_DECL then result = result + "VAR_DECL " + node.value end_if
    if node.node_type == AST_ASSIGNMENT then result = result + "ASSIGN " + node.value end_if
    if node.node_type == AST_IF_STMT then result = result + "IF" end_if
    if node.node_type == AST_WHILE_STMT then result = result + "WHILE" end_if
    if node.node_type == AST_RETURN_STMT then result = result + "RETURN" end_if
    if node.node_type == AST_BLOCK then result = result + "BLOCK" end_if
    if node.node_type == AST_BINARY_OP then result = result + "BINARY_OP " + node.value end_if
    if node.node_type == AST_UNARY_OP then result = result + "UNARY_OP " + node.value end_if
    if node.node_type == AST_CALL then result = result + "CALL " + node.value end_if
    if node.node_type == AST_IDENTIFIER then result = result + "ID " + node.value end_if
    if node.node_type == AST_NUMBER then result = result + "NUM " + node.value end_if
    if node.node_type == AST_STRING then result = result + "STR " + node.value end_if
    if node.node_type == AST_IMPORT then result = result + "IMPORT " + node.value end_if
    if node.node_type == AST_PRINT then result = result + "PRINT" end_if
    
    result = result + "\n"
    
    -- Children
    Numeric child_count = mlp_list_length(node.children)
    Numeric j = 0
    while j < child_count
        ASTNode child = mlp_list_get(node.children, j)
        result = result + ast_to_string(child, indent + 1)
        j = j + 1
    end
    
    return result
end_function
-- END IMPORT: lexer.mlp
-- BEGIN IMPORT: codegen.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Codegen Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 codegen.mlp (810 → <600 lines)
-- 6 Esas Compliant: MODULAR (<600), STATELESS, STRUCT+FUNC
-- Target: C code generation (GCC backend)

-- BEGIN IMPORT: lexer.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Lexer Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 lexer.mlp (635 → ~450 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- =============================================================================
-- TOKEN TYPES
-- =============================================================================

Numeric TOKEN_EOF = 0
Numeric TOKEN_IDENTIFIER = 1
Numeric TOKEN_NUMBER = 2
Numeric TOKEN_STRING = 3
Numeric TOKEN_INTERPOLATED_STRING = 4

-- Keywords (10-26)
Numeric TOKEN_FUNCTION = 10
Numeric TOKEN_END_FUNCTION = 11
Numeric TOKEN_STRUCT = 12
Numeric TOKEN_END_STRUCT = 13
Numeric TOKEN_IF = 14
Numeric TOKEN_THEN = 15
Numeric TOKEN_ELSE = 16
Numeric TOKEN_END_IF = 17
Numeric TOKEN_WHILE = 18
Numeric TOKEN_END = 19
Numeric TOKEN_RETURN = 20
Numeric TOKEN_IMPORT = 21
Numeric TOKEN_AS = 22
Numeric TOKEN_BREAK = 23
Numeric TOKEN_CONTINUE = 24
Numeric TOKEN_MODULE = 25
Numeric TOKEN_ENUM = 26

-- Types (30-34)
Numeric TOKEN_TYPE_STRING = 30
Numeric TOKEN_TYPE_NUMERIC = 31
Numeric TOKEN_TYPE_LIST = 32
Numeric TOKEN_TYPE_I32 = 33
Numeric TOKEN_TYPE_F64 = 34

-- Operators (40-54)
Numeric TOKEN_PLUS = 40
Numeric TOKEN_MINUS = 41
Numeric TOKEN_STAR = 42
Numeric TOKEN_DIV = 43
Numeric TOKEN_MOD = 44
Numeric TOKEN_ASSIGN = 45
Numeric TOKEN_EQ = 46
Numeric TOKEN_NEQ = 47
Numeric TOKEN_LT = 48
Numeric TOKEN_GT = 49
Numeric TOKEN_LTE = 50
Numeric TOKEN_GTE = 51
Numeric TOKEN_AND = 52
Numeric TOKEN_OR = 53
Numeric TOKEN_NOT = 54

-- Delimiters (60-67)
Numeric TOKEN_LEFT_PAREN = 60
Numeric TOKEN_RIGHT_PAREN = 61
Numeric TOKEN_LEFT_BRACKET = 62
Numeric TOKEN_RIGHT_BRACKET = 63
Numeric TOKEN_COMMA = 64
Numeric TOKEN_SEMICOLON = 65
Numeric TOKEN_DOT = 66
Numeric TOKEN_COLON = 67

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct Token then
    Numeric type
    String value
    Numeric line
    Numeric column
    list interpolation_parts
end_struct

struct LexerState then
    String source_code
    Numeric position
    Numeric length
    Numeric line
    Numeric column
    Numeric eof_reached
end_struct

-- =============================================================================
-- FACTORY & STATE MANAGEMENT
-- =============================================================================

function make_token(token_type, value, line, column)
    Token token
    token.type = token_type
    token.value = value
    token.line = line
    token.column = column
    token.interpolation_parts = list()
    return token
end_function

function lexer_state_create(source_code)
    LexerState state
    state.source_code = source_code
    state.position = 0
    state.length = string_length(source_code)
    state.line = 1
    state.column = 1
    state.eof_reached = 0
    return state
end_function

-- =============================================================================
-- CHARACTER HELPERS & CLASSIFICATION
-- =============================================================================

function char_at(state, offset)
    Numeric pos = state.position + offset
    if pos >= state.length then return "" end_if
    return string_substring(state.source_code, pos, 1)
end_function

function current_char(state)
    return char_at(state, 0)
end_function

function peek_char(state, offset)
    return char_at(state, offset)
end_function

function is_eof(state)
    if state.position >= state.length then return 1 end_if
    return 0
end_function

function advance(state)
    if is_eof(state) == 1 then return state end_if
    String ch = current_char(state)
    if ch == "\n" then
        state.line = state.line + 1
        state.column = 1
    else
        state.column = state.column + 1
    end_if
    state.position = state.position + 1
    return state
end_function

function is_digit(ch)
    if ch >= "0" then if ch <= "9" then return 1 end_if end_if
    return 0
end_function

function is_alpha(ch)
    if ch >= "a" then if ch <= "z" then return 1 end_if end_if
    if ch >= "A" then if ch <= "Z" then return 1 end_if end_if
    if ch == "_" then return 1 end_if
    return 0
end_function

function is_alnum(ch)
    if is_alpha(ch) == 1 then return 1 end_if
    if is_digit(ch) == 1 then return 1 end_if
    return 0
end_function

function is_whitespace(ch)
    if ch == " " then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- =============================================================================
-- WHITESPACE, COMMENTS & NUMBER/STRING READING
-- =============================================================================

function skip_whitespace(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_whitespace(ch) == 0 then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_line_comment(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == "\n" then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_whitespace_and_comments(state)
    while is_eof(state) == 0
        state = skip_whitespace(state)
        if is_eof(state) == 1 then break end_if
        String ch = current_char(state)
        String next = peek_char(state, 1)
        if ch == "-" then
            if next == "-" then
                state = skip_line_comment(state)
            else
                break
            end_if
        else
            break
        end_if
    end
    return state
end_function

function read_number(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_digit(ch) == 0 then
            if ch == "," then
                state = advance(state)
                continue
            end_if
            break
        end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    value = string_replace(value, ",", ".")
    Token token
    token = make_token(TOKEN_NUMBER, value, state.line, state.column)
    return token
end_function

function read_string(state, delimiter)
    state = advance(state)
    Numeric start = state.position
    list parts = list()
    String current_part = ""
    
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == delimiter then
            if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
            state = advance(state)
            break
        end_if
        if ch == "{" then
            if string_length(current_part) > 0 then
                mlp_list_add(parts, current_part)
                current_part = ""
            end_if
            state = advance(state)
            Numeric var_start = state.position
            while is_eof(state) == 0
                String vch = current_char(state)
                if vch == "}" then break end_if
                state = advance(state)
            end
            Numeric var_len = state.position - var_start
            String var_name = string_substring(state.source_code, var_start, var_len)
            mlp_list_add(parts, "{" + var_name + "}")
            state = advance(state)
        else
            current_part = current_part + ch
            state = advance(state)
        end_if
    end
    if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
    Numeric part_count = mlp_list_length(parts)
    if part_count > 1 then
        Token token
        token = make_token(TOKEN_INTERPOLATED_STRING, "", state.line, state.column)
        token.interpolation_parts = parts
        return token
    end_if
    if part_count == 1 then
        String final_value = mlp_list_get(parts, 0)
        return make_token(TOKEN_STRING, final_value, state.line, state.column)
    end_if
    return make_token(TOKEN_STRING, "", state.line, state.column)
end_function

-- =============================================================================
-- IDENTIFIER, OPERATOR READING & MAIN TOKENIZER
-- =============================================================================

function keyword_type(value)
    if value == "function" then return TOKEN_FUNCTION end_if
    if value == "end_function" then return TOKEN_END_FUNCTION end_if
    if value == "struct" then return TOKEN_STRUCT end_if
    if value == "end_struct" then return TOKEN_END_STRUCT end_if
    if value == "if" then return TOKEN_IF end_if
    if value == "then" then return TOKEN_THEN end_if
    if value == "else" then return TOKEN_ELSE end_if
    if value == "end_if" then return TOKEN_END_IF end_if
    if value == "while" then return TOKEN_WHILE end_if
    if value == "end" then return TOKEN_END end_if
    if value == "return" then return TOKEN_RETURN end_if
    if value == "import" then return TOKEN_IMPORT end_if
    if value == "as" then return TOKEN_AS end_if
    if value == "break" then return TOKEN_BREAK end_if
    if value == "continue" then return TOKEN_CONTINUE end_if
    if value == "module" then return TOKEN_MODULE end_if
    if value == "enum" then return TOKEN_ENUM end_if
    if value == "String" then return TOKEN_TYPE_STRING end_if
    if value == "Numeric" then return TOKEN_TYPE_NUMERIC end_if
    if value == "list" then return TOKEN_TYPE_LIST end_if
    if value == "i32" then return TOKEN_TYPE_I32 end_if
    if value == "f64" then return TOKEN_TYPE_F64 end_if
    return TOKEN_IDENTIFIER
end_function

function read_identifier(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_alnum(ch) == 0 then break end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    Numeric type = keyword_type(value)
    Token token
    token = make_token(type, value, state.line, state.column)
    return token
end_function

function read_operator(state)
    String ch = current_char(state)
    String next = peek_char(state, 1)
    
    -- Two-character operators
    if ch == "=" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_EQ, "==", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_ASSIGN, "=", state.line, state.column)
    end_if
    
    if ch == "!" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_NEQ, "!=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_NOT, "!", state.line, state.column)
    end_if
    
    if ch == "<" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_LTE, "<=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_LT, "<", state.line, state.column)
    end_if
    
    if ch == ">" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_GTE, ">=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_GT, ">", state.line, state.column)
    end_if
    
    if ch == "&" then
        if next == "&" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_AND, "&&", state.line, state.column)
        end_if
    end_if
    
    if ch == "|" then
        if next == "|" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_OR, "||", state.line, state.column)
        end_if
    end_if
    
    -- Single-character operators
    if ch == "+" then state = advance(state)
        return make_token(TOKEN_PLUS, "+", state.line, state.column) end_if
    if ch == "-" then state = advance(state)
        return make_token(TOKEN_MINUS, "-", state.line, state.column) end_if
    if ch == "*" then state = advance(state)
        return make_token(TOKEN_STAR, "*", state.line, state.column) end_if
    if ch == "/" then state = advance(state)
        return make_token(TOKEN_DIV, "/", state.line, state.column) end_if
    if ch == "%" then state = advance(state)
        return make_token(TOKEN_MOD, "%", state.line, state.column) end_if
    
    -- Delimiters
    if ch == "(" then state = advance(state)
        return make_token(TOKEN_LEFT_PAREN, "(", state.line, state.column) end_if
    if ch == ")" then state = advance(state)
        return make_token(TOKEN_RIGHT_PAREN, ")", state.line, state.column) end_if
    if ch == "[" then state = advance(state)
        return make_token(TOKEN_LEFT_BRACKET, "[", state.line, state.column) end_if
    if ch == "]" then state = advance(state)
        return make_token(TOKEN_RIGHT_BRACKET, "]", state.line, state.column) end_if
    if ch == "," then state = advance(state)
        return make_token(TOKEN_COMMA, ",", state.line, state.column) end_if
    if ch == ";" then state = advance(state)
        return make_token(TOKEN_SEMICOLON, ";", state.line, state.column) end_if
    if ch == "." then state = advance(state)
        return make_token(TOKEN_DOT, ".", state.line, state.column) end_if
    if ch == ":" then state = advance(state)
        return make_token(TOKEN_COLON, ":", state.line, state.column) end_if
    
    -- Unknown character
    state = advance(state)
    return make_token(TOKEN_EOF, "", state.line, state.column)
end_function

function get_next_token(state)
    if state.eof_reached == 1 then
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    state = skip_whitespace_and_comments(state)
    if is_eof(state) == 1 then
        state.eof_reached = 1
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    String ch = current_char(state)
    if is_digit(ch) == 1 then return read_number(state) end_if
    if ch == "\"" then return read_string(state, "\"") end_if
    if ch == "'" then return read_string(state, "'") end_if
    if is_alpha(ch) == 1 then return read_identifier(state) end_if
    return read_operator(state)
end_function

function tokenize(source_code)
    LexerState state
    state = lexer_state_create(source_code)
    list tokens = list()
    while state.eof_reached == 0
        Token token
        token = get_next_token(state)
        mlp_list_add(tokens, token)
        if token.type == TOKEN_EOF then break end_if
    end
    return tokens
end_function

-- =============================================================================
-- UTILITY: Token to String (for debugging)
-- =============================================================================

function token_type_name(type)
    if type == TOKEN_EOF then return "EOF" end_if
    if type == TOKEN_IDENTIFIER then return "IDENTIFIER" end_if
    if type == TOKEN_NUMBER then return "NUMBER" end_if
    if type == TOKEN_STRING then return "STRING" end_if
    if type == TOKEN_FUNCTION then return "FUNCTION" end_if
    return "UNKNOWN"
end_function
-- END IMPORT: lexer.mlp
-- BEGIN IMPORT: parser.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Parser Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 parser.mlp (661 → <500 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- BEGIN IMPORT: lexer.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Lexer Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 lexer.mlp (635 → ~450 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- =============================================================================
-- TOKEN TYPES
-- =============================================================================

Numeric TOKEN_EOF = 0
Numeric TOKEN_IDENTIFIER = 1
Numeric TOKEN_NUMBER = 2
Numeric TOKEN_STRING = 3
Numeric TOKEN_INTERPOLATED_STRING = 4

-- Keywords (10-26)
Numeric TOKEN_FUNCTION = 10
Numeric TOKEN_END_FUNCTION = 11
Numeric TOKEN_STRUCT = 12
Numeric TOKEN_END_STRUCT = 13
Numeric TOKEN_IF = 14
Numeric TOKEN_THEN = 15
Numeric TOKEN_ELSE = 16
Numeric TOKEN_END_IF = 17
Numeric TOKEN_WHILE = 18
Numeric TOKEN_END = 19
Numeric TOKEN_RETURN = 20
Numeric TOKEN_IMPORT = 21
Numeric TOKEN_AS = 22
Numeric TOKEN_BREAK = 23
Numeric TOKEN_CONTINUE = 24
Numeric TOKEN_MODULE = 25
Numeric TOKEN_ENUM = 26

-- Types (30-34)
Numeric TOKEN_TYPE_STRING = 30
Numeric TOKEN_TYPE_NUMERIC = 31
Numeric TOKEN_TYPE_LIST = 32
Numeric TOKEN_TYPE_I32 = 33
Numeric TOKEN_TYPE_F64 = 34

-- Operators (40-54)
Numeric TOKEN_PLUS = 40
Numeric TOKEN_MINUS = 41
Numeric TOKEN_STAR = 42
Numeric TOKEN_DIV = 43
Numeric TOKEN_MOD = 44
Numeric TOKEN_ASSIGN = 45
Numeric TOKEN_EQ = 46
Numeric TOKEN_NEQ = 47
Numeric TOKEN_LT = 48
Numeric TOKEN_GT = 49
Numeric TOKEN_LTE = 50
Numeric TOKEN_GTE = 51
Numeric TOKEN_AND = 52
Numeric TOKEN_OR = 53
Numeric TOKEN_NOT = 54

-- Delimiters (60-67)
Numeric TOKEN_LEFT_PAREN = 60
Numeric TOKEN_RIGHT_PAREN = 61
Numeric TOKEN_LEFT_BRACKET = 62
Numeric TOKEN_RIGHT_BRACKET = 63
Numeric TOKEN_COMMA = 64
Numeric TOKEN_SEMICOLON = 65
Numeric TOKEN_DOT = 66
Numeric TOKEN_COLON = 67

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct Token then
    Numeric type
    String value
    Numeric line
    Numeric column
    list interpolation_parts
end_struct

struct LexerState then
    String source_code
    Numeric position
    Numeric length
    Numeric line
    Numeric column
    Numeric eof_reached
end_struct

-- =============================================================================
-- FACTORY & STATE MANAGEMENT
-- =============================================================================

function make_token(token_type, value, line, column)
    Token token
    token.type = token_type
    token.value = value
    token.line = line
    token.column = column
    token.interpolation_parts = list()
    return token
end_function

function lexer_state_create(source_code)
    LexerState state
    state.source_code = source_code
    state.position = 0
    state.length = string_length(source_code)
    state.line = 1
    state.column = 1
    state.eof_reached = 0
    return state
end_function

-- =============================================================================
-- CHARACTER HELPERS & CLASSIFICATION
-- =============================================================================

function char_at(state, offset)
    Numeric pos = state.position + offset
    if pos >= state.length then return "" end_if
    return string_substring(state.source_code, pos, 1)
end_function

function current_char(state)
    return char_at(state, 0)
end_function

function peek_char(state, offset)
    return char_at(state, offset)
end_function

function is_eof(state)
    if state.position >= state.length then return 1 end_if
    return 0
end_function

function advance(state)
    if is_eof(state) == 1 then return state end_if
    String ch = current_char(state)
    if ch == "\n" then
        state.line = state.line + 1
        state.column = 1
    else
        state.column = state.column + 1
    end_if
    state.position = state.position + 1
    return state
end_function

function is_digit(ch)
    if ch >= "0" then if ch <= "9" then return 1 end_if end_if
    return 0
end_function

function is_alpha(ch)
    if ch >= "a" then if ch <= "z" then return 1 end_if end_if
    if ch >= "A" then if ch <= "Z" then return 1 end_if end_if
    if ch == "_" then return 1 end_if
    return 0
end_function

function is_alnum(ch)
    if is_alpha(ch) == 1 then return 1 end_if
    if is_digit(ch) == 1 then return 1 end_if
    return 0
end_function

function is_whitespace(ch)
    if ch == " " then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- =============================================================================
-- WHITESPACE, COMMENTS & NUMBER/STRING READING
-- =============================================================================

function skip_whitespace(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_whitespace(ch) == 0 then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_line_comment(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == "\n" then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_whitespace_and_comments(state)
    while is_eof(state) == 0
        state = skip_whitespace(state)
        if is_eof(state) == 1 then break end_if
        String ch = current_char(state)
        String next = peek_char(state, 1)
        if ch == "-" then
            if next == "-" then
                state = skip_line_comment(state)
            else
                break
            end_if
        else
            break
        end_if
    end
    return state
end_function

function read_number(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_digit(ch) == 0 then
            if ch == "," then
                state = advance(state)
                continue
            end_if
            break
        end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    value = string_replace(value, ",", ".")
    Token token
    token = make_token(TOKEN_NUMBER, value, state.line, state.column)
    return token
end_function

function read_string(state, delimiter)
    state = advance(state)
    Numeric start = state.position
    list parts = list()
    String current_part = ""
    
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == delimiter then
            if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
            state = advance(state)
            break
        end_if
        if ch == "{" then
            if string_length(current_part) > 0 then
                mlp_list_add(parts, current_part)
                current_part = ""
            end_if
            state = advance(state)
            Numeric var_start = state.position
            while is_eof(state) == 0
                String vch = current_char(state)
                if vch == "}" then break end_if
                state = advance(state)
            end
            Numeric var_len = state.position - var_start
            String var_name = string_substring(state.source_code, var_start, var_len)
            mlp_list_add(parts, "{" + var_name + "}")
            state = advance(state)
        else
            current_part = current_part + ch
            state = advance(state)
        end_if
    end
    if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
    Numeric part_count = mlp_list_length(parts)
    if part_count > 1 then
        Token token
        token = make_token(TOKEN_INTERPOLATED_STRING, "", state.line, state.column)
        token.interpolation_parts = parts
        return token
    end_if
    if part_count == 1 then
        String final_value = mlp_list_get(parts, 0)
        return make_token(TOKEN_STRING, final_value, state.line, state.column)
    end_if
    return make_token(TOKEN_STRING, "", state.line, state.column)
end_function

-- =============================================================================
-- IDENTIFIER, OPERATOR READING & MAIN TOKENIZER
-- =============================================================================

function keyword_type(value)
    if value == "function" then return TOKEN_FUNCTION end_if
    if value == "end_function" then return TOKEN_END_FUNCTION end_if
    if value == "struct" then return TOKEN_STRUCT end_if
    if value == "end_struct" then return TOKEN_END_STRUCT end_if
    if value == "if" then return TOKEN_IF end_if
    if value == "then" then return TOKEN_THEN end_if
    if value == "else" then return TOKEN_ELSE end_if
    if value == "end_if" then return TOKEN_END_IF end_if
    if value == "while" then return TOKEN_WHILE end_if
    if value == "end" then return TOKEN_END end_if
    if value == "return" then return TOKEN_RETURN end_if
    if value == "import" then return TOKEN_IMPORT end_if
    if value == "as" then return TOKEN_AS end_if
    if value == "break" then return TOKEN_BREAK end_if
    if value == "continue" then return TOKEN_CONTINUE end_if
    if value == "module" then return TOKEN_MODULE end_if
    if value == "enum" then return TOKEN_ENUM end_if
    if value == "String" then return TOKEN_TYPE_STRING end_if
    if value == "Numeric" then return TOKEN_TYPE_NUMERIC end_if
    if value == "list" then return TOKEN_TYPE_LIST end_if
    if value == "i32" then return TOKEN_TYPE_I32 end_if
    if value == "f64" then return TOKEN_TYPE_F64 end_if
    return TOKEN_IDENTIFIER
end_function

function read_identifier(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_alnum(ch) == 0 then break end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    Numeric type = keyword_type(value)
    Token token
    token = make_token(type, value, state.line, state.column)
    return token
end_function

function read_operator(state)
    String ch = current_char(state)
    String next = peek_char(state, 1)
    
    -- Two-character operators
    if ch == "=" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_EQ, "==", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_ASSIGN, "=", state.line, state.column)
    end_if
    
    if ch == "!" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_NEQ, "!=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_NOT, "!", state.line, state.column)
    end_if
    
    if ch == "<" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_LTE, "<=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_LT, "<", state.line, state.column)
    end_if
    
    if ch == ">" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_GTE, ">=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_GT, ">", state.line, state.column)
    end_if
    
    if ch == "&" then
        if next == "&" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_AND, "&&", state.line, state.column)
        end_if
    end_if
    
    if ch == "|" then
        if next == "|" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_OR, "||", state.line, state.column)
        end_if
    end_if
    
    -- Single-character operators
    if ch == "+" then state = advance(state)
        return make_token(TOKEN_PLUS, "+", state.line, state.column) end_if
    if ch == "-" then state = advance(state)
        return make_token(TOKEN_MINUS, "-", state.line, state.column) end_if
    if ch == "*" then state = advance(state)
        return make_token(TOKEN_STAR, "*", state.line, state.column) end_if
    if ch == "/" then state = advance(state)
        return make_token(TOKEN_DIV, "/", state.line, state.column) end_if
    if ch == "%" then state = advance(state)
        return make_token(TOKEN_MOD, "%", state.line, state.column) end_if
    
    -- Delimiters
    if ch == "(" then state = advance(state)
        return make_token(TOKEN_LEFT_PAREN, "(", state.line, state.column) end_if
    if ch == ")" then state = advance(state)
        return make_token(TOKEN_RIGHT_PAREN, ")", state.line, state.column) end_if
    if ch == "[" then state = advance(state)
        return make_token(TOKEN_LEFT_BRACKET, "[", state.line, state.column) end_if
    if ch == "]" then state = advance(state)
        return make_token(TOKEN_RIGHT_BRACKET, "]", state.line, state.column) end_if
    if ch == "," then state = advance(state)
        return make_token(TOKEN_COMMA, ",", state.line, state.column) end_if
    if ch == ";" then state = advance(state)
        return make_token(TOKEN_SEMICOLON, ";", state.line, state.column) end_if
    if ch == "." then state = advance(state)
        return make_token(TOKEN_DOT, ".", state.line, state.column) end_if
    if ch == ":" then state = advance(state)
        return make_token(TOKEN_COLON, ":", state.line, state.column) end_if
    
    -- Unknown character
    state = advance(state)
    return make_token(TOKEN_EOF, "", state.line, state.column)
end_function

function get_next_token(state)
    if state.eof_reached == 1 then
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    state = skip_whitespace_and_comments(state)
    if is_eof(state) == 1 then
        state.eof_reached = 1
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    String ch = current_char(state)
    if is_digit(ch) == 1 then return read_number(state) end_if
    if ch == "\"" then return read_string(state, "\"") end_if
    if ch == "'" then return read_string(state, "'") end_if
    if is_alpha(ch) == 1 then return read_identifier(state) end_if
    return read_operator(state)
end_function

function tokenize(source_code)
    LexerState state
    state = lexer_state_create(source_code)
    list tokens = list()
    while state.eof_reached == 0
        Token token
        token = get_next_token(state)
        mlp_list_add(tokens, token)
        if token.type == TOKEN_EOF then break end_if
    end
    return tokens
end_function

-- =============================================================================
-- UTILITY: Token to String (for debugging)
-- =============================================================================

function token_type_name(type)
    if type == TOKEN_EOF then return "EOF" end_if
    if type == TOKEN_IDENTIFIER then return "IDENTIFIER" end_if
    if type == TOKEN_NUMBER then return "NUMBER" end_if
    if type == TOKEN_STRING then return "STRING" end_if
    if type == TOKEN_FUNCTION then return "FUNCTION" end_if
    return "UNKNOWN"
end_function
-- END IMPORT: lexer.mlp

-- =============================================================================
-- AST NODE TYPES
-- =============================================================================

Numeric AST_PROGRAM = 0
Numeric AST_FUNCTION = 1
Numeric AST_STRUCT = 2
Numeric AST_VARIABLE_DECL = 3
Numeric AST_ASSIGNMENT = 4
Numeric AST_IF_STMT = 5
Numeric AST_WHILE_STMT = 6
Numeric AST_RETURN_STMT = 7
Numeric AST_BLOCK = 8
Numeric AST_BINARY_OP = 9
Numeric AST_UNARY_OP = 10
Numeric AST_CALL = 11
Numeric AST_IDENTIFIER = 12
Numeric AST_NUMBER = 13
Numeric AST_STRING = 14
Numeric AST_IMPORT = 15
Numeric AST_PRINT = 16

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct ASTNode then
    Numeric node_type
    String value
    list children
    Numeric line
    Numeric column
end_struct

struct ParserState then
    list tokens
    Numeric position
    Numeric scope_level
end_struct

-- =============================================================================
-- FACTORY FUNCTIONS
-- =============================================================================

function make_ast_node(node_type, value, line, column)
    ASTNode node
    node.node_type = node_type
    node.value = value
    node.children = list()
    node.line = line
    node.column = column
    return node
end_function

function make_parser_state(tokens)
    ParserState state
    state.tokens = tokens
    state.position = 0
    state.scope_level = 0
    return state
end_function

-- =============================================================================
-- TOKEN NAVIGATION
-- =============================================================================

function current_token(state)
    Numeric pos = state.position
    Numeric length = mlp_list_length(state.tokens)
    if pos >= length then
        Token eof_token = make_token(TOKEN_EOF, "", 0, 0)
        return eof_token
    end_if
    return mlp_list_get(state.tokens, pos)
end_function

function peek_token(state, offset)
    Numeric pos = state.position + offset
    Numeric length = mlp_list_length(state.tokens)
    if pos >= length then
        Token eof_token = make_token(TOKEN_EOF, "", 0, 0)
        return eof_token
    end_if
    return mlp_list_get(state.tokens, pos)
end_function

function advance_token(state)
    state.position = state.position + 1
    return state
end_function

function expect_token(state, expected_type)
    Token token = current_token(state)
    if token.type != expected_type then
        print "Parser error at line " print token.line
    end_if
    return advance_token(state)
end_function

function match_token(state, token_type)
    Token token = current_token(state)
    if token.type == token_type then
        return 1
    end_if
    return 0
end_function

-- =============================================================================
-- PRECEDENCE TABLE
-- =============================================================================

function get_precedence(token_type)
    if token_type == TOKEN_OR then return 10 end_if
    if token_type == TOKEN_AND then return 20 end_if
    if token_type == TOKEN_EQ then return 30 end_if
    if token_type == TOKEN_NEQ then return 30 end_if
    if token_type == TOKEN_LT then return 40 end_if
    if token_type == TOKEN_GT then return 40 end_if
    if token_type == TOKEN_LTE then return 40 end_if
    if token_type == TOKEN_GTE then return 40 end_if
    if token_type == TOKEN_PLUS then return 50 end_if
    if token_type == TOKEN_MINUS then return 50 end_if
    if token_type == TOKEN_STAR then return 60 end_if
    if token_type == TOKEN_DIV then return 60 end_if
    if token_type == TOKEN_MOD then return 60 end_if
    return 0
end_function

-- =============================================================================
-- EXPRESSION PARSING (PRATT STYLE)
-- =============================================================================

function parse_primary(state)
    Token token = current_token(state)
    
    -- Number literal
    if token.type == TOKEN_NUMBER then
        ASTNode node = make_ast_node(AST_NUMBER, token.value, token.line, token.column)
        state = advance_token(state)
        return node
    end_if
    
    -- String literal
    if token.type == TOKEN_STRING then
        ASTNode node = make_ast_node(AST_STRING, token.value, token.line, token.column)
        state = advance_token(state)
        return node
    end_if
    
    -- Identifier or function call
    if token.type == TOKEN_IDENTIFIER then
        ASTNode node = make_ast_node(AST_IDENTIFIER, token.value, token.line, token.column)
        state = advance_token(state)
        
        -- Check for function call
        Token next_token = current_token(state)
        if next_token.type == TOKEN_LEFT_PAREN then
            node.node_type = AST_CALL
            state = advance_token(state)
            
            -- Parse arguments
            if match_token(state, TOKEN_RIGHT_PAREN) == 0 then
                while 1 == 1
                    ASTNode arg = parse_expression(state, 0)
                    mlp_list_add(node.children, arg)
                    
                    Token comma_token = current_token(state)
                    if comma_token.type != TOKEN_COMMA then
                        break
                    end_if
                    state = advance_token(state)
                end
            end_if
            
            state = expect_token(state, TOKEN_RIGHT_PAREN)
        end_if
        
        return node
    end_if
    
    -- Parenthesized expression
    if token.type == TOKEN_LEFT_PAREN then
        state = advance_token(state)
        ASTNode expr = parse_expression(state, 0)
        state = expect_token(state, TOKEN_RIGHT_PAREN)
        return expr
    end_if
    
    -- Unary operators
    if token.type == TOKEN_MINUS then
        ASTNode node = make_ast_node(AST_UNARY_OP, "-", token.line, token.column)
        state = advance_token(state)
        mlp_list_add(node.children, parse_primary(state))
        return node
    end_if
    
    if token.type == TOKEN_NOT then
        ASTNode node = make_ast_node(AST_UNARY_OP, "!", token.line, token.column)
        state = advance_token(state)
        mlp_list_add(node.children, parse_primary(state))
        return node
    end_if
    
    -- Error
    print "Parser error at line " print token.line
    ASTNode error_node = make_ast_node(AST_NUMBER, "0", token.line, token.column)
    return error_node
end_function

function parse_expression(state, min_precedence)
    ASTNode left = parse_primary(state)
    
    while 1 == 1
        Token op_token = current_token(state)
        Numeric op_prec = get_precedence(op_token.type)
        
        if op_prec == 0 then break end_if
        if op_prec < min_precedence then break end_if
        
        String op_value = op_token.value
        Numeric op_line = op_token.line
        Numeric op_col = op_token.column
        state = advance_token(state)
        
        ASTNode right = parse_expression(state, op_prec + 1)
        
        ASTNode binary_node = make_ast_node(AST_BINARY_OP, op_value, op_line, op_col)
        mlp_list_add(binary_node.children, left)
        mlp_list_add(binary_node.children, right)
        
        left = binary_node
    end
    
    return left
end_function

-- =============================================================================
-- STATEMENT PARSING
-- =============================================================================

function parse_import_statement(state)
    Token import_token = current_token(state)
    state = expect_token(state, TOKEN_IMPORT)
    
    Token module_token = current_token(state)
    state = expect_token(state, TOKEN_STRING)
    
    ASTNode node = make_ast_node(AST_IMPORT, module_token.value, import_token.line, import_token.column)
    return node
end_function

function parse_print_statement(state)
    Token print_token = current_token(state)
    state = expect_token(state, TOKEN_PRINT)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_PRINT, "", print_token.line, print_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_return_statement(state)
    Token return_token = current_token(state)
    state = expect_token(state, TOKEN_RETURN)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_RETURN_STMT, "", return_token.line, return_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_variable_declaration(state)
    Token type_token = current_token(state)
    state = advance_token(state)
    
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    
    ASTNode node = make_ast_node(AST_VARIABLE_DECL, name_token.value, type_token.line, type_token.column)
    node.value = type_token.value + ":" + name_token.value
    
    -- Check for assignment
    Token assign_token = current_token(state)
    if assign_token.type == TOKEN_ASSIGN then
        state = advance_token(state)
        ASTNode init_expr = parse_expression(state, 0)
        mlp_list_add(node.children, init_expr)
    end_if
    
    return node
end_function

function parse_assignment(state)
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    state = expect_token(state, TOKEN_ASSIGN)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_ASSIGNMENT, name_token.value, name_token.line, name_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_if_statement(state)
    Token if_token = current_token(state)
    state = expect_token(state, TOKEN_IF)
    
    ASTNode condition = parse_expression(state, 0)
    state = expect_token(state, TOKEN_THEN)
    
    ASTNode then_block = parse_block(state, TOKEN_END_IF)
    
    ASTNode node = make_ast_node(AST_IF_STMT, "", if_token.line, if_token.column)
    mlp_list_add(node.children, condition)
    mlp_list_add(node.children, then_block)
    
    -- Check for else
    Token next_token = current_token(state)
    if next_token.type == TOKEN_ELSE then
        state = advance_token(state)
        ASTNode else_block = parse_block(state, TOKEN_END_IF)
        mlp_list_add(node.children, else_block)
    end_if
    
    state = expect_token(state, TOKEN_END_IF)
    return node
end_function

function parse_while_statement(state)
    Token while_token = current_token(state)
    state = expect_token(state, TOKEN_WHILE)
    
    ASTNode condition = parse_expression(state, 0)
    ASTNode body = parse_block(state, TOKEN_END)
    
    state = expect_token(state, TOKEN_END)
    
    ASTNode node = make_ast_node(AST_WHILE_STMT, "", while_token.line, while_token.column)
    mlp_list_add(node.children, condition)
    mlp_list_add(node.children, body)
    return node
end_function

function parse_function_declaration(state)
    Token func_token = current_token(state)
    state = expect_token(state, TOKEN_FUNCTION)
    
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    
    ASTNode node = make_ast_node(AST_FUNCTION, name_token.value, func_token.line, func_token.column)
    
    state = expect_token(state, TOKEN_LEFT_PAREN)
    
    -- Parse parameters
    if match_token(state, TOKEN_RIGHT_PAREN) == 0 then
        while 1 == 1
            Token param_name = current_token(state)
            state = expect_token(state, TOKEN_IDENTIFIER)
            
            ASTNode param_node = make_ast_node(AST_IDENTIFIER, param_name.value, param_name.line, param_name.column)
            mlp_list_add(node.children, param_node)
            
            Token comma_token = current_token(state)
            if comma_token.type != TOKEN_COMMA then
                break
            end_if
            state = advance_token(state)
        end
    end_if
    
    state = expect_token(state, TOKEN_RIGHT_PAREN)
    
    -- Parse function body
    ASTNode body = parse_block(state, TOKEN_END_FUNCTION)
    mlp_list_add(node.children, body)
    
    state = expect_token(state, TOKEN_END_FUNCTION)
    return node
end_function

function parse_statement(state)
    Token token = current_token(state)
    
    if token.type == TOKEN_IMPORT then
        return parse_import_statement(state)
    end_if
     return parse_import_statement(state) end_if
    if token.type == TOKEN_FUNCTION then return parse_function_declaration(state) end_if
    if token.type == TOKEN_PRINT then return parse_print_statement(state) end_if
    if token.type == TOKEN_RETURN then return parse_return_statement(state) end_if
    if token.type == TOKEN_IF then return parse_if_statement(state) end_if
    if token.type == TOKEN_WHILE then return parse_while_statement(state) end_if
    if token.type == TOKEN_TYPE_NUMERIC then return parse_variable_declaration(state) end_if
    if token.type == TOKEN_TYPE_STRING then return parse_variable_declaration(state) end_if
    if token.type == TOKEN_IDENTIFIER then return parse_assignment(state) end_if
    
    print "Parser error at line "_function

function parse_block(state, end_token_type)
    list statements = list()
    
    while 1 == 1
        Token token = current_token(state)
        
        if token.type == TOKEN_EOF then
            break
        end_if
        
        if token.type == end_token_type then
            break
        end_if
        
        ASTNode stmt = parse_statement(state)
        mlp_list_add(statements, stmt)
    end
    
    Token block_token = current_token(state)
    ASTNode block_node = make_ast_node(AST_BLOCK, "", block_token.line, block_token.column)
    block_node.children = statements
    return block_node
end_function

-- =============================================================================
-- TOP-LEVEL PARSER
-- =============================================================================

function parse(tokens)
    ParserState state = make_parser_state(tokens)
    ASTNode root = parse_block(state, TOKEN_EOF)
    root.node_type = AST_PROGRAM
    return root
end_function

function ast_to_string(node, indent)
    String result = ""
    
    -- Add indentation
    Numeric i = 0
    while i < indent
        result = result + "  "
        i = i + 1
    end
    
    -- Node type
    if node.node_type == AST_PROGRAM then result = result + "PROGRAM" end_if
    if node.node_type == AST_FUNCTION then result = result + "FUNCTION " + node.value end_if
    if node.node_type == AST_VARIABLE_DECL then result = result + "VAR_DECL " + node.value end_if
    if node.node_type == AST_ASSIGNMENT then result = result + "ASSIGN " + node.value end_if
    if node.node_type == AST_IF_STMT then result = result + "IF" end_if
    if node.node_type == AST_WHILE_STMT then result = result + "WHILE" end_if
    if node.node_type == AST_RETURN_STMT then result = result + "RETURN" end_if
    if node.node_type == AST_BLOCK then result = result + "BLOCK" end_if
    if node.node_type == AST_BINARY_OP then result = result + "BINARY_OP " + node.value end_if
    if node.node_type == AST_UNARY_OP then result = result + "UNARY_OP " + node.value end_if
    if node.node_type == AST_CALL then result = result + "CALL " + node.value end_if
    if node.node_type == AST_IDENTIFIER then result = result + "ID " + node.value end_if
    if node.node_type == AST_NUMBER then result = result + "NUM " + node.value end_if
    if node.node_type == AST_STRING then result = result + "STR " + node.value end_if
    if node.node_type == AST_IMPORT then result = result + "IMPORT " + node.value end_if
    if node.node_type == AST_PRINT then result = result + "PRINT" end_if
    
    result = result + "\n"
    
    -- Children
    Numeric child_count = mlp_list_length(node.children)
    Numeric j = 0
    while j < child_count
        ASTNode child = mlp_list_get(node.children, j)
        result = result + ast_to_string(child, indent + 1)
        j = j + 1
    end
    
    return result
end_function
-- END IMPORT: lexer.mlp

-- =============================================================================
-- CODEGEN STATE
-- =============================================================================

struct CodegenState then
    String output
    Numeric indent_level
    Numeric temp_counter
    Numeric label_counter
    list string_literals
end_struct

-- =============================================================================
-- FACTORY FUNCTIONS
-- =============================================================================

function make_codegen_state()
    CodegenState state
    state.output = ""
    state.indent_level = 0
    state.temp_counter = 0
    state.label_counter = 0
    state.string_literals = list()
    return state
end_function

-- =============================================================================
-- HELPER FUNCTIONS
-- =============================================================================

function indent_string(level)
    String result = ""
    Numeric i = 0
    while i < level
        result = result + "    "
        i = i + 1
    end
    return result
end_function

function emit_line(state, line)
    String indented = indent_string(state.indent_level) + line + "\n"
    state.output = state.output + indented
    return state
end_function

function emit_raw(state, text)
    state.output = state.output + text
    return state
end_function

function generate_temp_var(state)
    String temp = "_t" + mlp_numeric_to_string(state.temp_counter)
    state.temp_counter = state.temp_counter + 1
    return temp
end_function

function generate_label(state, prefix)
    String label = prefix + "_" + mlp_numeric_to_string(state.label_counter)
    state.label_counter = state.label_counter + 1
    return label
end_function

function register_string_literal(state, str_value)
    String label = "str_" + mlp_numeric_to_string(mlp_list_length(state.string_literals))
    mlp_list_add(state.string_literals, str_value)
    return label
end_function

-- =============================================================================
-- TYPE CONVERSION
-- =============================================================================

function mlp_type_to_c_type(mlp_type)
    if mlp_string_equals(mlp_type, "Numeric") then
        return "int64_t"
    end_if
    if mlp_string_equals(mlp_type, "String") then
        return "char*"
    end_if
    if mlp_string_equals(mlp_type, "i32") then
        return "int32_t"
    end_if
    if mlp_string_equals(mlp_type, "i64") then
        return "int64_t"
    end_if
    if mlp_string_equals(mlp_type, "f64") then
        return "double"
    end_if
    if mlp_string_equals(mlp_type, "list") then
        return "void*"
    end_if
    return "void*"
end_function

-- =============================================================================
-- EXPRESSION CODEGEN
-- =============================================================================

function codegen_expression(state, node)
    Numeric node_type = node.node_type
    
    -- Literal values
    if node_type == AST_NUMBER then
        return codegen_number(state, node)
    end_if
    
    if node_type == AST_STRING then
        return codegen_string(state, node)
    end_if
    
    if node_type == AST_IDENTIFIER then
        return codegen_identifier(state, node)
    end_if
    
    -- Binary operations
    if node_type == AST_BINARY_OP then
        return codegen_binary_op(state, node)
    end_if
    
    -- Unary operations
    if node_type == AST_UNARY_OP then
        return codegen_unary_op(state, node)
    end_if
    
    -- Function call
    if node_type == AST_CALL then
        return codegen_call(state, node)
    end_if
    
    return state
end_function

function codegen_number(state, node)
    state = emit_raw(state, node.value)
    return state
end_function

function codegen_string(state, node)
    String label = register_string_literal(state, node.value)
    state = emit_raw(state, label)
    return state
end_function

function codegen_identifier(state, node)
    state = emit_raw(state, node.value)
    return state
end_function

function codegen_binary_op(state, node)
    String op = node.value
    ASTNode left = mlp_list_get(node.children, 0)
    ASTNode right = mlp_list_get(node.children, 1)
    
    state = emit_raw(state, "(")
    state = codegen_expression(state, left)
    state = emit_raw(state, " " + op + " ")
    state = codegen_expression(state, right)
    state = emit_raw(state, ")")
    
    return state
end_function

function codegen_unary_op(state, node)
    String op = node.value
    ASTNode operand = mlp_list_get(node.children, 0)
    
    state = emit_raw(state, op)
    state = codegen_expression(state, operand)
    
    return state
end_function

function codegen_call(state, node)
    String func_name = node.value
    list args = node.children
    
    state = emit_raw(state, func_name + "(")
    
    Numeric i = 0
    Numeric argc = mlp_list_length(args)
    while i < argc
        ASTNode arg = mlp_list_get(args, i)
        state = codegen_expression(state, arg)
        
        if i < argc - 1 then
            state = emit_raw(state, ", ")
        end_if
        
        i = i + 1
    end
    
    state = emit_raw(state, ")")
    return state
end_function

-- =============================================================================
-- STATEMENT CODEGEN
-- =============================================================================

function codegen_statement(state, node)
    Numeric node_type = node.node_type
    
    if node_type == AST_VARIABLE_DECL then
        return codegen_variable_decl(state, node)
    end_if
    
    if node_type == AST_ASSIGNMENT then
        return codegen_assignment(state, node)
    end_if
    
    if node_type == AST_IF_STMT then
        return codegen_if_statement(state, node)
    end_if
    
    if node_type == AST_WHILE_STMT then
        return codegen_while_statement(state, node)
    end_if
    
    if node_type == AST_RETURN_STMT then
        return codegen_return_statement(state, node)
    end_if
    
    if node_type == AST_PRINT then
        return codegen_print_statement(state, node)
    end_if
    
    if node_type == AST_CALL then
        state = emit_line(state, "")
        state = codegen_expression(state, node)
        state = emit_raw(state, ";\n")
        return state
    end_if
    
    if node_type == AST_BLOCK then
        return codegen_block(state, node)
    end_if
    
    return state
end_function

function codegen_variable_decl(state, node)
    String var_name = node.value
    ASTNode init_node = mlp_list_get(node.children, 0)
    
    state = emit_line(state, "int64_t " + var_name + " = ")
    state = codegen_expression(state, init_node)
    state = emit_raw(state, ";\n")
    
    return state
end_function

function codegen_assignment(state, node)
    String var_name = node.value
    ASTNode value_node = mlp_list_get(node.children, 0)
    
    state = emit_line(state, var_name + " = ")
    state = codegen_expression(state, value_node)
    state = emit_raw(state, ";\n")
    
    return state
end_function

function codegen_if_statement(state, node)
    ASTNode condition = mlp_list_get(node.children, 0)
    ASTNode then_block = mlp_list_get(node.children, 1)
    
    state = emit_line(state, "if (")
    state = codegen_expression(state, condition)
    state = emit_raw(state, ") {\n")
    
    state.indent_level = state.indent_level + 1
    state = codegen_statement(state, then_block)
    state.indent_level = state.indent_level - 1
    
    -- Check for else block
    Numeric child_count = mlp_list_length(node.children)
    if child_count > 2 then
        ASTNode else_block = mlp_list_get(node.children, 2)
        state = emit_line(state, "} else {\n")
        
        state.indent_level = state.indent_level + 1
        state = codegen_statement(state, else_block)
        state.indent_level = state.indent_level - 1
    end_if
    
    state = emit_line(state, "}\n")
    return state
end_function

function codegen_while_statement(state, node)
    ASTNode condition = mlp_list_get(node.children, 0)
    ASTNode body = mlp_list_get(node.children, 1)
    
    state = emit_line(state, "while (")
    state = codegen_expression(state, condition)
    state = emit_raw(state, ") {\n")
    
    state.indent_level = state.indent_level + 1
    state = codegen_statement(state, body)
    state.indent_level = state.indent_level - 1
    
    state = emit_line(state, "}\n")
    return state
end_function

function codegen_return_statement(state, node)
    Numeric child_count = mlp_list_length(node.children)
    
    if child_count > 0 then
        ASTNode return_value = mlp_list_get(node.children, 0)
        state = emit_line(state, "return ")
        state = codegen_expression(state, return_value)
        state = emit_raw(state, ";\n")
    else
        state = emit_line(state, "return;\n")
    end_if
    
    return state
end_function

function codegen_print_statement(state, node)
    ASTNode arg = mlp_list_get(node.children, 0)
    
    state = emit_line(state, "printf(\"%lld\\n\", (long long)")
    state = codegen_expression(state, arg)
    state = emit_raw(state, ");\n")
    
    return state
end_function

function codegen_block(state, node)
    Numeric i = 0
    Numeric stmt_count = mlp_list_length(node.children)
    
    while i < stmt_count
        ASTNode stmt = mlp_list_get(node.children, i)
        state = codegen_statement(state, stmt)
        i = i + 1
    end
    
    return state
end_function

-- =============================================================================
-- FUNCTION & STRUCT CODEGEN
-- =============================================================================

function codegen_function(state, node)
    String func_name = node.value
    list children = node.children
    
    -- Get parameters (first n-1 children are params, last is body)
    Numeric child_count = mlp_list_length(children)
    Numeric param_count = child_count - 1
    
    -- Function signature
    state = emit_line(state, "int64_t " + func_name + "(")
    
    -- Parameters
    Numeric i = 0
    while i < param_count
        ASTNode param = mlp_list_get(children, i)
        state = emit_raw(state, "int64_t " + param.value)
        
        if i < param_count - 1 then
            state = emit_raw(state, ", ")
        end_if
        
        i = i + 1
    end
    
    state = emit_raw(state, ") {\n")
    
    -- Function body
    state.indent_level = state.indent_level + 1
    ASTNode body = mlp_list_get(children, param_count)
    state = codegen_statement(state, body)
    state.indent_level = state.indent_level - 1
    
    state = emit_line(state, "}\n")
    return state
end_function

function codegen_struct(state, node)
    String struct_name = node.value
    list fields = node.children
    
    state = emit_line(state, "typedef struct {\n")
    state.indent_level = state.indent_level + 1
    
    Numeric i = 0
    Numeric field_count = mlp_list_length(fields)
    while i < field_count
        ASTNode field = mlp_list_get(fields, i)
        state = emit_line(state, "int64_t " + field.value + ";\n")
        i = i + 1
    end
    
    state.indent_level = state.indent_level - 1
    state = emit_line(state, "} " + struct_name + ";\n")
    
    return state
end_function

function codegen_import(state, node)
    String module_name = node.value
    state = emit_line(state, "// import: " + module_name + "\n")
    return state
end_function

-- =============================================================================
-- TOP-LEVEL CODEGEN
-- =============================================================================

function codegen_program(state, node)
    list children = node.children
    
    -- Generate C header
    state = emit_line(state, "// Generated by MLP Stage2 Compiler\n")
    state = emit_line(state, "#include <stdio.h>\n")
    state = emit_line(state, "#include <stdint.h>\n")
    state = emit_line(state, "#include <stdlib.h>\n")
    state = emit_line(state, "\n")
    
    -- Process all top-level declarations
    Numeric i = 0
    Numeric decl_count = mlp_list_length(children)
    
    while i < decl_count
        ASTNode child = mlp_list_get(children, i)
        Numeric child_type = child.node_type
        
        if child_type == AST_IMPORT then
            state = codegen_import(state, child)
        end_if
        
        if child_type == AST_STRUCT then
            state = codegen_struct(state, child)
        end_if
        
        if child_type == AST_FUNCTION then
            state = codegen_function(state, child)
        end_if
        
        i = i + 1
    end
    
    -- Generate string literals section
    state = codegen_string_literals(state)
    
    return state
end_function

function codegen_string_literals(state)
    Numeric lit_count = mlp_list_length(state.string_literals)
    
    if lit_count > 0 then
        state = emit_line(state, "// String literals\n")
        
        Numeric i = 0
        while i < lit_count
            String value = mlp_list_get(state.string_literals, i)
            String label = "str_" + mlp_numeric_to_string(i)
            state = emit_line(state, "static const char " + label + "[] = \"" + value + "\";\n")
            i = i + 1
        end
        
        state = emit_line(state, "\n")
    end_if
    
    return state
end_function

-- =============================================================================
-- MAIN CODEGEN ENTRY POINT
-- =============================================================================

function codegen(ast_root)
    CodegenState state = make_codegen_state()
    
    if ast_root.node_type == AST_PROGRAM then
        state = codegen_program(state, ast_root)
    end_if
    
    return state.output
end_function

function codegen_ast_to_c(ast_root)
    return codegen(ast_root)
end_function
-- END IMPORT: lexer.mlp

-- =============================================================================
-- GENERIC TYPES SUPPORT
-- =============================================================================

struct GenericInstance then
    String base_name
    list type_params
    String concrete_name
end_struct

struct GenericState then
    list instances
    Numeric instance_counter
end_struct

function make_generic_state()
    GenericState state
    state.instances = list()
    state.instance_counter = 0
    return state
end_function

-- Generate concrete type name: List<i64> → List_i64
function generate_generic_concrete_name(base_name, type_params)
    String result = base_name
    Numeric i = 0
    while i < mlp_list_length(type_params)
        String type_param = mlp_list_get(type_params, i)
        result = result + "_" + type_param
        i = i + 1
    end
    return result
end_function

-- Register generic instance
function register_generic_instance(gen_state, base_name, type_params)
    String concrete_name = generate_generic_concrete_name(base_name, type_params)
    
    -- Check if already registered
    Numeric i = 0
    while i < mlp_list_length(gen_state.instances)
        GenericInstance inst = mlp_list_get(gen_state.instances, i)
        if mlp_string_equals(inst.concrete_name, concrete_name) then
            return concrete_name
        end_if
        i = i + 1
    end
    
    -- Create new instance
    GenericInstance inst
    inst.base_name = base_name
    inst.type_params = type_params
    inst.concrete_name = concrete_name
    mlp_list_add(gen_state.instances, inst)
    
    return concrete_name
end_function

-- =============================================================================
-- GENERIC FUNCTION CODEGEN
-- =============================================================================

function codegen_generic_function(state, node, type_params)
    -- Extract function details
    String func_name = node.name
    list params = node.parameters
    String return_type = node.return_type
    
    -- Generate concrete function name
    String concrete_name = generate_generic_concrete_name(func_name, type_params)
    
    -- Convert generic types to concrete types
    String c_return_type = mlp_type_to_c_type(return_type)
    
    -- Function signature
    String sig = c_return_type + " " + concrete_name + "("
    
    -- Parameters
    Numeric i = 0
    while i < mlp_list_length(params)
        ASTNode param = mlp_list_get(params, i)
        String param_type = param.type_name
        String c_param_type = mlp_type_to_c_type(param_type)
        sig = sig + c_param_type + " " + param.name
        if i < mlp_list_length(params) - 1 then
            sig = sig + ", "
        end_if
        i = i + 1
    end
    
    sig = sig + ") {"
    state = emit_line(state, sig)
    
    -- Function body
    state.indent_level = state.indent_level + 1
    state = codegen_statement(state, node.body)
    state.indent_level = state.indent_level - 1
    
    state = emit_line(state, "}")
    state = emit_line(state, "")
    
    return state
end_function

-- =============================================================================
-- CLOSURE/LAMBDA SUPPORT
-- =============================================================================

struct ClosureData then
    String closure_name
    list captured_vars
    Numeric param_count
    ASTNode body
end_struct

struct ClosureState then
    list closures
    Numeric closure_counter
end_struct

function make_closure_state()
    ClosureState state
    state.closures = list()
    state.closure_counter = 0
    return state
end_function

-- Generate closure struct definition
function codegen_closure_struct(state, closure_data)
    String struct_name = closure_data.closure_name + "_env"
    
    state = emit_line(state, "// Closure environment: " + closure_data.closure_name)
    state = emit_line(state, "struct " + struct_name + " {")
    state.indent_level = state.indent_level + 1
    
    -- Function pointer
    state = emit_line(state, "int64_t (*func_ptr)(struct " + struct_name + "*, int64_t);")
    
    -- Captured variables
    Numeric i = 0
    while i < mlp_list_length(closure_data.captured_vars)
        String var_name = mlp_list_get(closure_data.captured_vars, i)
        state = emit_line(state, "int64_t " + var_name + ";")
        i = i + 1
    end
    
    state.indent_level = state.indent_level - 1
    state = emit_line(state, "};")
    state = emit_line(state, "")
    
    return state
end_function

-- Generate closure function implementation
function codegen_closure_function(state, closure_data)
    String func_name = closure_data.closure_name + "_impl"
    String struct_name = closure_data.closure_name + "_env"
    
    -- Function signature: int64_t func_impl(struct env* env, params...)
    String sig = "int64_t " + func_name + "(struct " + struct_name + "* __env"
    
    -- Add parameters
    Numeric i = 0
    while i < closure_data.param_count
        sig = sig + ", int64_t __p" + mlp_numeric_to_string(i)
        i = i + 1
    end
    sig = sig + ") {"
    
    state = emit_line(state, sig)
    state.indent_level = state.indent_level + 1
    
    -- Load captured variables from environment
    i = 0
    while i < mlp_list_length(closure_data.captured_vars)
        String var_name = mlp_list_get(closure_data.captured_vars, i)
        state = emit_line(state, "int64_t " + var_name + " = __env->" + var_name + ";")
        i = i + 1
    end
    
    -- Generate body
    state = codegen_statement(state, closure_data.body)
    
    state.indent_level = state.indent_level - 1
    state = emit_line(state, "}")
    state = emit_line(state, "")
    
    return state
end_function

-- Generate closure creation code
function codegen_lambda_expression(state, node)
    String closure_name = "__lambda_" + mlp_numeric_to_string(state.label_counter)
    state.label_counter = state.label_counter + 1
    
    -- Create closure data
    ClosureData closure_data
    closure_data.closure_name = closure_name
    closure_data.captured_vars = node.captured_vars
    closure_data.param_count = mlp_list_length(node.parameters)
    closure_data.body = node.body
    
    -- Allocate closure on heap
    String struct_name = closure_name + "_env"
    state = emit_line(state, "// Allocate closure")
    state = emit_line(state, "struct " + struct_name + "* " + closure_name + " = ")
    state = emit_line(state, "    malloc(sizeof(struct " + struct_name + "));")
    
    -- Initialize function pointer
    state = emit_line(state, closure_name + "->func_ptr = " + closure_name + "_impl;")
    
    -- Capture variables
    Numeric i = 0
    while i < mlp_list_length(closure_data.captured_vars)
        String var_name = mlp_list_get(closure_data.captured_vars, i)
        state = emit_line(state, closure_name + "->" + var_name + " = " + var_name + ";")
        i = i + 1
    end
    
    return state
end_function

-- Generate closure call
function codegen_lambda_call(state, closure_var, arguments)
    state = emit_line(state, "// Call closure")
    String call_expr = closure_var + "->func_ptr(" + closure_var
    
    -- Add arguments
    Numeric i = 0
    while i < mlp_list_length(arguments)
        ASTNode arg = mlp_list_get(arguments, i)
        state = codegen_expression(state, arg)
        call_expr = call_expr + ", " + state.last_expr_result
        i = i + 1
    end
    
    call_expr = call_expr + ")"
    state = emit_line(state, call_expr + ";")
    
    return state
end_function

-- =============================================================================
-- PATTERN MATCHING CODEGEN
-- =============================================================================

struct PatternCase then
    ASTNode pattern
    ASTNode body
end_struct

-- Generate pattern match as nested if-else
function codegen_pattern_match(state, node)
    ASTNode target = node.target
    list cases = node.cases
    
    -- Evaluate target expression
    state = emit_line(state, "// Pattern match")
    state = codegen_expression(state, target)
    String target_var = generate_temp_var(state)
    state = emit_line(state, "int64_t " + target_var + " = " + state.last_expr_result + ";")
    
    -- Generate cases
    Numeric i = 0
    while i < mlp_list_length(cases)
        PatternCase pattern_case = mlp_list_get(cases, i)
        
        if i == 0 then
            state = emit_line(state, "if (")
        else
            state = emit_line(state, "} else if (")
        end_if
        
        -- Pattern condition
        state = codegen_pattern_condition(state, target_var, pattern_case.pattern)
        state = emit_line(state, ") {")
        
        -- Case body
        state.indent_level = state.indent_level + 1
        state = codegen_statement(state, pattern_case.body)
        state.indent_level = state.indent_level - 1
        
        i = i + 1
    end
    
    -- Default case (exhaustiveness check should be done in type checker)
    state = emit_line(state, "} else {")
    state.indent_level = state.indent_level + 1
    state = emit_line(state, "fprintf(stderr, \"Pattern match failed\\n\");")
    state = emit_line(state, "exit(1);")
    state.indent_level = state.indent_level - 1
    state = emit_line(state, "}")
    
    return state
end_function

-- Generate pattern matching condition
function codegen_pattern_condition(state, target_var, pattern)
    String pattern_type = pattern.type
    
    if mlp_string_equals(pattern_type, "LITERAL") then
        -- Literal pattern: match value == literal
        state.last_expr_result = target_var + " == " + mlp_numeric_to_string(pattern.value)
        return state
    end_if
    
    if mlp_string_equals(pattern_type, "IDENTIFIER") then
        -- Variable binding: always matches
        String var_name = pattern.name
        state = emit_line(state, "int64_t " + var_name + " = " + target_var + ";")
        state.last_expr_result = "1"  -- Always true
        return state
    end_if
    
    if mlp_string_equals(pattern_type, "WILDCARD") then
        -- Wildcard: always matches
        state.last_expr_result = "1"
        return state
    end_if
    
    if mlp_string_equals(pattern_type, "CONSTRUCTOR") then
        -- Constructor pattern (for enums/ADTs)
        String constructor_name = pattern.constructor
        state.last_expr_result = target_var + ".tag == TAG_" + constructor_name
        return state
    end_if
    
    -- Default: no match
    state.last_expr_result = "0"
    return state
end_function

-- =============================================================================
-- ENTRY POINT FOR ADVANCED CODEGEN
-- =============================================================================

function codegen_advanced_features(state, node)
    String node_type = node.type
    
    if mlp_string_equals(node_type, "GENERIC_FUNCTION") then
        return codegen_generic_function(state, node, node.type_params)
    end_if
    
    if mlp_string_equals(node_type, "LAMBDA") then
        return codegen_lambda_expression(state, node)
    end_if
    
    if mlp_string_equals(node_type, "PATTERN_MATCH") then
        return codegen_pattern_match(state, node)
    end_if
    
    -- Fallback to basic codegen
    return codegen_statement(state, node)
end_function

-- =============================================================================
-- MAIN CODEGEN WITH ADVANCED FEATURES
-- =============================================================================

function codegen_with_advanced(ast_root)
    CodegenState state = make_codegen_state()
    GenericState gen_state = make_generic_state()
    ClosureState closure_state = make_closure_state()
    
    -- Generate C header
    state = emit_line(state, "// Generated by MLP Stage2 Compiler (Advanced)")
    state = emit_line(state, "#include <stdio.h>")
    state = emit_line(state, "#include <stdint.h>")
    state = emit_line(state, "#include <stdlib.h>")
    state = emit_line(state, "#include <string.h>")
    state = emit_line(state, "")
    
    -- Generate code for all nodes
    state = codegen_program(state, ast_root)
    
    return state.output
end_function

-- Export
function codegen_advanced(ast)
    return codegen_with_advanced(ast)
end_function
-- END IMPORT: lexer.mlp
-- BEGIN IMPORT: type_system.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Type System Module - Stage2 Self-Hosting Compiler
-- Generic types, constraints, and type checking
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC
-- Target: Generic type instantiation and validation

-- BEGIN IMPORT: lexer.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Lexer Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 lexer.mlp (635 → ~450 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- =============================================================================
-- TOKEN TYPES
-- =============================================================================

Numeric TOKEN_EOF = 0
Numeric TOKEN_IDENTIFIER = 1
Numeric TOKEN_NUMBER = 2
Numeric TOKEN_STRING = 3
Numeric TOKEN_INTERPOLATED_STRING = 4

-- Keywords (10-26)
Numeric TOKEN_FUNCTION = 10
Numeric TOKEN_END_FUNCTION = 11
Numeric TOKEN_STRUCT = 12
Numeric TOKEN_END_STRUCT = 13
Numeric TOKEN_IF = 14
Numeric TOKEN_THEN = 15
Numeric TOKEN_ELSE = 16
Numeric TOKEN_END_IF = 17
Numeric TOKEN_WHILE = 18
Numeric TOKEN_END = 19
Numeric TOKEN_RETURN = 20
Numeric TOKEN_IMPORT = 21
Numeric TOKEN_AS = 22
Numeric TOKEN_BREAK = 23
Numeric TOKEN_CONTINUE = 24
Numeric TOKEN_MODULE = 25
Numeric TOKEN_ENUM = 26

-- Types (30-34)
Numeric TOKEN_TYPE_STRING = 30
Numeric TOKEN_TYPE_NUMERIC = 31
Numeric TOKEN_TYPE_LIST = 32
Numeric TOKEN_TYPE_I32 = 33
Numeric TOKEN_TYPE_F64 = 34

-- Operators (40-54)
Numeric TOKEN_PLUS = 40
Numeric TOKEN_MINUS = 41
Numeric TOKEN_STAR = 42
Numeric TOKEN_DIV = 43
Numeric TOKEN_MOD = 44
Numeric TOKEN_ASSIGN = 45
Numeric TOKEN_EQ = 46
Numeric TOKEN_NEQ = 47
Numeric TOKEN_LT = 48
Numeric TOKEN_GT = 49
Numeric TOKEN_LTE = 50
Numeric TOKEN_GTE = 51
Numeric TOKEN_AND = 52
Numeric TOKEN_OR = 53
Numeric TOKEN_NOT = 54

-- Delimiters (60-67)
Numeric TOKEN_LEFT_PAREN = 60
Numeric TOKEN_RIGHT_PAREN = 61
Numeric TOKEN_LEFT_BRACKET = 62
Numeric TOKEN_RIGHT_BRACKET = 63
Numeric TOKEN_COMMA = 64
Numeric TOKEN_SEMICOLON = 65
Numeric TOKEN_DOT = 66
Numeric TOKEN_COLON = 67

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct Token then
    Numeric type
    String value
    Numeric line
    Numeric column
    list interpolation_parts
end_struct

struct LexerState then
    String source_code
    Numeric position
    Numeric length
    Numeric line
    Numeric column
    Numeric eof_reached
end_struct

-- =============================================================================
-- FACTORY & STATE MANAGEMENT
-- =============================================================================

function make_token(token_type, value, line, column)
    Token token
    token.type = token_type
    token.value = value
    token.line = line
    token.column = column
    token.interpolation_parts = list()
    return token
end_function

function lexer_state_create(source_code)
    LexerState state
    state.source_code = source_code
    state.position = 0
    state.length = string_length(source_code)
    state.line = 1
    state.column = 1
    state.eof_reached = 0
    return state
end_function

-- =============================================================================
-- CHARACTER HELPERS & CLASSIFICATION
-- =============================================================================

function char_at(state, offset)
    Numeric pos = state.position + offset
    if pos >= state.length then return "" end_if
    return string_substring(state.source_code, pos, 1)
end_function

function current_char(state)
    return char_at(state, 0)
end_function

function peek_char(state, offset)
    return char_at(state, offset)
end_function

function is_eof(state)
    if state.position >= state.length then return 1 end_if
    return 0
end_function

function advance(state)
    if is_eof(state) == 1 then return state end_if
    String ch = current_char(state)
    if ch == "\n" then
        state.line = state.line + 1
        state.column = 1
    else
        state.column = state.column + 1
    end_if
    state.position = state.position + 1
    return state
end_function

function is_digit(ch)
    if ch >= "0" then if ch <= "9" then return 1 end_if end_if
    return 0
end_function

function is_alpha(ch)
    if ch >= "a" then if ch <= "z" then return 1 end_if end_if
    if ch >= "A" then if ch <= "Z" then return 1 end_if end_if
    if ch == "_" then return 1 end_if
    return 0
end_function

function is_alnum(ch)
    if is_alpha(ch) == 1 then return 1 end_if
    if is_digit(ch) == 1 then return 1 end_if
    return 0
end_function

function is_whitespace(ch)
    if ch == " " then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- =============================================================================
-- WHITESPACE, COMMENTS & NUMBER/STRING READING
-- =============================================================================

function skip_whitespace(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_whitespace(ch) == 0 then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_line_comment(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == "\n" then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_whitespace_and_comments(state)
    while is_eof(state) == 0
        state = skip_whitespace(state)
        if is_eof(state) == 1 then break end_if
        String ch = current_char(state)
        String next = peek_char(state, 1)
        if ch == "-" then
            if next == "-" then
                state = skip_line_comment(state)
            else
                break
            end_if
        else
            break
        end_if
    end
    return state
end_function

function read_number(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_digit(ch) == 0 then
            if ch == "," then
                state = advance(state)
                continue
            end_if
            break
        end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    value = string_replace(value, ",", ".")
    Token token
    token = make_token(TOKEN_NUMBER, value, state.line, state.column)
    return token
end_function

function read_string(state, delimiter)
    state = advance(state)
    Numeric start = state.position
    list parts = list()
    String current_part = ""
    
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == delimiter then
            if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
            state = advance(state)
            break
        end_if
        if ch == "{" then
            if string_length(current_part) > 0 then
                mlp_list_add(parts, current_part)
                current_part = ""
            end_if
            state = advance(state)
            Numeric var_start = state.position
            while is_eof(state) == 0
                String vch = current_char(state)
                if vch == "}" then break end_if
                state = advance(state)
            end
            Numeric var_len = state.position - var_start
            String var_name = string_substring(state.source_code, var_start, var_len)
            mlp_list_add(parts, "{" + var_name + "}")
            state = advance(state)
        else
            current_part = current_part + ch
            state = advance(state)
        end_if
    end
    if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
    Numeric part_count = mlp_list_length(parts)
    if part_count > 1 then
        Token token
        token = make_token(TOKEN_INTERPOLATED_STRING, "", state.line, state.column)
        token.interpolation_parts = parts
        return token
    end_if
    if part_count == 1 then
        String final_value = mlp_list_get(parts, 0)
        return make_token(TOKEN_STRING, final_value, state.line, state.column)
    end_if
    return make_token(TOKEN_STRING, "", state.line, state.column)
end_function

-- =============================================================================
-- IDENTIFIER, OPERATOR READING & MAIN TOKENIZER
-- =============================================================================

function keyword_type(value)
    if value == "function" then return TOKEN_FUNCTION end_if
    if value == "end_function" then return TOKEN_END_FUNCTION end_if
    if value == "struct" then return TOKEN_STRUCT end_if
    if value == "end_struct" then return TOKEN_END_STRUCT end_if
    if value == "if" then return TOKEN_IF end_if
    if value == "then" then return TOKEN_THEN end_if
    if value == "else" then return TOKEN_ELSE end_if
    if value == "end_if" then return TOKEN_END_IF end_if
    if value == "while" then return TOKEN_WHILE end_if
    if value == "end" then return TOKEN_END end_if
    if value == "return" then return TOKEN_RETURN end_if
    if value == "import" then return TOKEN_IMPORT end_if
    if value == "as" then return TOKEN_AS end_if
    if value == "break" then return TOKEN_BREAK end_if
    if value == "continue" then return TOKEN_CONTINUE end_if
    if value == "module" then return TOKEN_MODULE end_if
    if value == "enum" then return TOKEN_ENUM end_if
    if value == "String" then return TOKEN_TYPE_STRING end_if
    if value == "Numeric" then return TOKEN_TYPE_NUMERIC end_if
    if value == "list" then return TOKEN_TYPE_LIST end_if
    if value == "i32" then return TOKEN_TYPE_I32 end_if
    if value == "f64" then return TOKEN_TYPE_F64 end_if
    return TOKEN_IDENTIFIER
end_function

function read_identifier(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_alnum(ch) == 0 then break end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    Numeric type = keyword_type(value)
    Token token
    token = make_token(type, value, state.line, state.column)
    return token
end_function

function read_operator(state)
    String ch = current_char(state)
    String next = peek_char(state, 1)
    
    -- Two-character operators
    if ch == "=" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_EQ, "==", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_ASSIGN, "=", state.line, state.column)
    end_if
    
    if ch == "!" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_NEQ, "!=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_NOT, "!", state.line, state.column)
    end_if
    
    if ch == "<" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_LTE, "<=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_LT, "<", state.line, state.column)
    end_if
    
    if ch == ">" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_GTE, ">=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_GT, ">", state.line, state.column)
    end_if
    
    if ch == "&" then
        if next == "&" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_AND, "&&", state.line, state.column)
        end_if
    end_if
    
    if ch == "|" then
        if next == "|" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_OR, "||", state.line, state.column)
        end_if
    end_if
    
    -- Single-character operators
    if ch == "+" then state = advance(state)
        return make_token(TOKEN_PLUS, "+", state.line, state.column) end_if
    if ch == "-" then state = advance(state)
        return make_token(TOKEN_MINUS, "-", state.line, state.column) end_if
    if ch == "*" then state = advance(state)
        return make_token(TOKEN_STAR, "*", state.line, state.column) end_if
    if ch == "/" then state = advance(state)
        return make_token(TOKEN_DIV, "/", state.line, state.column) end_if
    if ch == "%" then state = advance(state)
        return make_token(TOKEN_MOD, "%", state.line, state.column) end_if
    
    -- Delimiters
    if ch == "(" then state = advance(state)
        return make_token(TOKEN_LEFT_PAREN, "(", state.line, state.column) end_if
    if ch == ")" then state = advance(state)
        return make_token(TOKEN_RIGHT_PAREN, ")", state.line, state.column) end_if
    if ch == "[" then state = advance(state)
        return make_token(TOKEN_LEFT_BRACKET, "[", state.line, state.column) end_if
    if ch == "]" then state = advance(state)
        return make_token(TOKEN_RIGHT_BRACKET, "]", state.line, state.column) end_if
    if ch == "," then state = advance(state)
        return make_token(TOKEN_COMMA, ",", state.line, state.column) end_if
    if ch == ";" then state = advance(state)
        return make_token(TOKEN_SEMICOLON, ";", state.line, state.column) end_if
    if ch == "." then state = advance(state)
        return make_token(TOKEN_DOT, ".", state.line, state.column) end_if
    if ch == ":" then state = advance(state)
        return make_token(TOKEN_COLON, ":", state.line, state.column) end_if
    
    -- Unknown character
    state = advance(state)
    return make_token(TOKEN_EOF, "", state.line, state.column)
end_function

function get_next_token(state)
    if state.eof_reached == 1 then
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    state = skip_whitespace_and_comments(state)
    if is_eof(state) == 1 then
        state.eof_reached = 1
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    String ch = current_char(state)
    if is_digit(ch) == 1 then return read_number(state) end_if
    if ch == "\"" then return read_string(state, "\"") end_if
    if ch == "'" then return read_string(state, "'") end_if
    if is_alpha(ch) == 1 then return read_identifier(state) end_if
    return read_operator(state)
end_function

function tokenize(source_code)
    LexerState state
    state = lexer_state_create(source_code)
    list tokens = list()
    while state.eof_reached == 0
        Token token
        token = get_next_token(state)
        mlp_list_add(tokens, token)
        if token.type == TOKEN_EOF then break end_if
    end
    return tokens
end_function

-- =============================================================================
-- UTILITY: Token to String (for debugging)
-- =============================================================================

function token_type_name(type)
    if type == TOKEN_EOF then return "EOF" end_if
    if type == TOKEN_IDENTIFIER then return "IDENTIFIER" end_if
    if type == TOKEN_NUMBER then return "NUMBER" end_if
    if type == TOKEN_STRING then return "STRING" end_if
    if type == TOKEN_FUNCTION then return "FUNCTION" end_if
    return "UNKNOWN"
end_function
-- END IMPORT: lexer.mlp
-- BEGIN IMPORT: parser.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Parser Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 parser.mlp (661 → <500 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- BEGIN IMPORT: lexer.mlp
-- lang: en-US
-- syntax: mlp
-- MLP Lexer Module - Stage2 Self-Hosting Compiler
-- Optimized from p7 lexer.mlp (635 → ~450 lines)
-- 6 Esas Compliant: MODULAR (<500), STATELESS, STRUCT+FUNC

-- =============================================================================
-- TOKEN TYPES
-- =============================================================================

Numeric TOKEN_EOF = 0
Numeric TOKEN_IDENTIFIER = 1
Numeric TOKEN_NUMBER = 2
Numeric TOKEN_STRING = 3
Numeric TOKEN_INTERPOLATED_STRING = 4

-- Keywords (10-26)
Numeric TOKEN_FUNCTION = 10
Numeric TOKEN_END_FUNCTION = 11
Numeric TOKEN_STRUCT = 12
Numeric TOKEN_END_STRUCT = 13
Numeric TOKEN_IF = 14
Numeric TOKEN_THEN = 15
Numeric TOKEN_ELSE = 16
Numeric TOKEN_END_IF = 17
Numeric TOKEN_WHILE = 18
Numeric TOKEN_END = 19
Numeric TOKEN_RETURN = 20
Numeric TOKEN_IMPORT = 21
Numeric TOKEN_AS = 22
Numeric TOKEN_BREAK = 23
Numeric TOKEN_CONTINUE = 24
Numeric TOKEN_MODULE = 25
Numeric TOKEN_ENUM = 26

-- Types (30-34)
Numeric TOKEN_TYPE_STRING = 30
Numeric TOKEN_TYPE_NUMERIC = 31
Numeric TOKEN_TYPE_LIST = 32
Numeric TOKEN_TYPE_I32 = 33
Numeric TOKEN_TYPE_F64 = 34

-- Operators (40-54)
Numeric TOKEN_PLUS = 40
Numeric TOKEN_MINUS = 41
Numeric TOKEN_STAR = 42
Numeric TOKEN_DIV = 43
Numeric TOKEN_MOD = 44
Numeric TOKEN_ASSIGN = 45
Numeric TOKEN_EQ = 46
Numeric TOKEN_NEQ = 47
Numeric TOKEN_LT = 48
Numeric TOKEN_GT = 49
Numeric TOKEN_LTE = 50
Numeric TOKEN_GTE = 51
Numeric TOKEN_AND = 52
Numeric TOKEN_OR = 53
Numeric TOKEN_NOT = 54

-- Delimiters (60-67)
Numeric TOKEN_LEFT_PAREN = 60
Numeric TOKEN_RIGHT_PAREN = 61
Numeric TOKEN_LEFT_BRACKET = 62
Numeric TOKEN_RIGHT_BRACKET = 63
Numeric TOKEN_COMMA = 64
Numeric TOKEN_SEMICOLON = 65
Numeric TOKEN_DOT = 66
Numeric TOKEN_COLON = 67

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct Token then
    Numeric type
    String value
    Numeric line
    Numeric column
    list interpolation_parts
end_struct

struct LexerState then
    String source_code
    Numeric position
    Numeric length
    Numeric line
    Numeric column
    Numeric eof_reached
end_struct

-- =============================================================================
-- FACTORY & STATE MANAGEMENT
-- =============================================================================

function make_token(token_type, value, line, column)
    Token token
    token.type = token_type
    token.value = value
    token.line = line
    token.column = column
    token.interpolation_parts = list()
    return token
end_function

function lexer_state_create(source_code)
    LexerState state
    state.source_code = source_code
    state.position = 0
    state.length = string_length(source_code)
    state.line = 1
    state.column = 1
    state.eof_reached = 0
    return state
end_function

-- =============================================================================
-- CHARACTER HELPERS & CLASSIFICATION
-- =============================================================================

function char_at(state, offset)
    Numeric pos = state.position + offset
    if pos >= state.length then return "" end_if
    return string_substring(state.source_code, pos, 1)
end_function

function current_char(state)
    return char_at(state, 0)
end_function

function peek_char(state, offset)
    return char_at(state, offset)
end_function

function is_eof(state)
    if state.position >= state.length then return 1 end_if
    return 0
end_function

function advance(state)
    if is_eof(state) == 1 then return state end_if
    String ch = current_char(state)
    if ch == "\n" then
        state.line = state.line + 1
        state.column = 1
    else
        state.column = state.column + 1
    end_if
    state.position = state.position + 1
    return state
end_function

function is_digit(ch)
    if ch >= "0" then if ch <= "9" then return 1 end_if end_if
    return 0
end_function

function is_alpha(ch)
    if ch >= "a" then if ch <= "z" then return 1 end_if end_if
    if ch >= "A" then if ch <= "Z" then return 1 end_if end_if
    if ch == "_" then return 1 end_if
    return 0
end_function

function is_alnum(ch)
    if is_alpha(ch) == 1 then return 1 end_if
    if is_digit(ch) == 1 then return 1 end_if
    return 0
end_function

function is_whitespace(ch)
    if ch == " " then return 1 end_if
    if ch == "\t" then return 1 end_if
    if ch == "\n" then return 1 end_if
    if ch == "\r" then return 1 end_if
    return 0
end_function

-- =============================================================================
-- WHITESPACE, COMMENTS & NUMBER/STRING READING
-- =============================================================================

function skip_whitespace(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_whitespace(ch) == 0 then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_line_comment(state)
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == "\n" then break end_if
        state = advance(state)
    end
    return state
end_function

function skip_whitespace_and_comments(state)
    while is_eof(state) == 0
        state = skip_whitespace(state)
        if is_eof(state) == 1 then break end_if
        String ch = current_char(state)
        String next = peek_char(state, 1)
        if ch == "-" then
            if next == "-" then
                state = skip_line_comment(state)
            else
                break
            end_if
        else
            break
        end_if
    end
    return state
end_function

function read_number(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_digit(ch) == 0 then
            if ch == "," then
                state = advance(state)
                continue
            end_if
            break
        end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    value = string_replace(value, ",", ".")
    Token token
    token = make_token(TOKEN_NUMBER, value, state.line, state.column)
    return token
end_function

function read_string(state, delimiter)
    state = advance(state)
    Numeric start = state.position
    list parts = list()
    String current_part = ""
    
    while is_eof(state) == 0
        String ch = current_char(state)
        if ch == delimiter then
            if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
            state = advance(state)
            break
        end_if
        if ch == "{" then
            if string_length(current_part) > 0 then
                mlp_list_add(parts, current_part)
                current_part = ""
            end_if
            state = advance(state)
            Numeric var_start = state.position
            while is_eof(state) == 0
                String vch = current_char(state)
                if vch == "}" then break end_if
                state = advance(state)
            end
            Numeric var_len = state.position - var_start
            String var_name = string_substring(state.source_code, var_start, var_len)
            mlp_list_add(parts, "{" + var_name + "}")
            state = advance(state)
        else
            current_part = current_part + ch
            state = advance(state)
        end_if
    end
    if string_length(current_part) > 0 then mlp_list_add(parts, current_part) end_if
    Numeric part_count = mlp_list_length(parts)
    if part_count > 1 then
        Token token
        token = make_token(TOKEN_INTERPOLATED_STRING, "", state.line, state.column)
        token.interpolation_parts = parts
        return token
    end_if
    if part_count == 1 then
        String final_value = mlp_list_get(parts, 0)
        return make_token(TOKEN_STRING, final_value, state.line, state.column)
    end_if
    return make_token(TOKEN_STRING, "", state.line, state.column)
end_function

-- =============================================================================
-- IDENTIFIER, OPERATOR READING & MAIN TOKENIZER
-- =============================================================================

function keyword_type(value)
    if value == "function" then return TOKEN_FUNCTION end_if
    if value == "end_function" then return TOKEN_END_FUNCTION end_if
    if value == "struct" then return TOKEN_STRUCT end_if
    if value == "end_struct" then return TOKEN_END_STRUCT end_if
    if value == "if" then return TOKEN_IF end_if
    if value == "then" then return TOKEN_THEN end_if
    if value == "else" then return TOKEN_ELSE end_if
    if value == "end_if" then return TOKEN_END_IF end_if
    if value == "while" then return TOKEN_WHILE end_if
    if value == "end" then return TOKEN_END end_if
    if value == "return" then return TOKEN_RETURN end_if
    if value == "import" then return TOKEN_IMPORT end_if
    if value == "as" then return TOKEN_AS end_if
    if value == "break" then return TOKEN_BREAK end_if
    if value == "continue" then return TOKEN_CONTINUE end_if
    if value == "module" then return TOKEN_MODULE end_if
    if value == "enum" then return TOKEN_ENUM end_if
    if value == "String" then return TOKEN_TYPE_STRING end_if
    if value == "Numeric" then return TOKEN_TYPE_NUMERIC end_if
    if value == "list" then return TOKEN_TYPE_LIST end_if
    if value == "i32" then return TOKEN_TYPE_I32 end_if
    if value == "f64" then return TOKEN_TYPE_F64 end_if
    return TOKEN_IDENTIFIER
end_function

function read_identifier(state)
    Numeric start = state.position
    while is_eof(state) == 0
        String ch = current_char(state)
        if is_alnum(ch) == 0 then break end_if
        state = advance(state)
    end
    Numeric len = state.position - start
    String value = string_substring(state.source_code, start, len)
    Numeric type = keyword_type(value)
    Token token
    token = make_token(type, value, state.line, state.column)
    return token
end_function

function read_operator(state)
    String ch = current_char(state)
    String next = peek_char(state, 1)
    
    -- Two-character operators
    if ch == "=" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_EQ, "==", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_ASSIGN, "=", state.line, state.column)
    end_if
    
    if ch == "!" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_NEQ, "!=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_NOT, "!", state.line, state.column)
    end_if
    
    if ch == "<" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_LTE, "<=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_LT, "<", state.line, state.column)
    end_if
    
    if ch == ">" then
        if next == "=" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_GTE, ">=", state.line, state.column)
        end_if
        state = advance(state)
        return make_token(TOKEN_GT, ">", state.line, state.column)
    end_if
    
    if ch == "&" then
        if next == "&" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_AND, "&&", state.line, state.column)
        end_if
    end_if
    
    if ch == "|" then
        if next == "|" then
            state = advance(state)
            state = advance(state)
            return make_token(TOKEN_OR, "||", state.line, state.column)
        end_if
    end_if
    
    -- Single-character operators
    if ch == "+" then state = advance(state)
        return make_token(TOKEN_PLUS, "+", state.line, state.column) end_if
    if ch == "-" then state = advance(state)
        return make_token(TOKEN_MINUS, "-", state.line, state.column) end_if
    if ch == "*" then state = advance(state)
        return make_token(TOKEN_STAR, "*", state.line, state.column) end_if
    if ch == "/" then state = advance(state)
        return make_token(TOKEN_DIV, "/", state.line, state.column) end_if
    if ch == "%" then state = advance(state)
        return make_token(TOKEN_MOD, "%", state.line, state.column) end_if
    
    -- Delimiters
    if ch == "(" then state = advance(state)
        return make_token(TOKEN_LEFT_PAREN, "(", state.line, state.column) end_if
    if ch == ")" then state = advance(state)
        return make_token(TOKEN_RIGHT_PAREN, ")", state.line, state.column) end_if
    if ch == "[" then state = advance(state)
        return make_token(TOKEN_LEFT_BRACKET, "[", state.line, state.column) end_if
    if ch == "]" then state = advance(state)
        return make_token(TOKEN_RIGHT_BRACKET, "]", state.line, state.column) end_if
    if ch == "," then state = advance(state)
        return make_token(TOKEN_COMMA, ",", state.line, state.column) end_if
    if ch == ";" then state = advance(state)
        return make_token(TOKEN_SEMICOLON, ";", state.line, state.column) end_if
    if ch == "." then state = advance(state)
        return make_token(TOKEN_DOT, ".", state.line, state.column) end_if
    if ch == ":" then state = advance(state)
        return make_token(TOKEN_COLON, ":", state.line, state.column) end_if
    
    -- Unknown character
    state = advance(state)
    return make_token(TOKEN_EOF, "", state.line, state.column)
end_function

function get_next_token(state)
    if state.eof_reached == 1 then
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    state = skip_whitespace_and_comments(state)
    if is_eof(state) == 1 then
        state.eof_reached = 1
        return make_token(TOKEN_EOF, "", state.line, state.column)
    end_if
    String ch = current_char(state)
    if is_digit(ch) == 1 then return read_number(state) end_if
    if ch == "\"" then return read_string(state, "\"") end_if
    if ch == "'" then return read_string(state, "'") end_if
    if is_alpha(ch) == 1 then return read_identifier(state) end_if
    return read_operator(state)
end_function

function tokenize(source_code)
    LexerState state
    state = lexer_state_create(source_code)
    list tokens = list()
    while state.eof_reached == 0
        Token token
        token = get_next_token(state)
        mlp_list_add(tokens, token)
        if token.type == TOKEN_EOF then break end_if
    end
    return tokens
end_function

-- =============================================================================
-- UTILITY: Token to String (for debugging)
-- =============================================================================

function token_type_name(type)
    if type == TOKEN_EOF then return "EOF" end_if
    if type == TOKEN_IDENTIFIER then return "IDENTIFIER" end_if
    if type == TOKEN_NUMBER then return "NUMBER" end_if
    if type == TOKEN_STRING then return "STRING" end_if
    if type == TOKEN_FUNCTION then return "FUNCTION" end_if
    return "UNKNOWN"
end_function
-- END IMPORT: lexer.mlp

-- =============================================================================
-- AST NODE TYPES
-- =============================================================================

Numeric AST_PROGRAM = 0
Numeric AST_FUNCTION = 1
Numeric AST_STRUCT = 2
Numeric AST_VARIABLE_DECL = 3
Numeric AST_ASSIGNMENT = 4
Numeric AST_IF_STMT = 5
Numeric AST_WHILE_STMT = 6
Numeric AST_RETURN_STMT = 7
Numeric AST_BLOCK = 8
Numeric AST_BINARY_OP = 9
Numeric AST_UNARY_OP = 10
Numeric AST_CALL = 11
Numeric AST_IDENTIFIER = 12
Numeric AST_NUMBER = 13
Numeric AST_STRING = 14
Numeric AST_IMPORT = 15
Numeric AST_PRINT = 16

-- =============================================================================
-- DATA STRUCTURES
-- =============================================================================

struct ASTNode then
    Numeric node_type
    String value
    list children
    Numeric line
    Numeric column
end_struct

struct ParserState then
    list tokens
    Numeric position
    Numeric scope_level
end_struct

-- =============================================================================
-- FACTORY FUNCTIONS
-- =============================================================================

function make_ast_node(node_type, value, line, column)
    ASTNode node
    node.node_type = node_type
    node.value = value
    node.children = list()
    node.line = line
    node.column = column
    return node
end_function

function make_parser_state(tokens)
    ParserState state
    state.tokens = tokens
    state.position = 0
    state.scope_level = 0
    return state
end_function

-- =============================================================================
-- TOKEN NAVIGATION
-- =============================================================================

function current_token(state)
    Numeric pos = state.position
    Numeric length = mlp_list_length(state.tokens)
    if pos >= length then
        Token eof_token = make_token(TOKEN_EOF, "", 0, 0)
        return eof_token
    end_if
    return mlp_list_get(state.tokens, pos)
end_function

function peek_token(state, offset)
    Numeric pos = state.position + offset
    Numeric length = mlp_list_length(state.tokens)
    if pos >= length then
        Token eof_token = make_token(TOKEN_EOF, "", 0, 0)
        return eof_token
    end_if
    return mlp_list_get(state.tokens, pos)
end_function

function advance_token(state)
    state.position = state.position + 1
    return state
end_function

function expect_token(state, expected_type)
    Token token = current_token(state)
    if token.type != expected_type then
        print "Parser error at line " print token.line
    end_if
    return advance_token(state)
end_function

function match_token(state, token_type)
    Token token = current_token(state)
    if token.type == token_type then
        return 1
    end_if
    return 0
end_function

-- =============================================================================
-- PRECEDENCE TABLE
-- =============================================================================

function get_precedence(token_type)
    if token_type == TOKEN_OR then return 10 end_if
    if token_type == TOKEN_AND then return 20 end_if
    if token_type == TOKEN_EQ then return 30 end_if
    if token_type == TOKEN_NEQ then return 30 end_if
    if token_type == TOKEN_LT then return 40 end_if
    if token_type == TOKEN_GT then return 40 end_if
    if token_type == TOKEN_LTE then return 40 end_if
    if token_type == TOKEN_GTE then return 40 end_if
    if token_type == TOKEN_PLUS then return 50 end_if
    if token_type == TOKEN_MINUS then return 50 end_if
    if token_type == TOKEN_STAR then return 60 end_if
    if token_type == TOKEN_DIV then return 60 end_if
    if token_type == TOKEN_MOD then return 60 end_if
    return 0
end_function

-- =============================================================================
-- EXPRESSION PARSING (PRATT STYLE)
-- =============================================================================

function parse_primary(state)
    Token token = current_token(state)
    
    -- Number literal
    if token.type == TOKEN_NUMBER then
        ASTNode node = make_ast_node(AST_NUMBER, token.value, token.line, token.column)
        state = advance_token(state)
        return node
    end_if
    
    -- String literal
    if token.type == TOKEN_STRING then
        ASTNode node = make_ast_node(AST_STRING, token.value, token.line, token.column)
        state = advance_token(state)
        return node
    end_if
    
    -- Identifier or function call
    if token.type == TOKEN_IDENTIFIER then
        ASTNode node = make_ast_node(AST_IDENTIFIER, token.value, token.line, token.column)
        state = advance_token(state)
        
        -- Check for function call
        Token next_token = current_token(state)
        if next_token.type == TOKEN_LEFT_PAREN then
            node.node_type = AST_CALL
            state = advance_token(state)
            
            -- Parse arguments
            if match_token(state, TOKEN_RIGHT_PAREN) == 0 then
                while 1 == 1
                    ASTNode arg = parse_expression(state, 0)
                    mlp_list_add(node.children, arg)
                    
                    Token comma_token = current_token(state)
                    if comma_token.type != TOKEN_COMMA then
                        break
                    end_if
                    state = advance_token(state)
                end
            end_if
            
            state = expect_token(state, TOKEN_RIGHT_PAREN)
        end_if
        
        return node
    end_if
    
    -- Parenthesized expression
    if token.type == TOKEN_LEFT_PAREN then
        state = advance_token(state)
        ASTNode expr = parse_expression(state, 0)
        state = expect_token(state, TOKEN_RIGHT_PAREN)
        return expr
    end_if
    
    -- Unary operators
    if token.type == TOKEN_MINUS then
        ASTNode node = make_ast_node(AST_UNARY_OP, "-", token.line, token.column)
        state = advance_token(state)
        mlp_list_add(node.children, parse_primary(state))
        return node
    end_if
    
    if token.type == TOKEN_NOT then
        ASTNode node = make_ast_node(AST_UNARY_OP, "!", token.line, token.column)
        state = advance_token(state)
        mlp_list_add(node.children, parse_primary(state))
        return node
    end_if
    
    -- Error
    print "Parser error at line " print token.line
    ASTNode error_node = make_ast_node(AST_NUMBER, "0", token.line, token.column)
    return error_node
end_function

function parse_expression(state, min_precedence)
    ASTNode left = parse_primary(state)
    
    while 1 == 1
        Token op_token = current_token(state)
        Numeric op_prec = get_precedence(op_token.type)
        
        if op_prec == 0 then break end_if
        if op_prec < min_precedence then break end_if
        
        String op_value = op_token.value
        Numeric op_line = op_token.line
        Numeric op_col = op_token.column
        state = advance_token(state)
        
        ASTNode right = parse_expression(state, op_prec + 1)
        
        ASTNode binary_node = make_ast_node(AST_BINARY_OP, op_value, op_line, op_col)
        mlp_list_add(binary_node.children, left)
        mlp_list_add(binary_node.children, right)
        
        left = binary_node
    end
    
    return left
end_function

-- =============================================================================
-- STATEMENT PARSING
-- =============================================================================

function parse_import_statement(state)
    Token import_token = current_token(state)
    state = expect_token(state, TOKEN_IMPORT)
    
    Token module_token = current_token(state)
    state = expect_token(state, TOKEN_STRING)
    
    ASTNode node = make_ast_node(AST_IMPORT, module_token.value, import_token.line, import_token.column)
    return node
end_function

function parse_print_statement(state)
    Token print_token = current_token(state)
    state = expect_token(state, TOKEN_PRINT)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_PRINT, "", print_token.line, print_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_return_statement(state)
    Token return_token = current_token(state)
    state = expect_token(state, TOKEN_RETURN)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_RETURN_STMT, "", return_token.line, return_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_variable_declaration(state)
    Token type_token = current_token(state)
    state = advance_token(state)
    
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    
    ASTNode node = make_ast_node(AST_VARIABLE_DECL, name_token.value, type_token.line, type_token.column)
    node.value = type_token.value + ":" + name_token.value
    
    -- Check for assignment
    Token assign_token = current_token(state)
    if assign_token.type == TOKEN_ASSIGN then
        state = advance_token(state)
        ASTNode init_expr = parse_expression(state, 0)
        mlp_list_add(node.children, init_expr)
    end_if
    
    return node
end_function

function parse_assignment(state)
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    state = expect_token(state, TOKEN_ASSIGN)
    
    ASTNode expr = parse_expression(state, 0)
    ASTNode node = make_ast_node(AST_ASSIGNMENT, name_token.value, name_token.line, name_token.column)
    mlp_list_add(node.children, expr)
    return node
end_function

function parse_if_statement(state)
    Token if_token = current_token(state)
    state = expect_token(state, TOKEN_IF)
    
    ASTNode condition = parse_expression(state, 0)
    state = expect_token(state, TOKEN_THEN)
    
    ASTNode then_block = parse_block(state, TOKEN_END_IF)
    
    ASTNode node = make_ast_node(AST_IF_STMT, "", if_token.line, if_token.column)
    mlp_list_add(node.children, condition)
    mlp_list_add(node.children, then_block)
    
    -- Check for else
    Token next_token = current_token(state)
    if next_token.type == TOKEN_ELSE then
        state = advance_token(state)
        ASTNode else_block = parse_block(state, TOKEN_END_IF)
        mlp_list_add(node.children, else_block)
    end_if
    
    state = expect_token(state, TOKEN_END_IF)
    return node
end_function

function parse_while_statement(state)
    Token while_token = current_token(state)
    state = expect_token(state, TOKEN_WHILE)
    
    ASTNode condition = parse_expression(state, 0)
    ASTNode body = parse_block(state, TOKEN_END)
    
    state = expect_token(state, TOKEN_END)
    
    ASTNode node = make_ast_node(AST_WHILE_STMT, "", while_token.line, while_token.column)
    mlp_list_add(node.children, condition)
    mlp_list_add(node.children, body)
    return node
end_function

function parse_function_declaration(state)
    Token func_token = current_token(state)
    state = expect_token(state, TOKEN_FUNCTION)
    
    Token name_token = current_token(state)
    state = expect_token(state, TOKEN_IDENTIFIER)
    
    ASTNode node = make_ast_node(AST_FUNCTION, name_token.value, func_token.line, func_token.column)
    
    state = expect_token(state, TOKEN_LEFT_PAREN)
    
    -- Parse parameters
    if match_token(state, TOKEN_RIGHT_PAREN) == 0 then
        while 1 == 1
            Token param_name = current_token(state)
            state = expect_token(state, TOKEN_IDENTIFIER)
            
            ASTNode param_node = make_ast_node(AST_IDENTIFIER, param_name.value, param_name.line, param_name.column)
            mlp_list_add(node.children, param_node)
            
            Token comma_token = current_token(state)
            if comma_token.type != TOKEN_COMMA then
                break
            end_if
            state = advance_token(state)
        end
    end_if
    
    state = expect_token(state, TOKEN_RIGHT_PAREN)
    
    -- Parse function body
    ASTNode body = parse_block(state, TOKEN_END_FUNCTION)
    mlp_list_add(node.children, body)
    
    state = expect_token(state, TOKEN_END_FUNCTION)
    return node
end_function

function parse_statement(state)
    Token token = current_token(state)
    
    if token.type == TOKEN_IMPORT then
        return parse_import_statement(state)
    end_if
     return parse_import_statement(state) end_if
    if token.type == TOKEN_FUNCTION then return parse_function_declaration(state) end_if
    if token.type == TOKEN_PRINT then return parse_print_statement(state) end_if
    if token.type == TOKEN_RETURN then return parse_return_statement(state) end_if
    if token.type == TOKEN_IF then return parse_if_statement(state) end_if
    if token.type == TOKEN_WHILE then return parse_while_statement(state) end_if
    if token.type == TOKEN_TYPE_NUMERIC then return parse_variable_declaration(state) end_if
    if token.type == TOKEN_TYPE_STRING then return parse_variable_declaration(state) end_if
    if token.type == TOKEN_IDENTIFIER then return parse_assignment(state) end_if
    
    print "Parser error at line "_function

function parse_block(state, end_token_type)
    list statements = list()
    
    while 1 == 1
        Token token = current_token(state)
        
        if token.type == TOKEN_EOF then
            break
        end_if
        
        if token.type == end_token_type then
            break
        end_if
        
        ASTNode stmt = parse_statement(state)
        mlp_list_add(statements, stmt)
    end
    
    Token block_token = current_token(state)
    ASTNode block_node = make_ast_node(AST_BLOCK, "", block_token.line, block_token.column)
    block_node.children = statements
    return block_node
end_function

-- =============================================================================
-- TOP-LEVEL PARSER
-- =============================================================================

function parse(tokens)
    ParserState state = make_parser_state(tokens)
    ASTNode root = parse_block(state, TOKEN_EOF)
    root.node_type = AST_PROGRAM
    return root
end_function

function ast_to_string(node, indent)
    String result = ""
    
    -- Add indentation
    Numeric i = 0
    while i < indent
        result = result + "  "
        i = i + 1
    end
    
    -- Node type
    if node.node_type == AST_PROGRAM then result = result + "PROGRAM" end_if
    if node.node_type == AST_FUNCTION then result = result + "FUNCTION " + node.value end_if
    if node.node_type == AST_VARIABLE_DECL then result = result + "VAR_DECL " + node.value end_if
    if node.node_type == AST_ASSIGNMENT then result = result + "ASSIGN " + node.value end_if
    if node.node_type == AST_IF_STMT then result = result + "IF" end_if
    if node.node_type == AST_WHILE_STMT then result = result + "WHILE" end_if
    if node.node_type == AST_RETURN_STMT then result = result + "RETURN" end_if
    if node.node_type == AST_BLOCK then result = result + "BLOCK" end_if
    if node.node_type == AST_BINARY_OP then result = result + "BINARY_OP " + node.value end_if
    if node.node_type == AST_UNARY_OP then result = result + "UNARY_OP " + node.value end_if
    if node.node_type == AST_CALL then result = result + "CALL " + node.value end_if
    if node.node_type == AST_IDENTIFIER then result = result + "ID " + node.value end_if
    if node.node_type == AST_NUMBER then result = result + "NUM " + node.value end_if
    if node.node_type == AST_STRING then result = result + "STR " + node.value end_if
    if node.node_type == AST_IMPORT then result = result + "IMPORT " + node.value end_if
    if node.node_type == AST_PRINT then result = result + "PRINT" end_if
    
    result = result + "\n"
    
    -- Children
    Numeric child_count = mlp_list_length(node.children)
    Numeric j = 0
    while j < child_count
        ASTNode child = mlp_list_get(node.children, j)
        result = result + ast_to_string(child, indent + 1)
        j = j + 1
    end
    
    return result
end_function
-- END IMPORT: lexer.mlp

-- =============================================================================
-- TYPE DEFINITIONS
-- =============================================================================

-- Basic type kinds
struct TypeKind then
    String name  -- "PRIMITIVE", "GENERIC", "STRUCT", "FUNCTION", "POINTER"
end_struct

-- Type representation
struct Type then
    String kind        -- TypeKind name
    String name        -- Type name: "Integer", "String", "List"
    list type_params   -- For generics: ["T"], ["K", "V"]
    list constraints   -- Generic constraints: ["T: Numeric"]
    Type return_type   -- For functions
    list param_types   -- For functions
    Boolean is_pointer
end_struct

-- Generic constraint (trait bound)
struct Constraint then
    String type_param  -- "T"
    String trait_name  -- "Numeric", "Comparable", "Printable"
end_struct

-- Generic instantiation record
struct GenericInstance then
    String base_type      -- "List", "HashMap"
    list type_args        -- ["Integer"], ["String", "Integer"]
    String concrete_name  -- "List_Integer", "HashMap_String_Integer"
    Type concrete_type    -- Instantiated type
end_struct

-- Type system state
struct TypeSystem then
    list primitive_types    -- Built-in types
    list generic_types      -- Generic type definitions
    list instances          -- Instantiated generics
    list struct_types       -- User-defined structs
    list function_types     -- Function signatures
    Numeric instance_counter
end_struct

-- =============================================================================
-- PRIMITIVE TYPES
-- =============================================================================

function make_primitive_type(name)
    Type t
    t.kind = "PRIMITIVE"
    t.name = name
    t.type_params = list()
    t.constraints = list()
    t.return_type = null
    t.param_types = list()
    t.is_pointer = false
    return t
end_function

function init_primitive_types()
    list primitives = list()
    mlp_list_append(primitives, make_primitive_type("Integer"))
    mlp_list_append(primitives, make_primitive_type("String"))
    mlp_list_append(primitives, make_primitive_type("Boolean"))
    mlp_list_append(primitives, make_primitive_type("Float"))
    mlp_list_append(primitives, make_primitive_type("Void"))
    mlp_list_append(primitives, make_primitive_type("Numeric"))
    return primitives
end_function

-- =============================================================================
-- TYPE SYSTEM INITIALIZATION
-- =============================================================================

function make_type_system()
    TypeSystem ts
    ts.primitive_types = init_primitive_types()
    ts.generic_types = list()
    ts.instances = list()
    ts.struct_types = list()
    ts.function_types = list()
    ts.instance_counter = 0
    return ts
end_function

-- =============================================================================
-- GENERIC TYPE OPERATIONS
-- =============================================================================

-- Create a generic type definition
function make_generic_type(name, type_params, constraints)
    Type t
    t.kind = "GENERIC"
    t.name = name
    t.type_params = type_params
    t.constraints = constraints
    t.return_type = null
    t.param_types = list()
    t.is_pointer = false
    return t
end_function

-- Generate concrete name from generic: List<Integer> → List_Integer
function generate_concrete_name(base_name, type_args)
    String result = base_name
    Numeric i = 0
    while i < mlp_list_length(type_args)
        Type arg = mlp_list_get(type_args, i)
        result = result + "_" + arg.name
        i = i + 1
    end
    return result
end_function

-- Check if generic instance already exists
function find_generic_instance(ts, base_name, type_args)
    Numeric i = 0
    while i < mlp_list_length(ts.instances)
        GenericInstance inst = mlp_list_get(ts.instances, i)
        if inst.base_type == base_name then
            -- Check if type_args match
            if mlp_list_length(inst.type_args) == mlp_list_length(type_args) then
                Boolean match = true
                Numeric j = 0
                while j < mlp_list_length(type_args)
                    Type arg1 = mlp_list_get(inst.type_args, j)
                    Type arg2 = mlp_list_get(type_args, j)
                    if arg1.name != arg2.name then
                        match = false
                    end
                    j = j + 1
                end
                if match then
                    return inst
                end
            end
        end
        i = i + 1
    end
    return null
end_function

-- Instantiate a generic type
function instantiate_generic(ts, base_name, type_args)
    -- Check if already instantiated
    GenericInstance existing = find_generic_instance(ts, base_name, type_args)
    if existing != null then
        return existing
    end
    
    -- Find generic type definition
    Type generic_type = null
    Numeric i = 0
    while i < mlp_list_length(ts.generic_types)
        Type t = mlp_list_get(ts.generic_types, i)
        if t.name == base_name then
            generic_type = t
        end
        i = i + 1
    end
    
    if generic_type == null then
        print("Error: Generic type not found: " + base_name)
        return null
    end
    
    -- Validate type arguments count
    Numeric expected = mlp_list_length(generic_type.type_params)
    Numeric provided = mlp_list_length(type_args)
    if expected != provided then
        print("Error: Generic " + base_name + " expects " + mlp_to_string(expected) + " type arguments, got " + mlp_to_string(provided))
        return null
    end
    
    -- Check constraints
    Boolean constraints_ok = check_constraints(generic_type.constraints, type_args)
    if not constraints_ok then
        return null
    end
    
    -- Create new instance
    GenericInstance inst
    inst.base_type = base_name
    inst.type_args = type_args
    inst.concrete_name = generate_concrete_name(base_name, type_args)
    
    -- Create concrete type
    Type concrete
    concrete.kind = "STRUCT"
    concrete.name = inst.concrete_name
    concrete.type_params = list()
    concrete.constraints = list()
    concrete.return_type = null
    concrete.param_types = list()
    concrete.is_pointer = false
    inst.concrete_type = concrete
    
    -- Register instance
    mlp_list_append(ts.instances, inst)
    ts.instance_counter = ts.instance_counter + 1
    
    return inst
end_function

-- =============================================================================
-- CONSTRAINT CHECKING
-- =============================================================================

-- Check if a type satisfies a constraint
function type_satisfies_constraint(type_arg, constraint)
    -- Built-in trait checks
    if constraint.trait_name == "Numeric" then
        if type_arg.name == "Integer" or type_arg.name == "Float" then
            return true
        end
        return false
    end
    
    if constraint.trait_name == "Comparable" then
        if type_arg.name == "Integer" or type_arg.name == "Float" or type_arg.name == "String" then
            return true
        end
        return false
    end
    
    if constraint.trait_name == "Printable" then
        -- All types are printable by default
        return true
    end
    
    -- Unknown trait - default to true for now
    return true
end_function

-- Check all constraints for generic instantiation
function check_constraints(constraints, type_args)
    Numeric i = 0
    while i < mlp_list_length(constraints)
        Constraint c = mlp_list_get(constraints, i)
        
        -- Find type argument for this constraint
        Numeric j = 0
        Boolean found = false
        while j < mlp_list_length(type_args)
            Type arg = mlp_list_get(type_args, j)
            -- Match type param name (simplified - assumes positional)
            if j == i then
                if not type_satisfies_constraint(arg, c) then
                    print("Error: Type " + arg.name + " does not satisfy constraint " + c.trait_name)
                    return false
                end
                found = true
            end
            j = j + 1
        end
        
        i = i + 1
    end
    return true
end_function

-- =============================================================================
-- TYPE CHECKING UTILITIES
-- =============================================================================

-- Check if two types are equal
function types_equal(t1, t2)
    if t1.name != t2.name then
        return false
    end
    if t1.kind != t2.kind then
        return false
    end
    -- Check generic parameters if any
    if mlp_list_length(t1.type_params) != mlp_list_length(t2.type_params) then
        return false
    end
    return true
end_function

-- Check if type is primitive
function is_primitive_type(ts, type_name)
    Numeric i = 0
    while i < mlp_list_length(ts.primitive_types)
        Type t = mlp_list_get(ts.primitive_types, i)
        if t.name == type_name then
            return true
        end
        i = i + 1
    end
    return false
end_function

-- Lookup type by name
function lookup_type(ts, type_name)
    -- Check primitives
    Numeric i = 0
    while i < mlp_list_length(ts.primitive_types)
        Type t = mlp_list_get(ts.primitive_types, i)
        if t.name == type_name then
            return t
        end
        i = i + 1
    end
    
    -- Check generic types
    i = 0
    while i < mlp_list_length(ts.generic_types)
        Type t = mlp_list_get(ts.generic_types, i)
        if t.name == type_name then
            return t
        end
        i = i + 1
    end
    
    -- Check struct types
    i = 0
    while i < mlp_list_length(ts.struct_types)
        Type t = mlp_list_get(ts.struct_types, i)
        if t.name == type_name then
            return t
        end
        i = i + 1
    end
    
    return null
end_function

-- =============================================================================
-- FUNCTION TYPE OPERATIONS
-- =============================================================================

-- Create function type
function make_function_type(return_type, param_types)
    Type t
    t.kind = "FUNCTION"
    t.name = "function"
    t.type_params = list()
    t.constraints = list()
    t.return_type = return_type
    t.param_types = param_types
    t.is_pointer = false
    return t
end_function

-- Register function type
function register_function_type(ts, func_name, return_type, param_types)
    Type func_type = make_function_type(return_type, param_types)
    mlp_list_append(ts.function_types, func_type)
    return func_type
end_function

-- =============================================================================
-- STRUCT TYPE OPERATIONS
-- =============================================================================

-- Create struct type
function make_struct_type(name)
    Type t
    t.kind = "STRUCT"
    t.name = name
    t.type_params = list()
    t.constraints = list()
    t.return_type = null
    t.param_types = list()
    t.is_pointer = false
    return t
end_function

-- Register struct type
function register_struct_type(ts, struct_name)
    Type struct_type = make_struct_type(struct_name)
    mlp_list_append(ts.struct_types, struct_type)
    return struct_type
end_function

-- =============================================================================
-- GENERIC REGISTRATION
-- =============================================================================

-- Register a generic type definition
function register_generic_type(ts, name, type_params, constraints)
    Type generic = make_generic_type(name, type_params, constraints)
    mlp_list_append(ts.generic_types, generic)
    return generic
end_function

-- =============================================================================
-- TYPE TO STRING (for debugging)
-- =============================================================================

function type_to_string(t)
    String result = t.name
    if mlp_list_length(t.type_params) > 0 then
        result = result + "<"
        Numeric i = 0
        while i < mlp_list_length(t.type_params)
            String param = mlp_list_get(t.type_params, i)
            if i > 0 then
                result = result + ", "
            end
            result = result + param
            i = i + 1
        end
        result = result + ">"
    end
    return result
end_function

-- =============================================================================
-- BUILT-IN GENERIC TYPES
-- =============================================================================

-- Initialize common generic types
function init_builtin_generics(ts)
    -- List<T>
    list list_params = list()
    mlp_list_append(list_params, "T")
    list list_constraints = list()
    register_generic_type(ts, "List", list_params, list_constraints)
    
    -- HashMap<K, V>
    list map_params = list()
    mlp_list_append(map_params, "K")
    mlp_list_append(map_params, "V")
    list map_constraints = list()
    register_generic_type(ts, "HashMap", map_params, map_constraints)
    
    -- Option<T>
    list option_params = list()
    mlp_list_append(option_params, "T")
    list option_constraints = list()
    register_generic_type(ts, "Option", option_params, option_constraints)
    
    -- Result<T, E>
    list result_params = list()
    mlp_list_append(result_params, "T")
    mlp_list_append(result_params, "E")
    list result_constraints = list()
    register_generic_type(ts, "Result", result_params, result_constraints)
    
    return ts
end_function

-- =============================================================================
-- MAIN API FUNCTIONS
-- =============================================================================

-- Initialize type system with built-in types
function init_type_system()
    TypeSystem ts = make_type_system()
    ts = init_builtin_generics(ts)
    return ts
end_function

-- Main entry point for type checking
function type_check(ast)
    TypeSystem ts = init_type_system()
    -- Type checking logic would go here
    -- For now, just return the type system
    return ts
end_function

-- Main entry point for generic instantiation
function instantiate_generics(ast)
    TypeSystem ts = init_type_system()
    -- Parse AST and instantiate all generic types
    -- This integrates with codegen_advanced.mlp
    return ts
end_function
-- END IMPORT: lexer.mlp

-- =============================================================================
-- COMPILER CONFIGURATION
-- =============================================================================

struct CompilerConfig then
    String input_file
    String output_file
    Boolean verbose
    Boolean type_check_enabled
    Boolean optimization_enabled
end_struct

function make_compiler_config()
    CompilerConfig config
    config.input_file = ""
    config.output_file = "output.c"
    config.verbose = false
    config.type_check_enabled = true
    config.optimization_enabled = false
    return config
end_function

-- =============================================================================
-- COMMAND LINE ARGUMENT PARSING
-- =============================================================================

function parse_arguments(args, config)
    Numeric i = 1  -- Skip argv[0] (program name)
    while i < mlp_list_length(args)
        String arg = mlp_list_get(args, i)
        
        if mlp_string_equals(arg, "-o") then
            i = i + 1
            if i < mlp_list_length(args) then
                config.output_file = mlp_list_get(args, i)
            end_if
        else if mlp_string_equals(arg, "-v") then
            config.verbose = true
        else if mlp_string_equals(arg, "--no-type-check") then
            config.type_check_enabled = false
        else if mlp_string_equals(arg, "-O") then
            config.optimization_enabled = true
        else
            -- Input file (first non-flag argument)
            if mlp_string_equals(config.input_file, "") then
                config.input_file = arg
            end_if
        end_if
        
        i = i + 1
    end
    
    return config
end_function

-- =============================================================================
-- FILE I/O OPERATIONS
-- =============================================================================

function read_source_file(filename)
    -- Read file content
    String content = mlp_file_read(filename)
    if mlp_string_equals(content, "") then
        mlp_print("Error: Cannot read file: ")
        mlp_print(filename)
        mlp_print("\n")
        return ""
    end_if
    return content
end_function

function write_output_file(filename, content)
    Numeric result = mlp_file_write(filename, content)
    if result == 0 then
        mlp_print("Error: Cannot write file: ")
        mlp_print(filename)
        mlp_print("\n")
        return false
    end_if
    return true
end_function

-- =============================================================================
-- COMPILER PIPELINE
-- =============================================================================

function compile_stage1_lexing(source_code, config)
    if config.verbose then
        mlp_print("[STAGE 1] Lexical Analysis...\n")
    end_if
    
    -- Initialize lexer state
    LexerState lexer = make_lexer_state(source_code)
    
    -- Tokenize source code
    list tokens = tokenize(lexer)
    
    if config.verbose then
        Numeric token_count = mlp_list_length(tokens)
        mlp_print("  Tokens: ")
        mlp_print(mlp_numeric_to_string(token_count))
        mlp_print("\n")
    end_if
    
    return tokens
end_function

function compile_stage2_parsing(tokens, config)
    if config.verbose then
        mlp_print("[STAGE 2] Syntax Analysis...\n")
    end_if
    
    -- Initialize parser state
    ParserState parser = make_parser_state(tokens)
    
    -- Parse tokens into AST
    ASTNode ast = parse_program(parser)
    
    if config.verbose then
        mlp_print("  AST nodes: ")
        Numeric node_count = mlp_list_length(ast.children)
        mlp_print(mlp_numeric_to_string(node_count))
        mlp_print("\n")
    end_if
    
    return ast
end_function

function compile_stage3_type_checking(ast, config)
    if config.verbose then
        mlp_print("[STAGE 3] Type Checking...\n")
    end_if
    
    if not config.type_check_enabled then
        if config.verbose then
            mlp_print("  Type checking disabled\n")
        end_if
        return true
    end_if
    
    -- Initialize type system
    TypeSystem ts = make_type_system()
    
    -- Type check AST
    Boolean type_check_result = type_check_program(ts, ast)
    
    if not type_check_result then
        mlp_print("Error: Type checking failed\n")
        return false
    end_if
    
    if config.verbose then
        mlp_print("  Type checking: OK\n")
    end_if
    
    return true
end_function

function compile_stage4_codegen(ast, config)
    if config.verbose then
        mlp_print("[STAGE 4] Code Generation...\n")
    end_if
    
    -- Initialize codegen state
    CodegenState codegen = make_codegen_state()
    
    -- Generate C code from AST
    CodegenState result = codegen_program(codegen, ast)
    
    -- Get generated code
    String c_code = result.output
    
    if config.verbose then
        Numeric code_length = mlp_string_length(c_code)
        mlp_print("  Generated C code: ")
        mlp_print(mlp_numeric_to_string(code_length))
        mlp_print(" bytes\n")
    end_if
    
    return c_code
end_function

-- =============================================================================
-- MAIN COMPILER FUNCTION
-- =============================================================================

function compile_mlp_file(config)
    -- Validate input
    if mlp_string_equals(config.input_file, "") then
        mlp_print("Error: No input file specified\n")
        mlp_print("Usage: melpc <input.mlp> [-o output.c] [-v] [--no-type-check] [-O]\n")
        return 1
    end_if
    
    if config.verbose then
        mlp_print("MLP Stage2 Compiler\n")
        mlp_print("===================\n")
        mlp_print("Input:  ")
        mlp_print(config.input_file)
        mlp_print("\n")
        mlp_print("Output: ")
        mlp_print(config.output_file)
        mlp_print("\n\n")
    end_if
    
    -- Read source file
    String source_code = read_source_file(config.input_file)
    if mlp_string_equals(source_code, "") then
        return 1
    end_if
    
    -- Stage 1: Lexical Analysis
    list tokens = compile_stage1_lexing(source_code, config)
    if mlp_list_length(tokens) == 0 then
        mlp_print("Error: Lexing failed\n")
        return 1
    end_if
    
    -- Stage 2: Syntax Analysis
    ASTNode ast = compile_stage2_parsing(tokens, config)
    if ast == null then
        mlp_print("Error: Parsing failed\n")
        return 1
    end_if
    
    -- Stage 3: Type Checking
    Boolean type_check_ok = compile_stage3_type_checking(ast, config)
    if not type_check_ok then
        return 1
    end_if
    
    -- Stage 4: Code Generation
    String c_code = compile_stage4_codegen(ast, config)
    if mlp_string_equals(c_code, "") then
        mlp_print("Error: Code generation failed\n")
        return 1
    end_if
    
    -- Write output file
    Boolean write_ok = write_output_file(config.output_file, c_code)
    if not write_ok then
        return 1
    end_if
    
    if config.verbose then
        mlp_print("\n[SUCCESS] Compilation complete!\n")
    end_if
    
    return 0
end_function

-- =============================================================================
-- ENTRY POINT
-- =============================================================================

function main()
    -- Get command line arguments
    list args = mlp_get_args()
    
    -- Parse arguments
    CompilerConfig config = make_compiler_config()
    config = parse_arguments(args, config)
    
    -- Compile
    Numeric exit_code = compile_mlp_file(config)
    
    -- Exit
    mlp_exit(exit_code)
end_function

-- Run main
main()
