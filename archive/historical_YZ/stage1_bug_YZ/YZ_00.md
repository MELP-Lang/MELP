# YZ_00: BUG-001 KÃ¶k Sebep Analizi Raporu

**Tarih:** 20 AralÄ±k 2025  
**GÃ¶revli:** YZ_00  
**Ãœst AkÄ±l:** YZ_ÃœA_04  
**Durum:** âœ… TAMAMLANDI

---

## ğŸ“‹ Ã–zet

**BUG-001: Fonksiyon body boÅŸ Ã¼retiliyor** sorunun kÃ¶k sebebi bulundu:

ğŸ¯ **KÃ¶k Sebep:** `const` deklarasyonlarÄ± iÃ§in tip inferencing (tip Ã§Ä±karÄ±mÄ±) desteklenmiyor.

---

## ğŸ› Bug DoÄŸrulama

### Test DosyasÄ±
```mlp
function main() as int {
    const x = 88
    return(x)
}
```

**Dosya:** `tests/manual/bug_001_const_return.mlp`

### Derleme Sonucu
```bash
$ ./compiler/stage0/modules/functions/functions_compiler \
    tests/manual/bug_001_const_return.mlp \
    temp/bug_001.s

2: error [Parser]: Expected 'function' keyword
âœ… Compiled tests/manual/bug_001_const_return.mlp -> temp/bug_001.s
   ğŸ“Š 1 functions, 0 structs, 0 enums
```

### Ãœretilen Assembly
```asm
.att_syntax
.data

.text

# Function: main
.global main
main:
    pushq %rbp
    movq %rsp, %rbp

.Lmain_return:
    movq %rbp, %rsp
    popq %rbp
    ret
```

**DoÄŸrulama:** âœ… Function body boÅŸ, `const x = 88` ve `return(x)` iÃ§in kod Ã¼retilmemiÅŸ.

---

## ğŸ” KÃ¶k Sebep Analizi (Derinlemesine)

### 1. Call Stack Ä°zleme

```
functions_parser.c:398: statement_parse() Ã§aÄŸrÄ±sÄ±
    â†“
statement_parser.c:603: TOKEN_CONST tespit edildi
    â†“
statement_parser.c:607: variable_parse_declaration(lexer, tok) Ã§aÄŸrÄ±sÄ±
    â†“
variable_parser.c:24: TOKEN_CONST tespit edildi
variable_parser.c:26: is_const = true
variable_parser.c:28: actual_type_token = lexer_next_token(lexer)
    â†’ Okunan: TOKEN_IDENTIFIER "x" (TÄ°P DEÄÄ°L!)
    â†“
variable_parser.c:34-50: Tip kontrolÃ¼
    â†’ TOKEN_NUMERIC? âŒ
    â†’ TOKEN_STRING_TYPE? âŒ
    â†’ TOKEN_BOOLEAN? âŒ
    â†’ TOKEN_ARRAY? âŒ
    â†’ TOKEN_LIST? âŒ
    â†’ TOKEN_TUPLE? âŒ
    â†“
variable_parser.c:51: return NULL (Not a variable declaration)
    â†“
statement_parser.c:628: return NULL
    â†“
functions_parser.c:401: break (End of body)
```

### 1.5. Const MekanizmasÄ± Analizi

**AST Temsili:**
```c
// variable.h:59
typedef struct {
    char* name;
    VarType type;
    char* value;
    bool is_const;        // âœ… Const flag mevcut
    void* init_expr;      // âœ… Expression desteÄŸi var
    ...
} VariableDeclaration;
```

**Symbol Table:**
```c
// functions.h:45
typedef struct LocalVariable {
    char* name;
    int stack_offset;
    int is_const;         // âœ… YZ_121: Const flag
    int64_t const_value;  // âœ… YZ_121: Immediate value
    ...
} LocalVariable;
```

**Const Registration (functions_codegen.c:163-166):**
```c
if (decl->is_const && decl->value) {
    int64_t const_val = atoll(decl->value);
    function_set_var_const(func, decl->name, const_val);
}
```

**Const Optimization (functions.c:447-459):**
```c
void function_set_var_const(FunctionDeclaration* func, const char* name, int64_t value) {
    var->is_const = 1;
    var->const_value = value;
    func->local_var_count--;      // âœ… Stack'ten Ã§Ä±kar
    var->stack_offset = 0;        // âœ… Stack'te yer yok
}
```

**Return CodeGen (statement_codegen.c:591-609):**
```c
// Special case: simple variable reference
if (!expr->left && !expr->right && expr->value && !expr->is_literal) {
    // Check if variable is const
    if (var->is_const) {
        // Load immediate const value
        fprintf(output, "    movq $%ld, %%r8  # Load const %s\n", 
                const_val, expr->value);  // âœ… DOÄRU: Immediate value!
    } else {
        // Load from stack
        int offset = function_get_var_offset(func, expr->value);
        fprintf(output, "    movq %d(%%rbp), %%r8  # Load %s\n", 
                offset, expr->value);
    }
}
```

**âœ… Mevcut Const Stratejisi (DOÄRU):**
1. Const deÄŸiÅŸken **stack'te yer kaplamaz** (local_var_count--)
2. Return statement'ta **immediate value** kullanÄ±lÄ±r (`movq $88, %r8`)
3. Runtime'da const iÃ§in **KOD ÃœRETÄ°LMEZ** (sadece symbol table'da)

**âŒ Sorun:** Parse aÅŸamasÄ±nda `const x = 88` syntax'Ä± desteklenmiyor!

### 2. HatanÄ±n MekanizmasÄ±

**Kod:** `const x = 88`

**Beklenen DavranÄ±ÅŸ:**
- `const` keyword gÃ¶rÃ¼ldÃ¼ÄŸÃ¼nde, deÄŸerden tip Ã§Ä±karÄ±mÄ± yapÄ±lmalÄ±
- `88` sayÄ±sÄ±ndan â†’ `numeric` tipi
- Variable declaration baÅŸarÄ±lÄ± olmalÄ±

**GerÃ§ek DavranÄ±ÅŸ:**
- `const` keyword gÃ¶rÃ¼ldÃ¼kten sonra **mutlaka** bir tip keyword bekleniyor
- `x` identifier okunuyor, tip keyword deÄŸil
- `variable_parse_declaration` NULL dÃ¶ndÃ¼rÃ¼yor
- `statement_parse` NULL dÃ¶ndÃ¼rÃ¼yor
- Function body parsing sonlanÄ±yor

### 3. Kaynak Kod Konumu

**Dosya:** `compiler/stage0/modules/variable/variable_parser.c`  
**Fonksiyon:** `variable_parse_declaration`  
**SatÄ±rlar:** 24-51

```c
// YZ_CONST: Check if this is a const declaration
bool is_const = false;
Token* actual_type_token = type_token;

if (type_token->type == TOKEN_CONST) {
    is_const = true;
    // Read next token for the actual type
    actual_type_token = lexer_next_token(lexer);  // â† Burada "x" okunuyor
    if (!actual_type_token) {
        fprintf(stderr, "Error: Expected type after 'const'\n");
        return NULL;
    }
}

// Check for type keyword (actual_type_token is OWNED if is_const, BORROWED otherwise)
VarType base_type;
if (actual_type_token->type == TOKEN_NUMERIC) {
    base_type = VAR_NUMERIC;
} else if (actual_type_token->type == TOKEN_STRING_TYPE) {
    base_type = VAR_STRING;
} else if (actual_type_token->type == TOKEN_BOOLEAN) {
    base_type = VAR_BOOLEAN;
} else if (actual_type_token->type == TOKEN_ARRAY) {
    base_type = VAR_ARRAY;
} else if (actual_type_token->type == TOKEN_LIST) {
    base_type = VAR_LIST;
} else if (actual_type_token->type == TOKEN_TUPLE) {
    base_type = VAR_TUPLE;
} else {
    if (is_const) token_free(actual_type_token);
    return NULL;  // â† BUG: Tip inferencing yapÄ±lmÄ±yor!
}
```

**Sorun:** SatÄ±r 34-51 arasÄ± sadece **explicit tip** keyword'lerini kontrol ediyor. `const` iÃ§in implicit tip Ã§Ä±karÄ±mÄ± yok.

---

## ğŸ’¡ Ã–nerilen Ã‡Ã¶zÃ¼m

### Strateji

`const` keyword sonrasÄ±:
1. Bir sonraki token'Ä± oku
2. **EÄŸer tip keyword ise:** Mevcut akÄ±ÅŸÄ± kullan (`const numeric x = 88`)
3. **EÄŸer identifier ise:** 
   - Identifier'Ä± deÄŸiÅŸken adÄ± olarak sakla
   - `=` tokenini bekle
   - Value expression'Ä± parse et
   - Expression'dan tip Ã§Ä±kar (type inference)
   - Variable declaration oluÅŸtur

### Pseudo-code

```c
if (type_token->type == TOKEN_CONST) {
    is_const = true;
    actual_type_token = lexer_next_token(lexer);
    
    // Check if next token is a type or identifier
    if (actual_type_token->type == TOKEN_IDENTIFIER) {
        // TYPE INFERENCE PATH
        // This is "const x = value" syntax
        char* var_name = strdup(actual_type_token->value);
        token_free(actual_type_token);
        
        // Expect '='
        Token* eq_tok = lexer_next_token(lexer);
        if (!eq_tok || eq_tok->type != TOKEN_ASSIGN) {
            // Error handling
        }
        token_free(eq_tok);
        
        // Parse value expression
        Token* val_tok = lexer_next_token(lexer);
        ArithmeticExpr* expr = arithmetic_parse_expression_stateless(lexer, val_tok, NULL);
        token_free(val_tok);
        
        // Infer type from expression
        VarType inferred_type = infer_type_from_expression(expr);
        
        // Create declaration with inferred type
        VariableDeclaration* decl = create_decl(var_name, inferred_type, is_const, expr);
        free(var_name);
        return decl;
    }
    // ELSE: Continue with explicit type path (existing code)
}
```

### Type Inference Logic

```c
VarType infer_type_from_expression(ArithmeticExpr* expr) {
    if (!expr) return VAR_NUMERIC;  // Default
    
    if (expr->is_string) return VAR_STRING;
    if (expr->is_boolean) return VAR_BOOLEAN;
    if (expr->is_collection) return VAR_LIST;  // or VAR_ARRAY
    if (expr->is_float) return VAR_NUMERIC;  // numeric handles both int/float
    
    return VAR_NUMERIC;  // Default for integer literals
}
```

### DeÄŸiÅŸtirilecek Dosya

**`compiler/stage0/modules/variable/variable_parser.c`**
- **Fonksiyon:** `variable_parse_declaration`
- **SatÄ±rlar:** 24-51 (const handling block)

---

## ğŸ§ª Test PlanÄ±

### Test 1: Tip Inferencing (SayÄ±)
```mlp
function test1() as int {
    const x = 42
    return(x)
}
```

**Beklenen:**
- Tip: `numeric` (inferred)
- Assembly: `movq $42, %r8` (immediate load)
- Assembly: `movq %r8, %rax` (return)
- **Const iÃ§in stack allocation YOK**

### Test 2: Tip Inferencing (String)
```mlp
function test2() as int {
    const msg = "hello"
    return(0)
}
```

**Beklenen:**
- Tip: `string` (inferred)
- Const string literal tanÄ±mÄ± (compile-time)
- **NOT:** String const'lar iÃ§in immediate value yok, pointer referansÄ±

### Test 3: Explicit Tip (Eski Syntax)
```mlp
function test3() as int {
    const numeric y = 100
    return(y)
}
```

**Beklenen:**
- Tip: `numeric` (explicit)
- Assembly: `movq $100, %r8` (immediate load)
- **Backward compatibility:** Eski syntax Ã§alÄ±ÅŸmalÄ±

### Test 4: Ä°fade ile Inference + Constant Folding
```mlp
function test4() as int {
    const sum = 10 + 20
    return(sum)
}
```

**Beklenen:**
- Tip: `numeric` (inferred from arithmetic)
- Expression: Constant folding â†’ `30`
- Assembly: `movq $30, %r8` (folded immediate)

### Test 5: Const Optimization Validation
```mlp
function test5() as int {
    const a = 10
    const b = 20
    numeric c = 30
    return(a + b + c)
}
```

**Beklenen:**
- `a`, `b`: Stack'te yer YOK (immediate)
- `c`: Stack'te yer VAR (-8(rbp))
- Assembly:
  ```asm
  movq $10, %r8    # const a (immediate)
  movq $20, %r9    # const b (immediate)
  movq -8(%rbp), %r10  # var c (stack)
  addq %r9, %r8
  addq %r10, %r8
  ```

---

## ğŸ“Š Etki Analizi

### DeÄŸiÅŸecek ModÃ¼ller
- âœï¸ `variable_parser.c` - Type inference ekleme (satÄ±r 24-51)
- ğŸ“– `variable_parser.h` - Helper fonksiyon tanÄ±mÄ± (opsiyonel)

### Test Edilmesi Gereken ModÃ¼ller
- âœ… `statement_parser.c` - Const statement parsing
- âœ… `functions_parser.c` - Function body parsing
- âœ… `arithmetic_parser.c` - Expression parsing (zaten Ã§alÄ±ÅŸÄ±yor)
- âœ… `functions_codegen.c` - Const registration (zaten Ã§alÄ±ÅŸÄ±yor)
- âœ… `statement_codegen.c` - Const immediate load (zaten Ã§alÄ±ÅŸÄ±yor)

### Backward Compatibility
- âœ… Eski syntax korunmalÄ±: `const numeric x = 10`
- âœ… Yeni syntax eklenecek: `const x = 10`

### Mevcut Const Infrastructure (DoÄŸrulama)
| BileÅŸen | Durum | AÃ§Ä±klama |
|---------|-------|----------|
| AST (`VariableDeclaration.is_const`) | âœ… Var | variable.h:59 |
| Symbol Table (`LocalVariable.is_const`) | âœ… Var | functions.h:55 |
| Symbol Table (`LocalVariable.const_value`) | âœ… Var | functions.h:56 |
| Stack Optimization | âœ… Ã‡alÄ±ÅŸÄ±yor | functions.c:457-459 |
| Immediate Load | âœ… Ã‡alÄ±ÅŸÄ±yor | statement_codegen.c:607-609 |
| Type Inference | âŒ YOK | **BUG! Eklenmeli** |

**SonuÃ§:** Infrastructure hazÄ±r, sadece **parse aÅŸamasÄ±nda type inference** eksik!

---

## ğŸ“ Referanslar

- `stage1_bug_YZ/BUG_LIST.md` - Bug listesi
- `stage1_bug_YZ/YZ_00_GOREV.md` - GÃ¶rev tanÄ±mÄ±
- `ust_akil_YZ/YZ_UA_03_DEVIR.md` - Ã–nceki analiz
- `PMPL_SYNTAX.md` - PMPL syntax referansÄ±

---

## âœ… Tamamlanan Ä°ÅŸler

- [x] Bug doÄŸrulandÄ± (test ile)
- [x] KÃ¶k sebep bulundu (variable_parser.c:24-51)
- [x] **Const infrastructure analizi** (HAZIR!)
  - [x] AST representation (is_const flag)
  - [x] Symbol table (is_const + const_value)
  - [x] Stack optimization (const iÃ§in yer ayrÄ±lmÄ±yor)
  - [x] Immediate load (return statement)
- [x] Ã‡Ã¶zÃ¼m Ã¶nerildi (type inference)
- [x] Test planÄ± hazÄ±rlandÄ±
- [x] Rapor yazÄ±ldÄ±

---

## ğŸ¯ Kilit Bulgular

### âœ… DOÄRU: Const CodeGen Stratejisi (YZ_121)

MELP'de const'lar **Rust benzeri** implement edilmiÅŸ:

```rust
// Rust'ta
const X: i32 = 88;  // Compile time, runtime'da yok

fn main() -> i32 {
    X  // Direkt $88 olarak derlenir
}
```

```mlp
// MELP'de (teorik - parse edilemiyor)
function main() as int {
    const x = 88
    return(x)  // movq $88, %r8 Ã¼retilmeli
}
```

**Mevcut Implementation:**
1. âœ… Const deÄŸiÅŸken **stack'te YER KAPLAMAZ** (`local_var_count--`)
2. âœ… Const value **immediate** olarak yÃ¼klenir (`movq $88, %r8`)
3. âœ… Runtime'da const iÃ§in **KOD ÃœRETÄ°LMEZ**
4. âŒ Parse aÅŸamasÄ±nda **type inference YOK** â†’ Bu yÃ¼zden parse baÅŸarÄ±sÄ±z

### âŒ SORUN: Type Inference Eksik

```c
// variable_parser.c:24-51
if (type_token->type == TOKEN_CONST) {
    actual_type_token = lexer_next_token(lexer);  // "x" okunuyor
    
    // Sadece explicit type keyword kontrol ediliyor
    if (actual_type_token->type == TOKEN_NUMERIC) { ... }
    else if (actual_type_token->type == TOKEN_STRING_TYPE) { ... }
    // ...
    else {
        return NULL;  // â† BUG: "x" identifier olduÄŸu iÃ§in baÅŸarÄ±sÄ±z!
    }
}
```

**Fix:** Identifier gÃ¶rdÃ¼ÄŸÃ¼nde â†’ `= value` parse et â†’ type inference yap

---

## ğŸ¯ Sonraki AdÄ±m

**GÃ¶rev:** YZ_01 - BUG-001 Fix Implementation  
**Ä°Ã§erik:** Ã–nerilen Ã§Ã¶zÃ¼mÃ¼ implement et  
**Atanan:** (Ãœst AkÄ±l tarafÄ±ndan atanacak)

---

**Rapor Tarihi:** 20 AralÄ±k 2025  
**GÃ¶revli:** YZ_00  
**Durum:** âœ… TAMAMLANDI
