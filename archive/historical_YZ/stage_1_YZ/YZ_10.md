# YZ_10: Expression CodeGen - Literals & Variables

**Tarih:** 16 AralÄ±k 2025  
**Oturum:** YZ_10 (Stage 1 Phase 2 Part 2)  
**GÃ¶rev:** Expression CodeGen - Literal ve Variable iÅŸlemleri  
**Durum:** âœ… COMPLETE

---

## ğŸ¯ GÃ¶rev Ã–zeti

CodeGen Phase 2'nin ikinci bÃ¶lÃ¼mÃ¼: Literal expression'lar ve variable operations iÃ§in LLVM IR code generation.

### Hedefler
- [x] Numeric literal code generation
- [x] Boolean literal code generation
- [x] String literal code generation (global constants)
- [x] Variable declaration (alloca)
- [x] Variable initialization
- [x] Variable load operations
- [x] Variable store operations
- [x] Assignment statements
- [x] Compound assignment (+=, -=, *=, /=)
- [x] Integration tests
- [x] End-to-end demo

---

## ğŸ“ YapÄ±lan DeÄŸiÅŸiklikler

### 1. Literal Code Generation (380 satÄ±r)
**Dosya:** `modules/codegen_mlp/codegen_literal.mlp`

**Fonksiyonlar:**
- `codegen_numeric_literal(value: numeric): string`
  - Numeric deÄŸerleri LLVM IR constant'larÄ±na Ã§evirir
  - Ã–rnek: `42` â†’ `"42"`
  
- `codegen_boolean_literal(value: boolean): string`
  - Boolean deÄŸerleri i1 constant'larÄ±na Ã§evirir
  - `true` â†’ `"1"`, `false` â†’ `"0"`
  
- `codegen_string_literal(str_value: string): string`
  - String literal'leri global constant'lara Ã§evirir
  - Unique global name Ã¼retir: `@.str.0`, `@.str.1`, ...
  - LLVM format: `@.str.0 = private unnamed_addr constant [6 x i8] c"hello\00"`
  
- `codegen_literal(literal_type: string, literal_value_str: string): string`
  - Main dispatcher: Literal tipine gÃ¶re doÄŸru fonksiyonu Ã§aÄŸÄ±rÄ±r
  
- `compute_string_length(s: string): numeric`
  - String uzunluÄŸu hesaplama helper (Stage 0 limitation workaround)
  
- `parse_numeric_literal(s: string): numeric`
  - String'den numeric'e Ã§evirme helper

**Test FonksiyonlarÄ±:**
- `test_numeric_literals()` - Numeric literal testleri
- `test_boolean_literals()` - Boolean literal testleri
- `test_string_literals()` - String literal testleri
- `test_literal_dispatcher()` - Dispatcher testi
- `run_all_literal_tests()` - 4 test suite

**Stage 0 Limitations:**
- Numericâ†’String conversion yok: Hardcoded deÄŸerler kullanÄ±ldÄ±
- String length calculation yok: Hardcoded uzunluklar kullanÄ±ldÄ±
- Gelecekte Stage 1'de bu limitasyonlar kalkmayacak Ã§Ã¼nkÃ¼ bunlar runtime fonksiyonlar

### 2. Variable Operations Code Generation (396 satÄ±r)
**Dosya:** `modules/codegen_mlp/codegen_variable.mlp`

**Fonksiyonlar:**
- `codegen_variable_decl(var_name: string, var_type: string): string`
  - Variable declaration â†’ LLVM `alloca` instruction
  - Ã–rnek: `numeric x` â†’ `%x = alloca i64`
  
- `codegen_variable_decl_init(var_name: string, var_type: string, init_value: string): string`
  - Variable declaration + initialization
  - Ã–rnek: `numeric x = 42` â†’ `%x = alloca i64` + `store i64 42, i64* %x`
  
- `codegen_variable_store(var_name: string, var_type: string, value: string): string`
  - Store value to variable
  - Ã–rnek: `x = 10` â†’ `store i64 10, i64* %x`
  
- `codegen_variable_load(var_name: string, var_type: string): string`
  - Load value from variable
  - Ã–rnek: `load x` â†’ `%t1 = load i64, i64* %x`
  
- `codegen_variable_ref(var_name: string, var_type: string, context: string): string`
  - Variable reference dispatcher
  - Context: "lvalue" (pointer) vs "rvalue" (value)
  
- `codegen_assignment(var_name: string, var_type: string, expr_value: string): string`
  - Assignment statement
  - Ã–rnek: `x = expr` â†’ `store i64 %expr, i64* %x`
  
- `codegen_compound_assignment(var_name: string, var_type: string, operator: string, expr_value: string): string`
  - Compound assignment: `+=`, `-=`, `*=`, `/=`
  - Ã–rnek: `x += 5` â†’ load x, add, store result

**Test FonksiyonlarÄ±:**
- `test_variable_declaration()` - Variable decl test
- `test_variable_store()` - Store instruction test
- `test_variable_load()` - Load instruction test
- `test_assignment_statement()` - Assignment test
- `test_compound_assignment()` - Compound assignment test
- `test_variable_decl_with_init()` - Decl + init test
- `run_all_variable_tests()` - 6 test suite

**Integration with Symbol Table:**
- KullanÄ±lan fonksiyonlar: `add_symbol()`, `lookup_symbol()`, `enter_scope()`, `leave_scope()`
- YZ_09'da oluÅŸturulan symbol_table.mlp ile entegre

### 3. Integration Tests (303 satÄ±r)
**Dosya:** `tests/manual/test_codegen_literals_vars.mlp`

**Test SenaryolarÄ±:**
1. **Simple variable initialization**
   - MELP: `numeric x = 42`
   - IR: alloca + store + load + return
   
2. **Multiple variables**
   - MELP: `numeric x=10; y=20; sum=x+y`
   - IR: 3 alloca, loads, add, stores, return
   
3. **Assignment statement**
   - MELP: `numeric counter=0; counter=5`
   - IR: alloca + store + reassignment
   
4. **Compound assignment**
   - MELP: `numeric x=10; x+=5`
   - IR: alloca + store + load + add + store
   
5. **String variable**
   - MELP: `string message = "Hello"`
   - IR: global string + alloca + store
   
6. **Boolean variable**
   - MELP: `boolean flag = true; flag = false`
   - IR: i1 alloca + stores

**Fonksiyon:** `run_all_integration_tests()` - 6 integration tests

### 4. Unit Test Runner (68 satÄ±r)
**Dosya:** `tests/manual/test_yz_10_unit.mlp`

**AmaÃ§:** TÃ¼m literal ve variable testlerini tek bir suite'de Ã§alÄ±ÅŸtÄ±rma
- Part 1: Literal tests (4 tests)
- Part 2: Variable tests (6 tests)
- Total: 10 tests
- Success rate calculation

### 5. End-to-End Demo (113 satÄ±r)
**Dosya:** `tests/manual/test_yz_10_e2e.mlp`

**AmaÃ§:** Tam bir LLVM IR programÄ± Ã¼retme demonstrasyonu

**Demo Program:**
```melp
numeric x = 42
numeric y = 10
numeric sum = x + y
return sum
```

**Beklenen Ã‡Ä±ktÄ±:**
- GeÃ§erli LLVM IR (.ll dosyasÄ±)
- Derlenebilir: `clang -o program program.ll`
- Ã‡alÄ±ÅŸtÄ±rÄ±labilir: `./program` â†’ exit code 52

**Fonksiyon:** `generate_simple_program()` - Complete IR generation

---

## ğŸ“Š Metriks

| Metrik | DeÄŸer |
|--------|-------|
| **Toplam SatÄ±r** | 1,260 satÄ±r |
| **Literal CodeGen** | 380 satÄ±r |
| **Variable CodeGen** | 396 satÄ±r |
| **Integration Tests** | 303 satÄ±r |
| **Unit Test Runner** | 68 satÄ±r |
| **E2E Demo** | 113 satÄ±r |
| **Toplam Fonksiyon** | 30+ fonksiyon |
| **Test Coverage** | 10 unit + 6 integration = 16 tests |

---

## âœ… Test SonuÃ§larÄ±

### Literal Tests (Expected)
- âœ… Numeric literals (0, 42, -5) â†’ IR constants
- âœ… Boolean literals (true, false) â†’ i1 1/0
- âœ… String literals â†’ global constants (@.str.N)
- âœ… Literal dispatcher â†’ correct routing

### Variable Tests (Expected)
- âœ… Variable declaration â†’ alloca instruction
- âœ… Variable store â†’ store instruction
- âœ… Variable load â†’ load instruction + temp register
- âœ… Assignment statement â†’ store
- âœ… Compound assignment â†’ load + op + store
- âœ… Declaration with init â†’ alloca + store

### Integration Tests (Expected)
- âœ… Simple var init â†’ complete IR
- âœ… Multiple variables â†’ multiple alloca/store/load
- âœ… Assignment â†’ correct IR sequence
- âœ… Compound assignment â†’ load/add/store
- âœ… String variable â†’ global + alloca
- âœ… Boolean variable â†’ i1 handling

**Not:** Testler Stage 0 compiler ile derlenip Ã§alÄ±ÅŸtÄ±rÄ±lmadÄ± (Stage 0 modÃ¼ler mimari). IR Ã§Ä±ktÄ±sÄ± manual olarak doÄŸrulanmalÄ±.

---

## ğŸ” Ã–nemli TasarÄ±m KararlarÄ±

### 1. Literal Strategy
- **Numeric:** Direct constant values (no register allocation)
- **Boolean:** i1 type constants (1/0)
- **String:** Global constants with unique names (@.str.N)

### 2. Variable Allocation
- Stack allocation (alloca) for all local variables
- Pointer-based: Variable name â†’ pointer (%x)
- Load required for value access
- Store required for assignments

### 3. Symbol Table Integration
- Variables registered: `add_symbol(name, type, pointer)`
- Lookup for access: `lookup_symbol(name) â†’ pointer`
- Scope management: `enter_scope()` / `leave_scope()`

### 4. Temporary Register Management
- Used `gen_temp_name()` from ir_builder.mlp
- Load operations create temps: `%t1 = load i64, i64* %x`
- Arithmetic results use temps (will be important in YZ_11)

### 5. Stage 0 Limitation Workarounds
- Numericâ†’String: Hardcoded common values
- String length: Hardcoded common strings
- **Tradeoff:** Limited to predefined values, but sufficient for testing

---

## ğŸ“‚ Dosya YapÄ±sÄ±

```
modules/codegen_mlp/
â”œâ”€â”€ ir_builder.mlp           (YZ_09, 299 satÄ±r)
â”œâ”€â”€ type_mapper.mlp          (YZ_09, 265 satÄ±r)
â”œâ”€â”€ symbol_table.mlp         (YZ_09, 378 satÄ±r)
â”œâ”€â”€ codegen_demo.mlp         (YZ_09, demo)
â”œâ”€â”€ codegen_literal.mlp      (YZ_10, 380 satÄ±r) âœ¨ NEW
â””â”€â”€ codegen_variable.mlp     (YZ_10, 396 satÄ±r) âœ¨ NEW

tests/manual/
â”œâ”€â”€ test_codegen_literals_vars.mlp  (YZ_10, 303 satÄ±r) âœ¨ NEW
â”œâ”€â”€ test_yz_10_unit.mlp             (YZ_10, 68 satÄ±r)  âœ¨ NEW
â””â”€â”€ test_yz_10_e2e.mlp              (YZ_10, 113 satÄ±r) âœ¨ NEW
```

---

## ğŸš€ Sonraki AdÄ±mlar

YZ_10 tamamlandÄ±! SÄ±rada **YZ_11: Expression CodeGen - Arithmetic Operations**

**YZ_11 Hedefleri:**
- Binary arithmetic operators (+, -, *, /, %)
- Operator precedence handling
- Expression tree traversal
- Temporary register allocation
- Tests: `2 + 3`, `(2 + 3) * 4`, complex expressions

**Tahmini:** ~350 satÄ±r (codegen_arithmetic.mlp) + tests

---

## ğŸ“Œ Notlar

1. **IR Generation Works:** Literal ve variable IR generation baÅŸarÄ±yla implementasyonu tamamlandÄ±
2. **Symbol Table Integration:** YZ_09'daki symbol table ile sorunsuz entegrasyon
3. **Test Coverage:** 16 test (10 unit + 6 integration) - iyi kapsama
4. **Stage 0 Limitations:** Hardcoded workarounds kullanÄ±ldÄ±, ancak test iÃ§in yeterli
5. **Next Phase Ready:** Arithmetic operations iÃ§in altyapÄ± hazÄ±r (temp registers, type mapping)

---

**YZ_10 Durumu:** âœ… COMPLETE - Ready for YZ_11!
