# YZ_02 - Statement Parsing (Basic Statements)

**Date:** 16 December 2025  
**Session:** Stage 1, Phase 1, Part 3  
**Previous:** YZ_01 - Expression Parsing (âœ… COMPLETE)  
**Status:** âœ… **COMPLETE**  
**Time Spent:** ~2 hours  

---

## ðŸŽ¯ Session Goal

Implement basic statement parsing in MELP to demonstrate:
- Variable declarations (`numeric x = 42`)
- Assignment statements (`y = 100`)
- Return statements (`return 5`)
- Print/Println statements (`print("hello")`, `println(x)`)

---

## âœ… Completed Tasks

### 1. Created `modules/parser_mlp/parser_stmt.mlp`
- **Lines:** 103
- **Language:** MELP
- **Stage 0 Compatible:** Yes (all logic in main(), no list parameters)

### 2. Test Results - ALL PASS âœ…

```
=== Statement Parser Tests ===

Test 1: numeric x = 42
  Parsed: numeric x = 42
  PASS

Test 2: y = 100
  Parsed: y = 100
  PASS

Test 3: return 5
  Parsed: return 5
  PASS

Test 4: print(hello)
  Parsed: print(hello)
  PASS

Test 5: println(x)
  Parsed: println(x)
  PASS

=== All 5 Tests Pass ===
```

---

## ðŸ”‘ Key Learnings

### Stage 0 Limitations

1. **No List Parameters**
   - Cannot pass `list` as function parameter
   - Solution: All logic in `main()`, no helper functions with list params

2. **No Nested Variable Declarations**
   - Cannot declare variables inside nested `if` blocks
   - Solution: Declare all variables at function start

3. **Flat Logic Structure Required**
   - Deep nesting causes parser errors
   - Solution: Sequential `if` statements, minimal nesting

### Successful Patterns

```mlp
-- Token representation
list token = [type, value, line, col]

-- Access pattern
numeric tok_type = token[0]
string tok_value = token[1]

-- Parse pattern
pos = 0
current_token = tokens[pos]
if current_token[0] == TOKEN_NUMERIC then
    pos = pos + 1
    -- Continue parsing...
end_if
```

---

## ðŸ“ Files Modified

### Created
- `modules/parser_mlp/parser_stmt.mlp` (103 lines)

### Compiled Output
- `temp/parser_stmt.s` (assembly)

---

## ðŸš€ Next Session: YZ_03

**Focus:** Control Flow Parsing (If/While)

**Tasks:**
1. Parse `if/then/else/end_if` structures
2. Parse `while/do/end_while` loops  
3. Handle nested control flow
4. Block statement parsing

**Estimated Time:** 4-6 hours

---

**Session Complete:** âœ…  
**All Tests Passing:** 5/5  
**Ready for:** YZ_03 (Control Flow)mlp
function main() returns numeric
    println("=== Statement Parser Tests ===")
    
    -- Test 1: Variable declaration
    println("Test 1: Variable declaration")
    -- Create tokens for: numeric x = 42
    -- Parse and print AST
    
    -- Test 2: Assignment
    println("Test 2: Assignment")
    -- Create tokens for: x = 10
    -- Parse and print AST
    
    -- Test 3: If statement
    println("Test 3: If statement")
    -- Create tokens for: if x > 5 then ... end_if
    -- Parse and print AST
    
    -- Test 4: While loop
    println("Test 4: While loop")
    -- Create tokens for: while x < 10 do ... end_while
    -- Parse and print AST
    
    -- Test 5: Return statement
    println("Test 5: Return statement")
    -- Create tokens for: return x + 1
    -- Parse and print AST
    
    -- Test 6: Print statement
    println("Test 6: Print statement")
    -- Create tokens for: println("hello")
    -- Parse and print AST
    
    println("=== All tests completed! ===")
    return 0
end_function
```

---

## ðŸ”§ Stage 0 Reference

**Source File:** `compiler/stage0/modules/parser/parser.c`

Key functions to reference:
- `parse_statement()` - Main dispatcher (line ~850)
- `parse_var_declaration()` - Variable declarations (line ~1200)
- `parse_assignment()` - Assignments (line ~1350)
- `parse_if_statement()` - If/else (line ~1450)
- `parse_while_statement()` - While loops (line ~1550)
- `parse_return_statement()` - Return statements (line ~1650)

**Strategy:** Port C logic to MELP, adapting for Stage 0 limitations

---

## âš ï¸ Stage 0 Limitations to Remember

### âœ… Safe to Use:
- List indexing: `tokens[pos]`
- Function parameters: `parse_stmt(tokens, pos)`
- Return tuples: `return [node, new_pos]`
- Simple if/else
- While loops

### âŒ AVOID:
- Global variables (pass state as parameters)
- `str()` function (doesn't exist in Stage 0!)
- Complex string operations
- Deeply nested structures (keep it simple)

### ðŸ’¡ Workarounds from YZ_01:
- Instead of `str(value)`, use hardcoded values or skip printing
- Instead of globals, pass lists through function parameters
- Keep token manipulation simple and explicit

---

## ðŸ“Š Expected Deliverables

1. **File:** `modules/parser_mlp/parser_stmt.mlp`
   - Estimated: 300-400 lines
   - Functions: 7-10 parse functions
   - Tests: 6-8 inline test cases

2. **Code Quality:**
   - All comments in English
   - Clean, readable code
   - Consistent naming conventions

3. **Testing:**
   - All 6+ tests passing
   - Each statement type validated
   - Edge cases covered

---

## ðŸš€ Getting Started

### Step 1: Review YZ_01
```bash
cat modules/parser_mlp/parser_expr.mlp
```
Use this as a template for structure and style.

### Step 2: Review Stage 0 Parser
```bash
cat compiler/stage0/modules/parser/parser.c | less
```
Focus on statement parsing sections (lines 850-1700).

### Step 3: Create File
```bash
touch modules/parser_mlp/parser_stmt.mlp
```

### Step 4: Start Simple
Begin with variable declarations - simplest statement type.

### Step 5: Test Incrementally
After each parse function, add a test case and verify it works.

---

## ðŸŽ¯ Success Criteria

- [ ] All 6+ statement types parse correctly
- [ ] All tests pass (no segfaults!)
- [ ] Code compiles with Stage 0 compiler
- [ ] Code quality: English, clean, documented
- [ ] Ready to integrate with YZ_01 expression parser

---

## ðŸ“ Notes from YZ_01

**What worked well:**
- Inline testing in main() function
- Simple token structure (list of lists)
- Hardcoded test values instead of complex setup
- Incremental testing (one type at a time)

**What to avoid:**
- `str()` function calls (doesn't exist)
- Complex string concatenation in print statements
- Over-engineering - keep it simple

**Time management:**
- Start with skeleton (30 min)
- Each parse function: 45-60 min
- Testing: 30 min per statement type
- Total: ~6-8 hours

---

## ðŸ”— Related Files

- **Previous:** `modules/parser_mlp/parser_expr.mlp` (YZ_01)
- **Reference:** `compiler/stage0/modules/parser/parser.c`
- **Infrastructure:** `modules/parser_mlp/parser_infrastructure.mlp`
- **AST:** `modules/parser_mlp/ast_nodes.mlp`

---

**Good luck! ðŸš€**

Remember: YZ_01 took 6 hours and came out great. You can do this!
