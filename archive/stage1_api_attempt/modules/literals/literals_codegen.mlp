-- ============================================================================
-- literals_codegen.mlp - Literal Value Code Generation for MELP Stage 1
-- ============================================================================
-- Part of: Stage 1 Literals Module
-- Purpose: Generate LLVM IR for literal values
-- Architecture: Stateless; parameterized design
-- ============================================================================

-- Import core utilities and literals parser
-- import "compiler/stage1/modules/core/token_types.mlp"
-- import "compiler/stage1/modules/core/type_mapper.mlp"
-- import "compiler/stage1/modules/literals/literals_parser.mlp"

-- ============================================================================
-- GLOBAL STRING LITERAL COUNTER
-- ============================================================================
-- Note: This is a compile-time counter for generating unique string names
-- It's incremented during code generation (single-pass compiler)
-- This is acceptable as it's deterministic and not mutable runtime state

const numeric INITIAL_STRING_COUNTER = 0
-- TIER 1: Move to compiler context when context system is implemented

-- ============================================================================
-- CODE GENERATION FUNCTIONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- codegen_integer_literal - Generate LLVM IR for integer literal
-- ----------------------------------------------------------------------------
-- Input:
--   literal: literal node [LIT_INTEGER; value; original_text]
--   result_var: variable name to store result (or "" for immediate)
--   indent: indentation string for formatting
-- Output:
--   LLVM IR code string
--
-- Example:
--   Input: [LIT_INTEGER; "42"; "42"]; "x"; "  "
--   Output: "  %x = add i64 0; 42  ; integer literal 42\n"
--
-- Alternative (immediate value in expression):
--   Input: [LIT_INTEGER; "42"; "42"]; ""; ""
--   Output: "42"  (just the value; no assignment)
-- ----------------------------------------------------------------------------
function codegen_integer_literal(list literal; string result_var; string indent) returns string
    string value = literal[1]
    string original_text = literal[2]
    
    -- If no result variable; return immediate value
    if result_var == "" then
        return value
    end_if
    
    -- Generate LLVM IR for integer constant assignment
    -- We use "add i64 0; value" to create a register with the constant
    string llvm_code = indent
    llvm_code = llvm_code + "%"
    llvm_code = llvm_code + result_var
    llvm_code = llvm_code + " = add i64 0; "
    llvm_code = llvm_code + value
    llvm_code = llvm_code + "  ; integer literal "
    llvm_code = llvm_code + original_text
    llvm_code = llvm_code + "\n"
    
    return llvm_code
end_function

-- ----------------------------------------------------------------------------
-- codegen_float_literal - Generate LLVM IR for float literal (TIER 1)
-- ----------------------------------------------------------------------------
-- Input:
--   literal: literal node [LIT_FLOAT; value; original_text]
--   result_var: variable name to store result
--   indent: indentation string
-- Output:
--   LLVM IR code string
--
-- Example:
--   Input: [LIT_FLOAT; "3.14"; "3.14"]; "f"; "  "
--   Output: "  %f = fadd double 0.0; 3.14  ; float literal 3.14\n"
-- ----------------------------------------------------------------------------
function codegen_float_literal(list literal; string result_var; string indent) returns string
    -- TIER 1: Implement float literal codegen
    -- For now; return empty string
    return ""
end_function

-- ----------------------------------------------------------------------------
-- codegen_string_literal - Generate LLVM IR for string literal
-- ----------------------------------------------------------------------------
-- Input:
--   literal: literal node [LIT_STRING; value; original_text]
--   result_var: variable name to store result (pointer to string)
--   indent: indentation string
--   string_id: unique ID for this string constant (for global naming)
-- Output:
--   [llvm_code; global_declaration]
--   - llvm_code: code to get pointer to string
--   - global_declaration: global string constant declaration
--
-- Example:
--   Input: [LIT_STRING; "hello"; "\"hello\""]; "str"; "  "; 1
--   Output:
--     llvm_code = "  %str = getelementptr [6 x i8]; [6 x i8]* @.str.1; i64 0; i64 0\n"
--     global_decl = "@.str.1 = private unnamed_addr constant [6 x i8] c\"hello\\00\"\n"
--
-- String literals in LLVM:
--   1. Declare global constant array (in global section)
--   2. Use getelementptr to get pointer to first element
--   3. String type is i8* (pointer to character array)
-- ----------------------------------------------------------------------------
function codegen_string_literal(list literal; string result_var; string indent; numeric string_id) returns list
    string value = literal[1]
    string original_text = literal[2]
    
    -- Calculate string length (+1 for null terminator)
    numeric str_len = 0  -- TIER 1: Implement proper string length function
    -- For now; estimate based on value
    -- HACK: Assume string length < 100 for now
    str_len = 100  -- Will be fixed in TIER 1
    
    -- Generate global string name
    string global_name = "@.str."
    -- TIER 1: Convert string_id to string properly
    -- For now; hardcode
    if string_id == 1 then
        global_name = "@.str.1"
    end_if
    if string_id == 2 then
        global_name = "@.str.2"
    end_if
    -- TIER 1: Add more cases or implement numeric to string conversion
    
    -- Generate global declaration
    -- Format: @.str.N = private unnamed_addr constant [LEN x i8] c"VALUE\00"
    string global_decl = global_name
    global_decl = global_decl + " = private unnamed_addr constant ["
    -- TIER 1: Convert str_len to string
    global_decl = global_decl + "100"  -- HACK
    global_decl = global_decl + " x i8] c\""
    global_decl = global_decl + value
    global_decl = global_decl + "\\00\"\n"
    
    -- Generate getelementptr instruction
    -- Format: %var = getelementptr [LEN x i8]; [LEN x i8]* @.str.N; i64 0; i64 0
    string llvm_code = indent
    llvm_code = llvm_code + "%"
    llvm_code = llvm_code + result_var
    llvm_code = llvm_code + " = getelementptr ["
    -- TIER 1: Convert str_len to string
    llvm_code = llvm_code + "100"  -- HACK
    llvm_code = llvm_code + " x i8]; ["
    llvm_code = llvm_code + "100"  -- HACK
    llvm_code = llvm_code + " x i8]* "
    llvm_code = llvm_code + global_name
    llvm_code = llvm_code + "; i64 0; i64 0  ; string literal "
    llvm_code = llvm_code + original_text
    llvm_code = llvm_code + "\n"
    
    -- Return both code and global declaration
    return (llvm_code; global_decl;)
end_function

-- ----------------------------------------------------------------------------
-- codegen_boolean_literal - Generate LLVM IR for boolean literal
-- ----------------------------------------------------------------------------
-- Input:
--   literal: literal node [LIT_BOOLEAN; value; original_text]
--   result_var: variable name to store result
--   indent: indentation string
-- Output:
--   LLVM IR code string
--
-- Example:
--   Input: [LIT_BOOLEAN; 1; "true"]; "flag"; "  "
--   Output: "  %flag = add i1 0; 1  ; boolean literal true\n"
--
--   Input: [LIT_BOOLEAN; 0; "false"]; "flag"; "  "
--   Output: "  %flag = add i1 0; 0  ; boolean literal false\n"
--
-- Boolean type in LLVM: i1 (1-bit integer)
--   - true = 1
--   - false = 0
-- ----------------------------------------------------------------------------
function codegen_boolean_literal(list literal; string result_var; string indent) returns string
    numeric value = literal[1]  -- 0 or 1
    string original_text = literal[2]
    
    -- If no result variable; return immediate value
    if result_var == "" then
        -- TIER 1: Convert numeric to string properly
        if value == 1 then
            return "1"
        end_if
        return "0"
    end_if
    
    -- Generate LLVM IR for boolean constant assignment
    -- We use "add i1 0; value" to create a register with the constant
    string llvm_code = indent
    llvm_code = llvm_code + "%"
    llvm_code = llvm_code + result_var
    llvm_code = llvm_code + " = add i1 0; "
    
    -- Convert value to string
    if value == 1 then
        llvm_code = llvm_code + "1"
    end_if
    if value == 0 then
        llvm_code = llvm_code + "0"
    end_if
    
    llvm_code = llvm_code + "  ; boolean literal "
    llvm_code = llvm_code + original_text
    llvm_code = llvm_code + "\n"
    
    return llvm_code
end_function

-- ----------------------------------------------------------------------------
-- codegen_literal - Generate LLVM IR for any literal (dispatcher)
-- ----------------------------------------------------------------------------
-- Input:
--   literal: literal node [lit_type; value; original_text]
--   result_var: variable name to store result
--   indent: indentation string
--   string_id: unique ID for string constants (optional; 0 if not string)
-- Output:
--   For integer/boolean: LLVM IR code string
--   For string: [llvm_code; global_declaration]
--   For unknown: empty string
--
-- Example:
--   Input: [LIT_INTEGER; "42"; "42"]; "x"; "  "; 0
--   Output: "  %x = add i64 0; 42  ; integer literal 42\n"
--
--   Input: [LIT_STRING; "hi"; "\"hi\""]; "s"; "  "; 1
--   Output: [code; global]
-- ----------------------------------------------------------------------------
function codegen_literal(list literal; string result_var; string indent; numeric string_id) returns list
    numeric lit_type = literal[0]
    
    if lit_type == LIT_INTEGER then
        string code = codegen_integer_literal(literal; result_var; indent)
        return (code; "";)  -- No global declaration for integers
    end_if
    
    if lit_type == LIT_FLOAT then
        string code = codegen_float_literal(literal; result_var; indent)
        return (code; "";)  -- TIER 1
    end_if
    
    if lit_type == LIT_STRING then
        return codegen_string_literal(literal; result_var; indent; string_id)
    end_if
    
    if lit_type == LIT_BOOLEAN then
        string code = codegen_boolean_literal(literal; result_var; indent)
        return (code; "";)  -- No global declaration for booleans
    end_if
    
    -- Unknown literal type
    return (""; "";)
end_function

-- ============================================================================
-- HELPER FUNCTIONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- get_literal_llvm_type - Get LLVM type for literal
-- ----------------------------------------------------------------------------
-- Input:
--   literal: literal node [lit_type; value; original_text]
-- Output:
--   LLVM type string
--
-- Example:
--   get_literal_llvm_type([LIT_INTEGER; 42; "42"]) → "i64"
--   get_literal_llvm_type([LIT_STRING; "hi"; "\"hi\""]) → "i8*"
--   get_literal_llvm_type([LIT_BOOLEAN; 1; "true"]) → "i1"
-- ----------------------------------------------------------------------------
function get_literal_llvm_type(list literal) returns string
    numeric lit_type = literal[0]
    
    if lit_type == LIT_INTEGER then
        return "i64"
    end_if
    if lit_type == LIT_FLOAT then
        return "double"  -- TIER 1
    end_if
    if lit_type == LIT_STRING then
        return "i8*"  -- Pointer to character array
    end_if
    if lit_type == LIT_BOOLEAN then
        return "i1"  -- 1-bit integer
    end_if
    
    return "void"  -- Unknown
end_function

-- ----------------------------------------------------------------------------
-- is_constant_literal - Check if literal is compile-time constant
-- ----------------------------------------------------------------------------
-- Input:
--   literal: literal node
-- Output:
--   1 if constant (can be evaluated at compile time); 0 otherwise
--
-- All literals are constants by definition
-- ----------------------------------------------------------------------------
function is_constant_literal(list literal) returns numeric
    return 1  -- All literals are constants
end_function

-- ----------------------------------------------------------------------------
-- get_literal_immediate_value - Get immediate value for expressions
-- ----------------------------------------------------------------------------
-- Input:
--   literal: literal node
-- Output:
--   String representation of immediate value (for use in LLVM expressions)
--
-- Example:
--   get_literal_immediate_value([LIT_INTEGER; "42"; "42"]) → "42"
--   get_literal_immediate_value([LIT_BOOLEAN; 1; "true"]) → "1"
--
-- Note: Strings cannot be used as immediate values (must use register)
-- ----------------------------------------------------------------------------
function get_literal_immediate_value(list literal) returns string
    numeric lit_type = literal[0]
    
    if lit_type == LIT_INTEGER then
        return literal[1]  -- Return value as string
    end_if
    
    if lit_type == LIT_BOOLEAN then
        numeric bool_val = literal[1]
        if bool_val == 1 then
            return "1"
        end_if
        return "0"
    end_if
    
    -- String and other types cannot be immediate values
    return ""
end_function

-- ============================================================================
-- OPTIMIZATION FUNCTIONS (TIER 1)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- optimize_literal_expression - Optimize literal expressions
-- ----------------------------------------------------------------------------
-- Input:
--   literals: list of literals in an expression
--   operator: operator between literals
-- Output:
--   Optimized literal or original expression
--
-- Example:
--   optimize_literal_expression([[LIT_INTEGER; "2"; "2"]; [LIT_INTEGER; "3"; "3"]]; "+")
--   → [LIT_INTEGER; "5"; "5"]  (constant folding: 2 + 3 = 5)
--
-- TIER 1: Implement constant folding
--   - Arithmetic operations on integer literals
--   - Comparison operations
--   - Boolean operations
-- ----------------------------------------------------------------------------
function optimize_literal_expression(list literals; string operator) returns list
    -- TIER 1: Implement constant folding
    -- For now; no optimization
    return (;)  -- Empty = no optimization
end_function

-- ----------------------------------------------------------------------------
-- fold_integer_operation - Fold integer arithmetic at compile time
-- ----------------------------------------------------------------------------
function fold_integer_operation(numeric left; numeric right; string op) returns numeric
    -- TIER 1: Implement constant folding
    return 0
end_function

-- ============================================================================
-- STRING LITERAL MANAGEMENT
-- ============================================================================

-- ----------------------------------------------------------------------------
-- generate_string_id - Generate unique ID for string literal
-- ----------------------------------------------------------------------------
-- Input:
--   None (uses internal counter)
-- Output:
--   Unique numeric ID for string
--
-- Note: This is a compile-time counter
-- TIER 1: Move to compiler context system
-- ----------------------------------------------------------------------------
function generate_string_id() returns numeric
    -- TIER 1: Implement proper counter
    -- For now; return 1 (single string)
    return 1
end_function

-- ----------------------------------------------------------------------------
-- escape_string_for_llvm - Escape string for LLVM IR
-- ----------------------------------------------------------------------------
-- Input:
--   str: string to escape
-- Output:
--   Escaped string suitable for LLVM IR
--
-- LLVM string escaping rules:
--   - \n → \\0A
--   - \t → \\09
--   - \" → \\22
--   - \\ → \\5C
--   - etc.
--
-- TIER 1: Implement proper escaping
-- ----------------------------------------------------------------------------
function escape_string_for_llvm(string str) returns string
    -- TIER 1: Implement proper escaping
    -- For now; return as-is (assume lexer handles it)
    return str
end_function

-- ============================================================================
-- END OF MODULE
-- ============================================================================
-- Usage Example:
--
--   -- Integer literal
--   list int_lit = [LIT_INTEGER; "42"; "42"]
--   list result1 = codegen_literal(int_lit; "x"; "  "; 0)
--   -- result1[0] = "  %x = add i64 0; 42  ; integer literal 42\n"
--
--   -- String literal
--   list str_lit = [LIT_STRING; "hello"; "\"hello\""]
--   list result2 = codegen_literal(str_lit; "s"; "  "; 1)
--   -- result2[0] = getelementptr instruction
--   -- result2[1] = global string declaration
--
--   -- Boolean literal
--   list bool_lit = [LIT_BOOLEAN; 1; "true"]
--   list result3 = codegen_literal(bool_lit; "flag"; "  "; 0)
--   -- result3[0] = "  %flag = add i1 0; 1  ; boolean literal true\n"
-- ============================================================================
