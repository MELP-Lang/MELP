-- ============================================================================
-- variables_parser.mlp - Variable Declaration & Assignment Parser
-- ============================================================================
-- Stage 1 Variables Module - Parser Component
-- Converted from: compiler/stage0/modules/variable/variable_parser.c
-- 
-- Purpose:
--   Parse variable declarations and assignments using stateless pattern
--   - Variable declaration: numeric x = 10
--   - Variable assignment: x = 20
--
-- Stateless Pattern:
--   - No mutable global state
--   - All state passed as parameters
--   - Returns [result, new_position] tuple
--
-- Dependencies:
--   - core/token_types.mlp (TOKEN_* constants)
--
-- Module: Variables
-- Author: YZ_05
-- Date: 18 AralÄ±k 2025
-- ============================================================================

-- Import core utilities
import "compiler/stage1/modules/core/token_types.mlp"

-- ============================================================================
-- VARIABLE TYPE CONSTANTS
-- ============================================================================

const numeric VAR_NUMERIC = 0
const numeric VAR_STRING = 1
const numeric VAR_BOOLEAN = 2
const numeric VAR_POINTER = 3      -- Pointer type (numeric*, string*)
const numeric VAR_ARRAY = 4        -- Array type (numeric[], string[])
const numeric VAR_LIST = 5         -- List type () - heterogeneous, mutable
const numeric VAR_TUPLE = 6        -- Tuple type <> - heterogeneous, immutable

-- ============================================================================
-- STORAGE LOCATION CONSTANTS
-- ============================================================================

const numeric STORAGE_REGISTER = 0  -- Temporary values in registers
const numeric STORAGE_STACK = 1     -- Local variables on stack
const numeric STORAGE_DATA = 2      -- Global/state variables in .data
const numeric STORAGE_BSS = 3       -- Uninitialized globals in .bss
const numeric STORAGE_HEAP = 4      -- Dynamic allocation via malloc

-- ============================================================================
-- HELPER FUNCTIONS
-- ============================================================================

-- Map token type to variable type
function token_to_var_type(numeric token_type) returns numeric
    if token_type == TOKEN_NUMERIC then
        return VAR_NUMERIC
    else_if token_type == TOKEN_STRING_TYPE then
        return VAR_STRING
    else_if token_type == TOKEN_BOOLEAN then
        return VAR_BOOLEAN
    else_if token_type == TOKEN_ARRAY then
        return VAR_ARRAY
    else_if token_type == TOKEN_LIST then
        return VAR_LIST
    else_if token_type == TOKEN_TUPLE then
        return VAR_TUPLE
    else
        return -1  -- Invalid type
    end_if
end_function

-- Check if token is a type keyword
function is_type_token(numeric token_type) returns boolean
    if token_type == TOKEN_NUMERIC then
        return true
    else_if token_type == TOKEN_STRING_TYPE then
        return true
    else_if token_type == TOKEN_BOOLEAN then
        return true
    else_if token_type == TOKEN_ARRAY then
        return true
    else_if token_type == TOKEN_LIST then
        return true
    else_if token_type == TOKEN_TUPLE then
        return true
    else
        return false
    end_if
end_function

-- ============================================================================
-- VARIABLE DECLARATION PARSER
-- ============================================================================

-- Parse variable declaration: numeric x = 10
--
-- Input:
--   tokens: list - Token stream [[type, value], [type, value], ...]
--   pos: numeric - Current position in token stream
--
-- Output:
--   list - [declaration_info, new_position]
--     declaration_info: list - Variable declaration details
--       [0]: text - Variable name
--       [1]: numeric - Variable type (VAR_NUMERIC, VAR_STRING, etc.)
--       [2]: text - Initial value (or empty string if none)
--       [3]: numeric - Storage location (STORAGE_*)
--       [4]: boolean - Is pointer
--       [5]: boolean - Is array
--       [6]: numeric - Array size (0 if dynamic or not array)
--       [7]: numeric - Base type (for pointers/arrays)
--       [8]: boolean - Has initializer
--     new_position: numeric - Updated position after parsing
--
-- Returns empty list [] if parsing fails
--
function parse_variable_declaration(list tokens, numeric pos) returns list
    -- Check bounds
    if pos >= tokens.length then
        return []
    end_if
    
    -- Get type token
    list type_token = tokens[pos]
    numeric token_type = type_token[0]
    
    -- Check if type keyword
    numeric base_type = token_to_var_type(token_type)
    if base_type == -1 then
        return []  -- Not a variable declaration
    end_if
    
    numeric current_pos = pos + 1  -- Move past type token
    
    -- Check for pointer (*) or array ([])
    boolean is_pointer = false
    boolean is_array = false
    numeric array_size = 0
    numeric actual_type = base_type
    
    if current_pos >= tokens.length then
        return []  -- Unexpected end
    end_if
    
    list next_token = tokens[current_pos]
    numeric next_type = next_token[0]
    
    -- Check for pointer: numeric*
    if next_type == TOKEN_MULTIPLY then
        is_pointer = true
        actual_type = VAR_POINTER
        current_pos = current_pos + 1
        
        if current_pos >= tokens.length then
            return []
        end_if
        
        next_token = tokens[current_pos]
        next_type = next_token[0]
    else_if next_type == TOKEN_LBRACKET then
        -- Check for array: numeric[10] or numeric[]
        is_array = true
        actual_type = VAR_ARRAY
        current_pos = current_pos + 1
        
        if current_pos >= tokens.length then
            return []
        end_if
        
        next_token = tokens[current_pos]
        next_type = next_token[0]
        
        -- Check for array size
        if next_type == TOKEN_NUMBER then
            text size_str = next_token[1]
            array_size = numeric(size_str)  -- Convert string to number
            current_pos = current_pos + 1
            
            if current_pos >= tokens.length then
                return []
            end_if
            
            next_token = tokens[current_pos]
            next_type = next_token[0]
        end_if
        
        -- Expect ']'
        if next_type != TOKEN_RBRACKET then
            return []  -- Expected ']'
        end_if
        
        current_pos = current_pos + 1
        
        if current_pos >= tokens.length then
            return []
        end_if
        
        next_token = tokens[current_pos]
        next_type = next_token[0]
    end_if
    
    -- Expect identifier
    if next_type != TOKEN_IDENTIFIER then
        return []  -- Expected identifier
    end_if
    
    text var_name = next_token[1]
    current_pos = current_pos + 1
    
    -- Initialize declaration info
    text init_value = ""
    numeric storage_loc = STORAGE_BSS  -- Default: uninitialized
    boolean has_initializer = false
    
    -- Check for optional '=' initializer
    if current_pos < tokens.length then
        list assign_token = tokens[current_pos]
        numeric assign_type = assign_token[0]
        
        if assign_type == TOKEN_ASSIGN then
            has_initializer = true
            current_pos = current_pos + 1
            
            if current_pos >= tokens.length then
                return []  -- Expected value after '='
            end_if
            
            list value_token = tokens[current_pos]
            numeric value_type = value_token[0]
            
            -- Parse simple literal values
            if value_type == TOKEN_NUMBER then
                init_value = value_token[1]
                storage_loc = STORAGE_DATA
                current_pos = current_pos + 1
            else_if value_type == TOKEN_STRING then
                init_value = value_token[1]
                storage_loc = STORAGE_DATA
                current_pos = current_pos + 1
            else_if value_type == TOKEN_TRUE then
                init_value = "true"
                storage_loc = STORAGE_DATA
                current_pos = current_pos + 1
            else_if value_type == TOKEN_FALSE then
                init_value = "false"
                storage_loc = STORAGE_DATA
                current_pos = current_pos + 1
            else_if value_type == TOKEN_IDENTIFIER then
                -- Variable reference: numeric x = y
                init_value = value_token[1]
                storage_loc = STORAGE_BSS  -- Runtime initialization
                current_pos = current_pos + 1
            else
                -- Complex expression (would need expression parser)
                -- For now, mark as runtime initialization
                init_value = ""
                storage_loc = STORAGE_BSS
                -- Don't advance position - let caller handle expression
            end_if
        end_if
    end_if
    
    -- Build declaration info
    list decl_info = [
        var_name,          -- [0]: name
        actual_type,       -- [1]: type
        init_value,        -- [2]: initial value
        storage_loc,       -- [3]: storage location
        is_pointer,        -- [4]: is pointer
        is_array,          -- [5]: is array
        array_size,        -- [6]: array size
        base_type,         -- [7]: base type
        has_initializer    -- [8]: has initializer
    ]
    
    return [decl_info, current_pos]
end_function

-- ============================================================================
-- VARIABLE ASSIGNMENT PARSER
-- ============================================================================

-- Parse variable assignment: x = 20
--
-- Input:
--   tokens: list - Token stream [[type, value], [type, value], ...]
--   pos: numeric - Current position (should be at identifier)
--
-- Output:
--   list - [assignment_info, new_position]
--     assignment_info: list - Assignment details
--       [0]: text - Variable name
--       [1]: text - Value (simple literal or identifier)
--       [2]: boolean - Is expression (true if not simple literal)
--     new_position: numeric - Updated position after parsing
--
-- Returns empty list [] if parsing fails
--
function parse_variable_assignment(list tokens, numeric pos) returns list
    -- Check bounds
    if pos >= tokens.length then
        return []
    end_if
    
    -- Get identifier token
    list id_token = tokens[pos]
    numeric token_type = id_token[0]
    
    if token_type != TOKEN_IDENTIFIER then
        return []  -- Not an assignment
    end_if
    
    text var_name = id_token[1]
    numeric current_pos = pos + 1
    
    -- Expect '='
    if current_pos >= tokens.length then
        return []
    end_if
    
    list assign_token = tokens[current_pos]
    numeric assign_type = assign_token[0]
    
    if assign_type != TOKEN_ASSIGN then
        return []  -- Not an assignment
    end_if
    
    current_pos = current_pos + 1
    
    -- Parse value
    if current_pos >= tokens.length then
        return []  -- Expected value
    end_if
    
    list value_token = tokens[current_pos]
    numeric value_type = value_token[0]
    text value_str = ""
    boolean is_expression = false
    
    -- Parse simple values
    if value_type == TOKEN_NUMBER then
        value_str = value_token[1]
        current_pos = current_pos + 1
    else_if value_type == TOKEN_STRING then
        value_str = value_token[1]
        current_pos = current_pos + 1
    else_if value_type == TOKEN_TRUE then
        value_str = "true"
        current_pos = current_pos + 1
    else_if value_type == TOKEN_FALSE then
        value_str = "false"
        current_pos = current_pos + 1
    else_if value_type == TOKEN_IDENTIFIER then
        value_str = value_token[1]
        current_pos = current_pos + 1
    else
        -- Complex expression
        is_expression = true
        -- Don't advance - caller handles expression
    end_if
    
    -- Build assignment info
    list assign_info = [
        var_name,       -- [0]: variable name
        value_str,      -- [1]: value
        is_expression   -- [2]: is expression
    ]
    
    return [assign_info, current_pos]
end_function

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

-- Get variable type name (for debugging/display)
function get_var_type_name(numeric var_type) returns text
    if var_type == VAR_NUMERIC then
        return "numeric"
    else_if var_type == VAR_STRING then
        return "string"
    else_if var_type == VAR_BOOLEAN then
        return "boolean"
    else_if var_type == VAR_POINTER then
        return "pointer"
    else_if var_type == VAR_ARRAY then
        return "array"
    else_if var_type == VAR_LIST then
        return "list"
    else_if var_type == VAR_TUPLE then
        return "tuple"
    else
        return "unknown"
    end_if
end_function

-- Get storage location name (for debugging/display)
function get_storage_name(numeric storage) returns text
    if storage == STORAGE_REGISTER then
        return "register"
    else_if storage == STORAGE_STACK then
        return "stack"
    else_if storage == STORAGE_DATA then
        return "data"
    else_if storage == STORAGE_BSS then
        return "bss"
    else_if storage == STORAGE_HEAP then
        return "heap"
    else
        return "unknown"
    end_if
end_function

-- ============================================================================
-- END OF MODULE
-- ============================================================================
