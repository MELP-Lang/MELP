-- arrays_parser.mlp - Array Parser for MELP Stage 1
-- Part of: Stage 1 Arrays Module
-- Purpose: Parse array literals, indexing, and operations
-- Architecture: Stateless, parameterized design

-- Import core utilities (token types, type mapper)
-- import "compiler/stage1/modules/core/token_types.mlp"
-- import "compiler/stage1/modules/core/type_mapper.mlp"
-- import "compiler/stage1/modules/literals/literals_parser.mlp"

-- ARRAY NODE TYPE CONSTANTS

const numeric ARRAY_LITERAL = 1         -- Array literal: [1; 2; 3]
const numeric ARRAY_INDEX = 2           -- Array indexing: arr[i]
const numeric ARRAY_LENGTH = 3          -- Array length: len(arr)
const numeric ARRAY_DECLARATION = 4     -- Array declaration: list arr = [...]
const numeric ARRAY_ASSIGNMENT = 5      -- Array element assignment: arr[i] = value

-- ARRAY NODE STRUCTURE
-- Array Literal: [ARRAY_LITERAL; element_list; element_count]
--   element_list: list of literal nodes
--   element_count: numeric count of elements
--
-- Array Index: [ARRAY_INDEX; array_name; index_expr]
--   array_name: string identifier
--   index_expr: expression node (literal, variable, or expression)
--
-- Array Length: [ARRAY_LENGTH; array_name]
--   array_name: string identifier
--
-- Examples:
--   [1; 2; 3]        → [ARRAY_LITERAL; [lit1; lit2; lit3], 3]
--   arr[0]           → [ARRAY_INDEX; "arr"; [LIT_INTEGER; "0"; "0"]]
--   len(arr)         → [ARRAY_LENGTH; "arr"]

-- PARSER FUNCTIONS

-- ----------------------------------------------------------------------------
-- parse_array_literal - Parse array literal [elem1; elem2; ...]
-- ----------------------------------------------------------------------------
-- Input:
--   tokens: list of tokens
--   pos: current position
-- Output:
--   [array_node; new_pos] on success
--   [[], pos] on failure (not an array literal)
--
-- Syntax:
--   array_literal = '[' [ element (';' element)* ] ']'
--   element = literal | identifier | expression
--
-- Example:
--   Input: tokens starting with '['; '42'; ';'; '43'; ']'
--   Output: [[ARRAY_LITERAL; [lit1; lit2], 2], new_pos]
-- ----------------------------------------------------------------------------
function parse_array_literal(list tokens; numeric pos) returns list
    -- Check if current token is '['
    list token = tokens[pos]
    numeric token_type = token[0]
    
    if token_type != TOKEN_LBRACKET then
        return ([; pos;)  -- Not an array literal
    end_if
    
    -- Move past '['
    numeric current_pos = pos + 1
    
    -- Initialize element list
    list elements = []
    numeric element_count = 0
    
    -- Check for empty array []
    list next_token = tokens[current_pos]
    if next_token[0] == TOKEN_RBRACKET then
        -- Empty array
        list array_node = [ARRAY_LITERAL; elements; 0]
        return ((array_node; current_pos + 1))
    end_if
    
    -- Parse elements
    numeric parsing = 1
    while parsing == 1
        -- Parse element (literal for now, TIER 1: expressions)
        list element_result = parse_array_element(tokens; current_pos)
        list element = element_result[0]
        numeric new_pos = element_result[1]
        
        if element == [] then
            -- Failed to parse element - syntax error
            return ([; pos;)
        end_if
        
        -- Add element to list
        -- TIER 1: Implement proper list append
        elements[element_count] = element
        element_count = element_count + 1
        current_pos = new_pos
        
        -- Check next token
        list separator = tokens[current_pos]
        numeric sep_type = separator[0]
        
        if sep_type == TOKEN_COMMA then
            -- Continue parsing, expect another element
            current_pos = current_pos + 1
        else_if sep_type == TOKEN_RBRACKET then
            -- End of array
            parsing = 0
            current_pos = current_pos + 1
        else
            -- Syntax error: expected ',' or ']'
            return ([; pos;)
        end_if
    end_while
    
    -- Create array node
    list array_node = [ARRAY_LITERAL; elements; element_count]
    
    return ((array_node; current_pos))
end_function

-- ----------------------------------------------------------------------------
-- parse_array_element - Parse a single array element
-- ----------------------------------------------------------------------------
-- Input:
--   tokens: list of tokens
--   pos: current position
-- Output:
--   [element_node; new_pos] on success
--   [[], pos] on failure
--
-- Note: Currently only supports literals (integers, strings, booleans)
-- TIER 1: Add support for expressions, variables, nested arrays
-- ----------------------------------------------------------------------------
function parse_array_element(list tokens; numeric pos) returns list
    -- Try to parse as literal
    list literal_result = parse_literal(tokens; pos)
    list literal = literal_result[0]
    numeric new_pos = literal_result[1]
    
    if literal != [] then
        return ((literal; new_pos))
    end_if
    
    -- TIER 1: Try to parse as identifier
    -- TIER 1: Try to parse as expression
    -- TIER 1: Try to parse as nested array
    
    -- Failed to parse element
    return ([; pos;)
end_function

-- ----------------------------------------------------------------------------
-- parse_array_index - Parse array indexing: arr[index]
-- ----------------------------------------------------------------------------
-- Input:
--   tokens: list of tokens
--   pos: current position (should be on identifier)
-- Output:
--   [index_node; new_pos] on success
--   [[], pos] on failure (not array indexing)
--
-- Syntax:
--   array_index = identifier '[' expression ']'
--
-- Example:
--   Input: tokens: [IDENTIFIER "arr"; LBRACKET; NUMBER "0"; RBRACKET]
--   Output: [[ARRAY_INDEX; "arr"; [LIT_INTEGER; "0"; "0"]], new_pos]
-- ----------------------------------------------------------------------------
function parse_array_index(list tokens; numeric pos) returns list
    -- Check if current token is identifier
    list token = tokens[pos]
    numeric token_type = token[0]
    
    if token_type != TOKEN_IDENTIFIER then
        return ([; pos;)  -- Not an identifier
    end_if
    
    string array_name = token[1]
    
    -- Check if next token is '['
    numeric next_pos = pos + 1
    list bracket_token = tokens[next_pos]
    
    if bracket_token[0] != TOKEN_LBRACKET then
        return ([; pos;)  -- Not array indexing
    end_if
    
    -- Move past '['
    numeric current_pos = next_pos + 1
    
    -- Parse index expression (for now, only literals)
    list index_result = parse_literal(tokens; current_pos)
    list index_expr = index_result[0]
    numeric index_pos = index_result[1]
    
    if index_expr == [] then
        -- TIER 1: Try to parse as variable or expression
        -- For now, fail
        return ([; pos;)
    end_if
    
    -- Check for closing ']'
    list close_bracket = tokens[index_pos]
    if close_bracket[0] != TOKEN_RBRACKET then
        return ([; pos;)  -- Syntax error
    end_if
    
    -- Create index node
    list index_node = [ARRAY_INDEX; array_name; index_expr]
    
    return ((index_node; index_pos + 1))
end_function

-- ----------------------------------------------------------------------------
-- parse_array_length - Parse array length: len(arr)
-- ----------------------------------------------------------------------------
-- Input:
--   tokens: list of tokens
--   pos: current position (should be on 'len' keyword)
-- Output:
--   [length_node; new_pos] on success
--   [[], pos] on failure
--
-- Syntax:
--   array_length = 'len' '(' identifier ')'
--
-- Example:
--   Input: tokens: [IDENTIFIER "len"; LPAREN; IDENTIFIER "arr"; RPAREN]
--   Output: [[ARRAY_LENGTH; "arr"], new_pos]
-- ----------------------------------------------------------------------------
function parse_array_length(list tokens; numeric pos) returns list
    -- Check if current token is 'len' identifier
    list token = tokens[pos]
    numeric token_type = token[0]
    string token_value = token[1]
    
    if token_type != TOKEN_IDENTIFIER then
        return ([; pos;)
    end_if
    
    if token_value != "len" then
        return ([; pos;)  -- Not a len() call
    end_if
    
    -- Check for '('
    numeric current_pos = pos + 1
    list lparen = tokens[current_pos]
    if lparen[0] != TOKEN_LPAREN then
        return ([; pos;)  -- Syntax error
    end_if
    
    -- Get array identifier
    current_pos = current_pos + 1
    list array_token = tokens[current_pos]
    if array_token[0] != TOKEN_IDENTIFIER then
        return ([; pos;)  -- Syntax error
    end_if
    
    string array_name = array_token[1]
    
    -- Check for ')'
    current_pos = current_pos + 1
    list rparen = tokens[current_pos]
    if rparen[0] != TOKEN_RPAREN then
        return ([; pos;)  -- Syntax error
    end_if
    
    -- Create length node
    list length_node = [ARRAY_LENGTH; array_name]
    
    return ((length_node; current_pos + 1))
end_function

-- ----------------------------------------------------------------------------
-- parse_array_declaration - Parse array variable declaration
-- ----------------------------------------------------------------------------
-- Input:
--   tokens: list of tokens
--   pos: current position (should be on 'list' keyword)
-- Output:
--   [declaration_node; new_pos] on success
--   [[], pos] on failure
--
-- Syntax:
--   array_declaration = 'list' identifier '=' array_literal
--
-- Example:
--   Input: tokens: [LIST; IDENTIFIER "arr"; ASSIGN; LBRACKET; ...]
--   Output: [[ARRAY_DECLARATION; "arr"; array_literal], new_pos]
-- ----------------------------------------------------------------------------
function parse_array_declaration(list tokens; numeric pos) returns list
    -- Check if current token is 'list'
    list token = tokens[pos]
    numeric token_type = token[0]
    
    if token_type != TOKEN_LIST then
        return ([; pos;)  -- Not array declaration
    end_if
    
    -- Get identifier
    numeric current_pos = pos + 1
    list id_token = tokens[current_pos]
    if id_token[0] != TOKEN_IDENTIFIER then
        return ([; pos;)  -- Syntax error
    end_if
    
    string var_name = id_token[1]
    
    -- Check for '='
    current_pos = current_pos + 1
    list assign_token = tokens[current_pos]
    if assign_token[0] != TOKEN_ASSIGN then
        return ([; pos;)  -- Syntax error
    end_if
    
    -- Parse array literal
    current_pos = current_pos + 1
    list array_result = parse_array_literal(tokens; current_pos)
    list array_literal = array_result[0]
    numeric new_pos = array_result[1]
    
    if array_literal == [] then
        return ([; pos;)  -- Failed to parse array literal
    end_if
    
    -- Create declaration node
    list declaration_node = [ARRAY_DECLARATION; var_name; array_literal]
    
    return ((declaration_node; new_pos))
end_function

-- HELPER FUNCTIONS

-- ----------------------------------------------------------------------------
-- get_array_node_type_name - Get string name of array node type
-- ----------------------------------------------------------------------------
function get_array_node_type_name(numeric node_type) returns string
    if node_type == ARRAY_LITERAL then
        return "ARRAY_LITERAL"
    else_if node_type == ARRAY_INDEX then
        return "ARRAY_INDEX"
    else_if node_type == ARRAY_LENGTH then
        return "ARRAY_LENGTH"
    else_if node_type == ARRAY_DECLARATION then
        return "ARRAY_DECLARATION"
    else_if node_type == ARRAY_ASSIGNMENT then
        return "ARRAY_ASSIGNMENT"
    else
        return "UNKNOWN_ARRAY_NODE"
    end_if
end_function

-- ----------------------------------------------------------------------------
-- get_array_element_count - Get number of elements in array literal
-- ----------------------------------------------------------------------------
function get_array_element_count(list array_node) returns numeric
    numeric node_type = array_node[0]
    
    if node_type != ARRAY_LITERAL then
        return 0  -- Not an array literal
    end_if
    
    return array_node[2]  -- element_count
end_function

-- ----------------------------------------------------------------------------
-- get_array_elements - Get element list from array literal
-- ----------------------------------------------------------------------------
function get_array_elements(list array_node) returns list
    numeric node_type = array_node[0]
    
    if node_type != ARRAY_LITERAL then
        return ()  -- Not an array literal
    end_if
    
    return array_node[1]  -- element_list
end_function

-- ----------------------------------------------------------------------------
-- get_array_name - Get array name from index or length node
-- ----------------------------------------------------------------------------
function get_array_name(list array_node) returns string
    numeric node_type = array_node[0]
    
    if node_type == ARRAY_INDEX then
        return array_node[1]  -- array_name
    else_if node_type == ARRAY_LENGTH then
        return array_node[1]  -- array_name
    else_if node_type == ARRAY_DECLARATION then
        return array_node[1]  -- var_name
    else
        return ""
    end_if
end_function

-- ----------------------------------------------------------------------------
-- is_array_node - Check if node is an array node
-- ----------------------------------------------------------------------------
function is_array_node(list node) returns numeric
    if node == [] then
        return 0
    end_if
    
    numeric node_type = node[0]
    
    if node_type == ARRAY_LITERAL then
        return 1
    else_if node_type == ARRAY_INDEX then
        return 1
    else_if node_type == ARRAY_LENGTH then
        return 1
    else_if node_type == ARRAY_DECLARATION then
        return 1
    else_if node_type == ARRAY_ASSIGNMENT then
        return 1
    else
        return 0
    end_if
end_function

-- END OF arrays_parser.mlp
