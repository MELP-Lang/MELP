-- ============================================================================
-- MELP Compiler - Main Entry Point
-- ============================================================================
-- File: modules/compiler.mlp
-- Author: YZ_24 Part 2 + ÜA_00
-- Date: 22 Aralık 2025
-- Purpose: CLI driver for MELP compiler
-- Status: Stage 1 Self-Hosting - Main Module
-- ============================================================================
--
-- This is the main entry point for the MELP compiler.
-- It handles:
-- - Command-line argument parsing
-- - File I/O (read source, write LLVM IR)
-- - Calling compiler_integration.mlp pipeline
-- - Exit codes and error reporting
--
-- Usage:
--   melp_compiler <input.mlp> <output.ll>
--   melp_compiler --help
--   melp_compiler --version
-- ============================================================================

-- ============================================================================
-- IMPORTS
-- ============================================================================

-- NOTE: Import system not yet fully functional in Stage 0
-- Conceptual imports (functions must be available at link time):
-- - compiler_integration.mlp (compile_source function)
-- - lexer_mlp/lexer.mlp (tokenization)
-- - parser_mlp/parser_core.mlp (parsing)
-- - codegen_mlp/codegen_integration.mlp (code generation)

-- ============================================================================
-- VERSION INFORMATION
-- ============================================================================

function get_version() returns string
    return "0.1.0"
end_function

function get_compiler_name() returns string
    return "MELP Compiler"
end_function

function get_build_date() returns string
    return "17 Aralik 2025"
end_function

-- ============================================================================
-- HELP & USAGE
-- ============================================================================

function print_usage() returns numeric
    println("")
    println("========================================")
    println("  MELP Compiler - Usage")
    println("========================================")
    println("")
    println("Usage:")
    println("  melp <input.mlp> <output.ll>")
    println("")
    println("Arguments:")
    println("  input.mlp   - Source file to compile")
    println("  output.ll   - Output LLVM IR file")
    println("")
    println("Options:")
    println("  --help      - Show this help message")
    println("  --version   - Show version information")
    println("  --verbose   - Enable verbose output")
    println("")
    println("Examples:")
    println("  melp program.mlp program.ll")
    println("  melp --verbose test.mlp test.ll")
    println("")
    return 0
end_function

function print_version() returns numeric
    println("")
    println("========================================")
    println("MELP Compiler")
    println("========================================")
    println("Version: 0.1.0")
    println("Build:   17 Aralik 2025")
    println("")
    println("MELP Stage 1 Self-Hosting Compiler")
    println("Lexer -> Parser -> CodeGen -> LLVM IR")
    println("")
    return 0
end_function

-- ============================================================================
-- FILE I/O SIMULATION
-- ============================================================================

-- Note: Stage 0 doesn't have real file I/O
-- These are placeholder functions for the API

function read_source_file(string filename) returns string
    println("[INFO] Reading file:")
    println(filename)
    
    -- Use Stage 0's built-in read_file function
    string content = read_file(filename)
    
    return content
end_function

function write_output_file(string filename; string content) returns numeric
    println("[INFO] Writing file:")
    println(filename)
    
    -- Use Stage 0's built-in write_file function
    numeric result = write_file(filename; content)
    
    return result
end_function

function file_exists(string filename) returns numeric
    -- TODO: Check if file exists
    -- For now, assume it exists
    return 1
end_function

-- ============================================================================
-- ARGUMENT PARSING
-- ============================================================================

-- Parse command line arguments
-- Returns: status code (0 = success, 1 = error, 2 = help/version shown)
function parse_arguments() returns numeric
    -- Note: Stage 0 doesn't support argc/argv
    -- This is a placeholder for the API
    
    println("[INFO] Parsing command-line arguments")
    println("[INFO] Using default: input.mlp -> output.ll")
    
    return 0
end_function

-- ============================================================================
-- MAIN COMPILATION DRIVER
-- ============================================================================

-- ============================================================================
-- COMPILATION PIPELINE (REAL IMPLEMENTATION)
-- ============================================================================

-- NOTE: This function is defined in compiler_integration.mlp
-- For Stage 0 build, we need to either:
-- 1. Link with compiler_integration.mlp (preferred)
-- 2. Inline the implementation here (temporary)
--
-- Using inline approach for now until import system is stable

function compile_source(string source_code) returns string
    println("========================================")
    println("  MELP Compiler - Full Pipeline")
    println("========================================")
    println("")
    
    -- Phase 1: Lexical Analysis (REAL IMPLEMENTATION)
    println("Phase 1: Lexical Analysis...")
    println("  Tokenizing source code...")
    
    -- Initialize tokenization state
    numeric pos = 0
    numeric line = 1
    numeric col = 1
    numeric source_len = length(source_code)
    list tokens = []
    list result = []
    list token = []
    numeric token_count = 0
    
    -- Tokenization loop
    while pos < source_len
        -- Call lexer's tokenize_next function
        result = tokenize_next(source_code; pos; line; col)
        
        -- Extract results
        token = result[0]
        pos = result[1]
        col = result[2]
        line = result[3]
        
        -- Add token to list (if not EOF/unknown)
        numeric token_type = token[0]
        if token_type != 80 then
            -- Not EOF, add to tokens
            -- TODO: Proper list append when available
            token_count = token_count + 1
        end_if
        
        -- Break on EOF
        if token_type == 80 then
            exit
        end_if
    end_while
    
    println("  ✓ Tokenization complete: ")
    print(token_count)
    println(" tokens")
    println("")
    
    -- Phase 2: Parsing (REAL IMPLEMENTATION)
    println("Phase 2: Parsing...")
    println("  Building AST...")
    
    -- Call parser's parse_tokens function
    list ast = parse_tokens(tokens)
    
    println("  ✓ AST construction complete")
    println("")
    
    -- Phase 3: Code Generation (REAL IMPLEMENTATION)
    println("Phase 3: Code Generation...")
    println("  Generating LLVM IR...")
    
    -- Call codegen's codegen_ast function
    string llvm_ir = codegen_ast(ast)
    
    println("  ✓ LLVM IR generation complete")
    println("")
    
    -- Summary
    println("========================================")
    println("Compilation Summary:")
    println("  Status: SUCCESS")
    println("  Tokens: ")
    print(token_count)
    println("")
    println("  Phases: Lexer → Parser → CodeGen")
    println("========================================")
    println("")
    
    return llvm_ir
end_function

function compile_file(string input_file; string output_file) returns numeric
    println("")
    println("========================================")
    println("  MELP Compiler - Compilation")
    println("========================================")
    println("")
    println("Input:  ")
    println(input_file)
    println("Output: ")
    println(output_file)
    println("")
    
    -- Step 1: Read source file
    println("[1/3] Reading source file...")
    string source_code = read_source_file(input_file)
    
    if source_code == "" then
        println("[ERROR] Failed to read input file")
        return 1
    end_if
    
    println("  ✓ Source file read successfully")
    println("")
    
    -- Step 2: Compile source
    println("[2/3] Compiling...")
    string llvm_ir = compile_source(source_code)
    
    if llvm_ir == "" then
        println("[ERROR] Compilation failed")
        return 1
    end_if
    
    println("  ✓ Compilation successful")
    println("")
    
    -- Step 3: Write output file
    println("[3/3] Writing output file...")
    numeric write_result = write_output_file(output_file; llvm_ir)
    
    if write_result == 0 then
        println("[ERROR] Failed to write output file")
        return 1
    end_if
    
    println("  ✓ Output file written successfully")
    println("")
    
    -- Success!
    println("========================================")
    println("Compilation completed successfully!")
    println("========================================")
    println("")
    
    return 0
end_function

-- ============================================================================
-- MAIN ENTRY POINT
-- ============================================================================

function main() returns numeric
    println("")
    println("================================================")
    println("  MELP Compiler v0.1.0")
    println("  Stage 1 Self-Hosting Compiler")
    println("  Date: 17 Aralik 2025")
    println("================================================")
    println("")
    
    -- Parse arguments
    numeric arg_result = parse_arguments()
    
    if arg_result == 2 then
        -- Help or version was shown, exit
        return 0
    end_if
    
    if arg_result == 1 then
        -- Argument parsing error
        print_usage()
        return 1
    end_if
    
    -- Default compilation test
    println("[MODE] Test Mode - Using default files")
    println("")
    
    string input_file = "test.mlp"
    string output_file = "test.ll"
    
    -- Compile
    numeric result = compile_file(input_file; output_file)
    
    if result == 0 then
        println("================================================")
        println("  Status: SUCCESS")
        println("================================================")
        return 0
    else
        println("================================================")
        println("  Status: FAILED")
        println("================================================")
        return 1
    end_if
end_function
