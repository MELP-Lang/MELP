-- ============================================================================
-- test_literals.mlp - Test Suite for Literals Module
-- ============================================================================
-- Part of: Stage 1 Literals Module
-- Purpose: Comprehensive tests for literal parsing and code generation
-- Note: This file will be executed when Stage 1 compiler is ready
-- ============================================================================

-- Import modules to test
-- import "compiler/stage1/modules/core/token_types.mlp"
-- import "compiler/stage1/modules/literals/literals_parser.mlp"
-- import "compiler/stage1/modules/literals/literals_codegen.mlp"

-- ============================================================================
-- TEST UTILITIES
-- ============================================================================

numeric test_count = 0
numeric test_passed = 0
numeric test_failed = 0

function assert_equal(string test_name, string expected, string actual) returns numeric
    test_count = test_count + 1
    
    if expected == actual then
        test_passed = test_passed + 1
        print "✓ PASS: "
        print test_name
        print "\n"
        return 1
    end_if
    
    test_failed = test_failed + 1
    print "✗ FAIL: "
    print test_name
    print "\n"
    print "  Expected: "
    print expected
    print "\n"
    print "  Actual: "
    print actual
    print "\n"
    return 0
end_function

function assert_not_empty(string test_name, list result) returns numeric
    test_count = test_count + 1
    
    if result[0] != [] then
        test_passed = test_passed + 1
        print "✓ PASS: "
        print test_name
        print "\n"
        return 1
    end_if
    
    test_failed = test_failed + 1
    print "✗ FAIL: "
    print test_name
    print " (result is empty)\n"
    return 0
end_function

function print_test_summary() returns numeric
    print "\n"
    print "========================================\n"
    print "Test Summary\n"
    print "========================================\n"
    print "Total tests: "
    -- TIER 1: print test_count (numeric to string conversion)
    print "\n"
    print "Passed: "
    -- TIER 1: print test_passed
    print "\n"
    print "Failed: "
    -- TIER 1: print test_failed
    print "\n"
    
    if test_failed == 0 then
        print "\n✓ ALL TESTS PASSED!\n"
        return 1
    end_if
    
    print "\n✗ SOME TESTS FAILED\n"
    return 0
end_function

-- ============================================================================
-- TEST 1: Integer Literal Parsing
-- ============================================================================

function test_integer_literal_parsing() returns numeric
    print "\n[TEST 1] Integer Literal Parsing\n"
    print "================================\n"
    
    -- Test case 1: Simple positive integer
    list tokens1 = [[TOKEN_NUMBER; "42"]]
    list result1 = parse_integer_literal(tokens1, 0)
    list literal1 = result1[0]
    numeric new_pos1 = result1[1]
    
    -- Check literal type
    if literal1[0] != LIT_INTEGER then
        print "✗ FAIL: Expected LIT_INTEGER\n"
        return 0
    end_if
    
    -- Check value
    if literal1[1] != "42" then
        print "✗ FAIL: Expected value '42'\n"
        return 0
    end_if
    
    -- Check position
    if new_pos1 != 1 then
        print "✗ FAIL: Expected position 1\n"
        return 0
    end_if
    
    print "✓ PASS: Integer literal '42' parsed correctly\n"
    
    -- Test case 2: Zero
    list tokens2 = [[TOKEN_NUMBER; "0"]]
    list result2 = parse_integer_literal(tokens2, 0)
    list literal2 = result2[0]
    
    if literal2[1] != "0" then
        print "✗ FAIL: Expected value '0'\n"
        return 0
    end_if
    
    print "✓ PASS: Integer literal '0' parsed correctly\n"
    
    -- Test case 3: Large number
    list tokens3 = [[TOKEN_NUMBER; "123456789"]]
    list result3 = parse_integer_literal(tokens3, 0)
    list literal3 = result3[0]
    
    if literal3[1] != "123456789" then
        print "✗ FAIL: Expected value '123456789'\n"
        return 0
    end_if
    
    print "✓ PASS: Integer literal '123456789' parsed correctly\n"
    
    -- Test case 4: Non-number token (should fail gracefully)
    list tokens4 = [[TOKEN_IDENTIFIER; "abc"]]
    list result4 = parse_integer_literal(tokens4, 0)
    
    if result4[0] != [] then
        print "✗ FAIL: Should return empty for non-number token\n"
        return 0
    end_if
    
    print "✓ PASS: Non-number token handled correctly\n"
    
    return 1
end_function

-- ============================================================================
-- TEST 2: String Literal Parsing
-- ============================================================================

function test_string_literal_parsing() returns numeric
    print "\n[TEST 2] String Literal Parsing\n"
    print "================================\n"
    
    -- Test case 1: Simple string
    list tokens1 = [[TOKEN_STRING; "hello"]]
    list result1 = parse_string_literal(tokens1, 0)
    list literal1 = result1[0]
    
    if literal1[0] != LIT_STRING then
        print "✗ FAIL: Expected LIT_STRING\n"
        return 0
    end_if
    
    if literal1[1] != "hello" then
        print "✗ FAIL: Expected value 'hello'\n"
        return 0
    end_if
    
    print "✓ PASS: String literal 'hello' parsed correctly\n"
    
    -- Test case 2: Empty string
    list tokens2 = [[TOKEN_STRING; ""]]
    list result2 = parse_string_literal(tokens2, 0)
    list literal2 = result2[0]
    
    if literal2[1] != "" then
        print "✗ FAIL: Expected empty string\n"
        return 0
    end_if
    
    print "✓ PASS: Empty string literal parsed correctly\n"
    
    -- Test case 3: String with spaces
    list tokens3 = [[TOKEN_STRING; "hello world"]]
    list result3 = parse_string_literal(tokens3, 0)
    list literal3 = result3[0]
    
    if literal3[1] != "hello world" then
        print "✗ FAIL: Expected value 'hello world'\n"
        return 0
    end_if
    
    print "✓ PASS: String literal with spaces parsed correctly\n"
    
    -- Test case 4: Non-string token (should fail gracefully)
    list tokens4 = [[TOKEN_NUMBER; "42"]]
    list result4 = parse_string_literal(tokens4, 0)
    
    if result4[0] != [] then
        print "✗ FAIL: Should return empty for non-string token\n"
        return 0
    end_if
    
    print "✓ PASS: Non-string token handled correctly\n"
    
    return 1
end_function

-- ============================================================================
-- TEST 3: Boolean Literal Parsing
-- ============================================================================

function test_boolean_literal_parsing() returns numeric
    print "\n[TEST 3] Boolean Literal Parsing\n"
    print "=================================\n"
    
    -- Test case 1: true
    list tokens1 = [[TOKEN_TRUE; "true"]]
    list result1 = parse_boolean_literal(tokens1, 0)
    list literal1 = result1[0]
    
    if literal1[0] != LIT_BOOLEAN then
        print "✗ FAIL: Expected LIT_BOOLEAN for 'true'\n"
        return 0
    end_if
    
    if literal1[1] != 1 then
        print "✗ FAIL: Expected value 1 for 'true'\n"
        return 0
    end_if
    
    print "✓ PASS: Boolean literal 'true' parsed correctly\n"
    
    -- Test case 2: false
    list tokens2 = [[TOKEN_FALSE; "false"]]
    list result2 = parse_boolean_literal(tokens2, 0)
    list literal2 = result2[0]
    
    if literal2[0] != LIT_BOOLEAN then
        print "✗ FAIL: Expected LIT_BOOLEAN for 'false'\n"
        return 0
    end_if
    
    if literal2[1] != 0 then
        print "✗ FAIL: Expected value 0 for 'false'\n"
        return 0
    end_if
    
    print "✓ PASS: Boolean literal 'false' parsed correctly\n"
    
    -- Test case 3: Non-boolean token (should fail gracefully)
    list tokens3 = [[TOKEN_NUMBER; "42"]]
    list result3 = parse_boolean_literal(tokens3, 0)
    
    if result3[0] != [] then
        print "✗ FAIL: Should return empty for non-boolean token\n"
        return 0
    end_if
    
    print "✓ PASS: Non-boolean token handled correctly\n"
    
    return 1
end_function

-- ============================================================================
-- TEST 4: Generic Literal Parsing (Dispatcher)
-- ============================================================================

function test_generic_literal_parsing() returns numeric
    print "\n[TEST 4] Generic Literal Parsing\n"
    print "=================================\n"
    
    -- Test case 1: Parse integer
    list tokens1 = [[TOKEN_NUMBER; "100"]]
    list result1 = parse_literal(tokens1, 0)
    list literal1 = result1[0]
    
    if literal1[0] != LIT_INTEGER then
        print "✗ FAIL: parse_literal should recognize integer\n"
        return 0
    end_if
    
    print "✓ PASS: parse_literal correctly identified integer\n"
    
    -- Test case 2: Parse string
    list tokens2 = [[TOKEN_STRING; "test"]]
    list result2 = parse_literal(tokens2, 0)
    list literal2 = result2[0]
    
    if literal2[0] != LIT_STRING then
        print "✗ FAIL: parse_literal should recognize string\n"
        return 0
    end_if
    
    print "✓ PASS: parse_literal correctly identified string\n"
    
    -- Test case 3: Parse boolean
    list tokens3 = [[TOKEN_TRUE; "true"]]
    list result3 = parse_literal(tokens3, 0)
    list literal3 = result3[0]
    
    if literal3[0] != LIT_BOOLEAN then
        print "✗ FAIL: parse_literal should recognize boolean\n"
        return 0
    end_if
    
    print "✓ PASS: parse_literal correctly identified boolean\n"
    
    -- Test case 4: Non-literal token
    list tokens4 = [[TOKEN_IDENTIFIER; "variable"]]
    list result4 = parse_literal(tokens4, 0)
    
    if result4[0] != [] then
        print "✗ FAIL: parse_literal should return empty for identifier\n"
        return 0
    end_if
    
    print "✓ PASS: parse_literal correctly rejected identifier\n"
    
    return 1
end_function

-- ============================================================================
-- TEST 5: Integer Literal Code Generation
-- ============================================================================

function test_integer_codegen() returns numeric
    print "\n[TEST 5] Integer Literal Code Generation\n"
    print "=========================================\n"
    
    -- Test case 1: Generate code for integer literal
    list literal1 = [LIT_INTEGER; "42"; "42"]
    list result1 = codegen_literal(literal1, "x", "  ", 0)
    string code1 = result1[0]
    
    -- Check if code contains expected elements
    -- TIER 1: Implement proper string contains check
    print "Generated code:\n"
    print code1
    
    print "✓ PASS: Integer codegen executed\n"
    
    -- Test case 2: Immediate value (no assignment)
    string immediate = codegen_integer_literal(literal1, "", "")
    
    if immediate != "42" then
        print "✗ FAIL: Expected immediate value '42'\n"
        return 0
    end_if
    
    print "✓ PASS: Integer immediate value correct\n"
    
    return 1
end_function

-- ============================================================================
-- TEST 6: String Literal Code Generation
-- ============================================================================

function test_string_codegen() returns numeric
    print "\n[TEST 6] String Literal Code Generation\n"
    print "========================================\n"
    
    -- Test case 1: Generate code for string literal
    list literal1 = [LIT_STRING; "hello"; "\"hello\""]
    list result1 = codegen_literal(literal1, "str", "  ", 1)
    string code1 = result1[0]
    string global1 = result1[1]
    
    print "Generated code:\n"
    print code1
    print "\nGlobal declaration:\n"
    print global1
    
    print "\n✓ PASS: String codegen executed\n"
    
    -- Test case 2: Check LLVM type
    string llvm_type = get_literal_llvm_type(literal1)
    
    if llvm_type != "i8*" then
        print "✗ FAIL: Expected LLVM type 'i8*' for string\n"
        return 0
    end_if
    
    print "✓ PASS: String LLVM type correct (i8*)\n"
    
    return 1
end_function

-- ============================================================================
-- TEST 7: Boolean Literal Code Generation
-- ============================================================================

function test_boolean_codegen() returns numeric
    print "\n[TEST 7] Boolean Literal Code Generation\n"
    print "=========================================\n"
    
    -- Test case 1: true
    list literal1 = [LIT_BOOLEAN; 1; "true"]
    list result1 = codegen_literal(literal1, "flag", "  ", 0)
    string code1 = result1[0]
    
    print "Generated code for 'true':\n"
    print code1
    
    print "✓ PASS: Boolean true codegen executed\n"
    
    -- Test case 2: false
    list literal2 = [LIT_BOOLEAN; 0; "false"]
    list result2 = codegen_literal(literal2, "flag", "  ", 0)
    string code2 = result2[0]
    
    print "Generated code for 'false':\n"
    print code2
    
    print "✓ PASS: Boolean false codegen executed\n"
    
    -- Test case 3: Check LLVM type
    string llvm_type = get_literal_llvm_type(literal1)
    
    if llvm_type != "i1" then
        print "✗ FAIL: Expected LLVM type 'i1' for boolean\n"
        return 0
    end_if
    
    print "✓ PASS: Boolean LLVM type correct (i1)\n"
    
    return 1
end_function

-- ============================================================================
-- TEST 8: Helper Functions
-- ============================================================================

function test_helper_functions() returns numeric
    print "\n[TEST 8] Helper Functions\n"
    print "=========================\n"
    
    -- Test get_literal_type_name
    string type_name1 = get_literal_type_name(LIT_INTEGER)
    if type_name1 != "INTEGER" then
        print "✗ FAIL: Expected 'INTEGER'\n"
        return 0
    end_if
    print "✓ PASS: get_literal_type_name(LIT_INTEGER) = 'INTEGER'\n"
    
    string type_name2 = get_literal_type_name(LIT_STRING)
    if type_name2 != "STRING" then
        print "✗ FAIL: Expected 'STRING'\n"
        return 0
    end_if
    print "✓ PASS: get_literal_type_name(LIT_STRING) = 'STRING'\n"
    
    string type_name3 = get_literal_type_name(LIT_BOOLEAN)
    if type_name3 != "BOOLEAN" then
        print "✗ FAIL: Expected 'BOOLEAN'\n"
        return 0
    end_if
    print "✓ PASS: get_literal_type_name(LIT_BOOLEAN) = 'BOOLEAN'\n"
    
    -- Test is_literal_token
    numeric is_lit1 = is_literal_token(TOKEN_NUMBER)
    if is_lit1 != 1 then
        print "✗ FAIL: TOKEN_NUMBER should be literal\n"
        return 0
    end_if
    print "✓ PASS: is_literal_token(TOKEN_NUMBER) = 1\n"
    
    numeric is_lit2 = is_literal_token(TOKEN_IDENTIFIER)
    if is_lit2 != 0 then
        print "✗ FAIL: TOKEN_IDENTIFIER should not be literal\n"
        return 0
    end_if
    print "✓ PASS: is_literal_token(TOKEN_IDENTIFIER) = 0\n"
    
    -- Test is_constant_literal
    list literal = [LIT_INTEGER; "42"; "42"]
    numeric is_const = is_constant_literal(literal)
    if is_const != 1 then
        print "✗ FAIL: All literals should be constant\n"
        return 0
    end_if
    print "✓ PASS: is_constant_literal returns 1\n"
    
    return 1
end_function

-- ============================================================================
-- TEST 9: Type Inference
-- ============================================================================

function test_type_inference() returns numeric
    print "\n[TEST 9] Type Inference\n"
    print "========================\n"
    
    -- Test integer type inference
    list int_lit = [LIT_INTEGER; "42"; "42"]
    numeric inferred_type1 = infer_literal_type(int_lit)
    if inferred_type1 != TYPE_NUMERIC then
        print "✗ FAIL: Integer should infer to TYPE_NUMERIC\n"
        return 0
    end_if
    print "✓ PASS: Integer literal infers to TYPE_NUMERIC\n"
    
    -- Test string type inference
    list str_lit = [LIT_STRING; "hello"; "\"hello\""]
    numeric inferred_type2 = infer_literal_type(str_lit)
    if inferred_type2 != TYPE_STRING then
        print "✗ FAIL: String should infer to TYPE_STRING\n"
        return 0
    end_if
    print "✓ PASS: String literal infers to TYPE_STRING\n"
    
    -- Test boolean type inference
    list bool_lit = [LIT_BOOLEAN; 1; "true"]
    numeric inferred_type3 = infer_literal_type(bool_lit)
    if inferred_type3 != TYPE_BOOLEAN then
        print "✗ FAIL: Boolean should infer to TYPE_BOOLEAN\n"
        return 0
    end_if
    print "✓ PASS: Boolean literal infers to TYPE_BOOLEAN\n"
    
    return 1
end_function

-- ============================================================================
-- TEST 10: LLVM Type Mapping
-- ============================================================================

function test_llvm_type_mapping() returns numeric
    print "\n[TEST 10] LLVM Type Mapping\n"
    print "============================\n"
    
    -- Test integer → i64
    list int_lit = [LIT_INTEGER; "42"; "42"]
    string llvm_type1 = get_literal_llvm_type(int_lit)
    if llvm_type1 != "i64" then
        print "✗ FAIL: Integer should map to 'i64'\n"
        return 0
    end_if
    print "✓ PASS: Integer → i64\n"
    
    -- Test string → i8*
    list str_lit = [LIT_STRING; "hi"; "\"hi\""]
    string llvm_type2 = get_literal_llvm_type(str_lit)
    if llvm_type2 != "i8*" then
        print "✗ FAIL: String should map to 'i8*'\n"
        return 0
    end_if
    print "✓ PASS: String → i8*\n"
    
    -- Test boolean → i1
    list bool_lit = [LIT_BOOLEAN; 1; "true"]
    string llvm_type3 = get_literal_llvm_type(bool_lit)
    if llvm_type3 != "i1" then
        print "✗ FAIL: Boolean should map to 'i1'\n"
        return 0
    end_if
    print "✓ PASS: Boolean → i1\n"
    
    return 1
end_function

-- ============================================================================
-- MAIN TEST RUNNER
-- ============================================================================

function main() returns numeric
    print "\n"
    print "========================================\n"
    print "MELP Stage 1 - Literals Module Tests\n"
    print "========================================\n"
    
    -- Run all tests
    numeric result1 = test_integer_literal_parsing()
    numeric result2 = test_string_literal_parsing()
    numeric result3 = test_boolean_literal_parsing()
    numeric result4 = test_generic_literal_parsing()
    numeric result5 = test_integer_codegen()
    numeric result6 = test_string_codegen()
    numeric result7 = test_boolean_codegen()
    numeric result8 = test_helper_functions()
    numeric result9 = test_type_inference()
    numeric result10 = test_llvm_type_mapping()
    
    -- Print summary
    numeric all_passed = print_test_summary()
    
    return all_passed
end_function

-- ============================================================================
-- END OF TEST SUITE
-- ============================================================================
