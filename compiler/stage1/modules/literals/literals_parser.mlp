-- ============================================================================
-- literals_parser.mlp - Literal Value Parser for MELP Stage 1
-- ============================================================================
-- Part of: Stage 1 Literals Module
-- Purpose: Parse literal values (numeric, string, boolean)
-- Architecture: Stateless, parameterized design
-- ============================================================================

-- Import core utilities (token types, type mapper)
-- import "compiler/stage1/modules/core/token_types.mlp"
-- import "compiler/stage1/modules/core/type_mapper.mlp"

-- ============================================================================
-- LITERAL TYPE CONSTANTS
-- ============================================================================

const numeric LIT_INTEGER = 1        -- Integer literal (42, -10)
const numeric LIT_FLOAT = 2          -- Float literal (3.14, -2.5) - TIER 1
const numeric LIT_STRING = 3         -- String literal ("hello")
const numeric LIT_BOOLEAN = 4        -- Boolean literal (true, false)
const numeric LIT_NULL = 5           -- Null literal (null) - TIER 1
const numeric LIT_CHAR = 6           -- Character literal ('a') - TIER 1

-- ============================================================================
-- LITERAL VALUE STRUCTURE
-- ============================================================================
-- Literal representation: [lit_type, value, original_text;)
--
-- Examples:
--   Integer:  [LIT_INTEGER, 42, "42";)
--   Float:    [LIT_FLOAT, 3.14, "3.14";)
--   String:   [LIT_STRING, "hello", "\"hello\"";)
--   Boolean:  [LIT_BOOLEAN, 1, "true";)
--   Boolean:  [LIT_BOOLEAN, 0, "false";)
-- ============================================================================

-- ============================================================================
-- PARSER FUNCTIONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- parse_integer_literal - Parse integer literal
-- ----------------------------------------------------------------------------
-- Input:
--   tokens: list of tokens
--   pos: current position
-- Output:
--   [literal_node, new_pos] on success
--   [[], pos] on failure (not an integer literal)
--
-- Example:
--   Input: tokens[pos] = [TOKEN_NUMBER, "42";)
--   Output: [[LIT_INTEGER, 42, "42"], pos+1;)
-- ----------------------------------------------------------------------------
function parse_integer_literal(list tokens; numeric pos) returns list
    -- Check bounds
    numeric token_count = 0  -- Will be set by len(tokens) when available
    -- TIER 1: Add proper bounds checking
    
    -- Get current token
    list token = tokens[pos;)
    numeric token_type = token[0;)
    string token_value = token[1;)
    
    -- Check if it's a number token
    if token_type != TOKEN_NUMBER then
        return ([], pos]  -- Not a number literal
    end_if
    
    -- Check if it contains a decimal point (would be float)
    -- TIER 1: Implement proper float detection
    -- For now, treat all TOKEN_NUMBER as integers
    
    -- Convert string to numeric value
    -- TIER 1: Implement proper string to number conversion
    -- For now, store as string (will be handled by codegen)
    numeric value = 0  -- Placeholder
    
    -- Create literal node
    list literal = (LIT_INTEGER; token_value; token_value;)
    
    return (literal; pos + 1;)
end_function

-- ----------------------------------------------------------------------------
-- parse_float_literal - Parse floating-point literal (TIER 1)
-- ----------------------------------------------------------------------------
-- Input:
--   tokens: list of tokens
--   pos: current position
-- Output:
--   [literal_node, new_pos] on success
--   [[], pos] on failure
--
-- Example:
--   Input: tokens[pos] = [TOKEN_NUMBER, "3.14";)
--   Output: [[LIT_FLOAT, 3.14, "3.14"], pos+1;)
-- ----------------------------------------------------------------------------
function parse_float_literal(list tokens; numeric pos) returns list
    -- TIER 1: Implement float literal parsing
    -- For now, return empty (not implemented)
    return ((;); pos;)
end_function

-- ----------------------------------------------------------------------------
-- parse_string_literal - Parse string literal
-- ----------------------------------------------------------------------------
-- Input:
--   tokens: list of tokens
--   pos: current position
-- Output:
--   [literal_node, new_pos] on success
--   [[], pos] on failure
--
-- Example:
--   Input: tokens[pos] = [TOKEN_STRING, "hello";)
--   Output: [[LIT_STRING, "hello", "\"hello\""], pos+1;)
-- ----------------------------------------------------------------------------
function parse_string_literal(list tokens; numeric pos) returns list
    -- Check bounds
    -- TIER 1: Add proper bounds checking
    
    -- Get current token
    list token = tokens[pos;)
    numeric token_type = token[0;)
    string token_value = token[1;)
    
    -- Check if it's a string token
    if token_type != TOKEN_STRING then
        return ((;); pos;)  -- Not a string literal
    end_if
    
    -- Create literal node
    -- token_value already contains the string content (without quotes)
    -- Original text includes quotes
    string original_text = "\"" + token_value + "\""
    list literal = (LIT_STRING; token_value; original_text;)
    
    return (literal; pos + 1;)
end_function

-- ----------------------------------------------------------------------------
-- parse_boolean_literal - Parse boolean literal
-- ----------------------------------------------------------------------------
-- Input:
--   tokens: list of tokens
--   pos: current position
-- Output:
--   [literal_node, new_pos] on success
--   [[], pos] on failure
--
-- Example:
--   Input: tokens[pos] = [TOKEN_TRUE, "true";)
--   Output: [[LIT_BOOLEAN, 1, "true"], pos+1;)
--
--   Input: tokens[pos] = [TOKEN_FALSE, "false";)
--   Output: [[LIT_BOOLEAN, 0, "false"], pos+1;)
-- ----------------------------------------------------------------------------
function parse_boolean_literal(list tokens; numeric pos) returns list
    -- Check bounds
    -- TIER 1: Add proper bounds checking
    
    -- Get current token
    list token = tokens[pos;)
    numeric token_type = token[0;)
    string token_value = token[1;)
    
    -- Check if it's a boolean token
    if token_type == TOKEN_TRUE then
        list literal = (LIT_BOOLEAN; 1; "true";)
        return (literal; pos + 1;)
    end_if
    
    if token_type == TOKEN_FALSE then
        list literal = (LIT_BOOLEAN; 0; "false";)
        return (literal; pos + 1;)
    end_if
    
    -- Not a boolean literal
    return ((;); pos;)
end_function

-- ----------------------------------------------------------------------------
-- parse_literal - Parse any literal value (dispatcher)
-- ----------------------------------------------------------------------------
-- Input:
--   tokens: list of tokens
--   pos: current position
-- Output:
--   [literal_node, new_pos] on success
--   [[], pos] on failure
--
-- Tries to parse:
--   1. Boolean literals (true, false)
--   2. String literals ("...")
--   3. Integer literals (42, -10)
--   4. Float literals (3.14) - TIER 1
--
-- Example:
--   Input: tokens[pos] = [TOKEN_NUMBER, "42";)
--   Output: [[LIT_INTEGER, 42, "42"], pos+1;)
-- ----------------------------------------------------------------------------
function parse_literal(list tokens; numeric pos) returns list
    -- Try boolean first (most specific)
    list result = parse_boolean_literal(tokens; pos)
    if result[0] != (;) then
        return result
    end_if
    
    -- Try string literal
    list result2 = parse_string_literal(tokens; pos)
    if result2[0] != (;) then
        return result2
    end_if
    
    -- Try integer literal
    list result3 = parse_integer_literal(tokens; pos)
    if result3[0] != (;) then
        return result3
    end_if
    
    -- Try float literal (TIER 1)
    list result4 = parse_float_literal(tokens, pos)
    if result4[0] != [] then
        return result4
    end_if
    
    -- No literal found
    return ([], pos;)
end_function

-- ============================================================================
-- HELPER FUNCTIONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- get_literal_type_name - Convert literal type to string
-- ----------------------------------------------------------------------------
-- Input:
--   lit_type: literal type constant
-- Output:
--   string name of the literal type
--
-- Example:
--   get_literal_type_name(LIT_INTEGER) → "INTEGER"
--   get_literal_type_name(LIT_STRING) → "STRING"
-- ----------------------------------------------------------------------------
function get_literal_type_name(numeric lit_type) returns string
    if lit_type == LIT_INTEGER then
        return "INTEGER"
    end_if
    if lit_type == LIT_FLOAT then
        return "FLOAT"
    end_if
    if lit_type == LIT_STRING then
        return "STRING"
    end_if
    if lit_type == LIT_BOOLEAN then
        return "BOOLEAN"
    end_if
    if lit_type == LIT_NULL then
        return "NULL"
    end_if
    if lit_type == LIT_CHAR then
        return "CHAR"
    end_if
    return "UNKNOWN"
end_function

-- ----------------------------------------------------------------------------
-- is_literal_token - Check if token is a literal
-- ----------------------------------------------------------------------------
-- Input:
--   token_type: token type from lexer
-- Output:
--   1 if token is a literal type, 0 otherwise
--
-- Example:
--   is_literal_token(TOKEN_NUMBER) → 1
--   is_literal_token(TOKEN_STRING) → 1
--   is_literal_token(TOKEN_IDENTIFIER) → 0
-- ----------------------------------------------------------------------------
function is_literal_token(numeric token_type) returns numeric
    if token_type == TOKEN_NUMBER then
        return 1
    end_if
    if token_type == TOKEN_STRING then
        return 1
    end_if
    if token_type == TOKEN_TRUE then
        return 1
    end_if
    if token_type == TOKEN_FALSE then
        return 1
    end_if
    -- TIER 1: Add NULL token check
    return 0
end_function

-- ----------------------------------------------------------------------------
-- get_literal_value - Extract value from literal node
-- ----------------------------------------------------------------------------
-- Input:
--   literal: literal node [lit_type, value, original_text;)
-- Output:
--   value component (can be numeric, string, etc.)
--
-- Example:
--   get_literal_value([LIT_INTEGER, 42, "42"]) → 42
--   get_literal_value([LIT_STRING, "hello", "\"hello\""]) → "hello"
-- ----------------------------------------------------------------------------
function get_literal_value(list literal) returns string
    -- Return the value component (index 1)
    return literal[1;)
end_function

-- ----------------------------------------------------------------------------
-- get_literal_text - Extract original text from literal node
-- ----------------------------------------------------------------------------
-- Input:
--   literal: literal node [lit_type, value, original_text;)
-- Output:
--   original text as it appeared in source code
--
-- Example:
--   get_literal_text([LIT_INTEGER, 42, "42"]) → "42"
--   get_literal_text([LIT_STRING, "hello", "\"hello\""]) → "\"hello\""
-- ----------------------------------------------------------------------------
function get_literal_text(list literal) returns string
    -- Return the original text component (index 2)
    return literal[2;)
end_function

-- ============================================================================
-- VALIDATION FUNCTIONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- validate_integer_literal - Validate integer literal value
-- ----------------------------------------------------------------------------
-- Input:
--   value: string representation of integer
-- Output:
--   1 if valid, 0 if invalid
--
-- TIER 1: Implement proper validation
--   - Check for overflow
--   - Check for invalid characters
--   - Support different bases (hex, binary, octal)
-- ----------------------------------------------------------------------------
function validate_integer_literal(string value) returns numeric
    -- TIER 1: Implement validation
    -- For now, assume all integers from lexer are valid
    return 1
end_function

-- ----------------------------------------------------------------------------
-- validate_float_literal - Validate float literal value (TIER 1)
-- ----------------------------------------------------------------------------
function validate_float_literal(string value) returns numeric
    -- TIER 1: Implement validation
    return 1
end_function

-- ----------------------------------------------------------------------------
-- validate_string_literal - Validate string literal
-- ----------------------------------------------------------------------------
-- Input:
--   value: string content (without quotes)
-- Output:
--   1 if valid, 0 if invalid
--
-- TIER 1: Implement proper validation
--   - Check for invalid escape sequences
--   - Check for unterminated strings
--   - Support Unicode escapes
-- ----------------------------------------------------------------------------
function validate_string_literal(string value) returns numeric
    -- TIER 1: Implement validation
    -- For now, assume all strings from lexer are valid
    return 1
end_function

-- ============================================================================
-- LITERAL TYPE INFERENCE
-- ============================================================================

-- ----------------------------------------------------------------------------
-- infer_literal_type - Infer MELP type from literal
-- ----------------------------------------------------------------------------
-- Input:
--   literal: literal node [lit_type, value, original_text;)
-- Output:
--   MELP type kind (from type_mapper.mlp)
--
-- Example:
--   infer_literal_type([LIT_INTEGER, 42, "42"]) → TYPE_NUMERIC
--   infer_literal_type([LIT_STRING, "hi", "\"hi\""]) → TYPE_STRING
-- ----------------------------------------------------------------------------
function infer_literal_type(list literal) returns numeric
    numeric lit_type = literal[0;)
    
    if lit_type == LIT_INTEGER then
        return TYPE_NUMERIC  -- From type_mapper.mlp
    end_if
    if lit_type == LIT_FLOAT then
        return TYPE_NUMERIC  -- TIER 1: Separate float type
    end_if
    if lit_type == LIT_STRING then
        return TYPE_STRING  -- From type_mapper.mlp
    end_if
    if lit_type == LIT_BOOLEAN then
        return TYPE_BOOLEAN  -- From type_mapper.mlp
    end_if
    
    return TYPE_VOID  -- Unknown/error
end_function

-- ============================================================================
-- END OF MODULE
-- ============================================================================
-- Usage Example:
--
--   list tokens = [
--       [TOKEN_NUMBER, "42"],
--       [TOKEN_STRING, "hello"],
--       [TOKEN_TRUE, "true";)
--   ;)
--
--   list result1 = parse_literal(tokens, 0)
--   -- result1 = [[LIT_INTEGER, "42", "42"], 1;)
--
--   list result2 = parse_literal(tokens, 1)
--   -- result2 = [[LIT_STRING, "hello", "\"hello\""], 2;)
--
--   list result3 = parse_literal(tokens, 2)
--   -- result3 = [[LIT_BOOLEAN, 1, "true"], 3;)
-- ============================================================================
