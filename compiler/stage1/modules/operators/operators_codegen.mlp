-- ============================================================================
-- MELP Stage 1 - Operators CodeGen Module
-- ============================================================================
-- Purpose: Generate LLVM IR for arithmetic, comparison, and logical operators
-- Author: YZ_06
-- Date: 18 AralÄ±k 2025
-- Source: Stage 0 arithmetic_codegen.c, comparison_codegen.c
-- Dependencies: core/type_mapper.mlp, operators_parser.mlp
-- ============================================================================

import "../core/type_mapper.mlp"
import "operators_parser.mlp"

-- ============================================================================
-- LLVM IR GENERATION - ARITHMETIC OPERATIONS
-- ============================================================================

-- Generate LLVM IR for arithmetic binary operation
-- expr: Expression node [node_type, value, left, right, operator]
-- result_reg: Register name for result (e.g., "%1")
-- indent: Indentation string for formatting
-- Returns: LLVM IR code as string
function codegen_logical_unary(list expr; string result_reg; string indent) returns string
    numeric op = get_expr_operator(expr)
    list left = get_expr_left(expr)
    list right = get_expr_right(expr)
    
    string code = ""
    
    -- Generate code for left operand
    string left_reg = "%temp_left"
    code = code + codegen_expression(left; left_reg; indent)
    
    -- Generate code for right operand
    string right_reg = "%temp_right"
    code = code + codegen_expression(right; right_reg; indent)
    
    -- Generate operation instruction
    string comment = "; " + get_operator_name(op) + " operation"
    
    if op == OP_ADD then
        code = code + indent + result_reg + " = add i64 " + left_reg + ", " + right_reg + "  " + comment + "\n"
    end_if
    
    if op == OP_SUB then
        code = code + indent + result_reg + " = sub i64 " + left_reg + ", " + right_reg + "  " + comment + "\n"
    end_if
    
    if op == OP_MUL then
        code = code + indent + result_reg + " = mul i64 " + left_reg + ", " + right_reg + "  " + comment + "\n"
    end_if
    
    if op == OP_DIV then
        code = code + indent + result_reg + " = sdiv i64 " + left_reg + ", " + right_reg + "  " + comment + "\n"
    end_if
    
    if op == OP_MOD then
        code = code + indent + result_reg + " = srem i64 " + left_reg + ", " + right_reg + "  " + comment + "\n"
    end_if
    
    if op == OP_POW then
        -- Power operation: call @llvm.powi intrinsic
        code = code + indent + result_reg + " = call i64 @llvm.powi.i64(i64 " + left_reg + ", i32 " + right_reg + ")  " + comment + "\n"
    end_if
    
    if op == OP_BIT_AND then
        code = code + indent + result_reg + " = and i64 " + left_reg + ", " + right_reg + "  " + comment + "\n"
    end_if
    
    if op == OP_BIT_OR then
        code = code + indent + result_reg + " = or i64 " + left_reg + ", " + right_reg + "  " + comment + "\n"
    end_if
    
    if op == OP_BIT_XOR then
        code = code + indent + result_reg + " = xor i64 " + left_reg + ", " + right_reg + "  " + comment + "\n"
    end_if
    
    return code
end_function

-- ============================================================================
-- LLVM IR GENERATION - COMPARISON OPERATIONS
-- ============================================================================

-- Generate LLVM IR for comparison binary operation
-- Returns i1 (boolean) result
function codegen_comparison_binary(list expr; string result_reg; string indent) returns string
    numeric op = get_expr_operator(expr)
    list left = get_expr_left(expr)
    list right = get_expr_right(expr)
    
    string code = ""
    
    -- Generate code for left operand
    string left_reg = "%temp_left"
    code = code + codegen_expression(left; left_reg; indent)
    
    -- Generate code for right operand
    string right_reg = "%temp_right"
    code = code + codegen_expression(right; right_reg; indent)
    
    -- Generate comparison instruction
    string comment = "; " + get_operator_name(op) + " comparison"
    string condition = ""
    
    if op == OP_EQ then
        condition = "eq"
    end_if
    if op == OP_NE then
        condition = "ne"
    end_if
    if op == OP_LT then
        condition = "slt"  -- signed less than
    end_if
    if op == OP_GT then
        condition = "sgt"  -- signed greater than
    end_if
    if op == OP_LE then
        condition = "sle"  -- signed less or equal
    end_if
    if op == OP_GE then
        condition = "sge"  -- signed greater or equal
    end_if
    
    code = code + indent + result_reg + " = icmp " + condition + " i64 " + left_reg + ", " + right_reg + "  " + comment + "\n"
    
    return code
end_function

-- ============================================================================
-- LLVM IR GENERATION - LOGICAL OPERATIONS
-- ============================================================================

-- Generate LLVM IR for logical binary operation (and, or)
function codegen_logical_binary(list expr; string result_reg; string indent) returns string
    numeric op = get_expr_operator(expr)
    list left = get_expr_left(expr)
    list right = get_expr_right(expr)
    
    string code = ""
    
    -- Generate code for left operand (should be i1)
    string left_reg = "%temp_left_bool"
    code = code + codegen_expression(left; left_reg; indent)
    
    -- Generate code for right operand (should be i1)
    string right_reg = "%temp_right_bool"
    code = code + codegen_expression(right; right_reg; indent)
    
    -- Generate logical instruction
    string comment = "; " + get_operator_name(op) + " operation"
    
    if op == OP_AND then
        code = code + indent + result_reg + " = and i1 " + left_reg + ", " + right_reg + "  " + comment + "\n"
    end_if
    
    if op == OP_OR then
        code = code + indent + result_reg + " = or i1 " + left_reg + ", " + right_reg + "  " + comment + "\n"
    end_if
    
    return code
end_function

-- Generate LLVM IR for logical unary operation (not)
function codegen_logical_unary(list expr; string result_reg; string indent) returns string
    numeric op = get_expr_operator(expr)
    list operand = get_expr_left(expr)
    
    string code = ""
    
    -- Generate code for operand
    string operand_reg = "%temp_operand"
    code = code + codegen_expression(operand; operand_reg; indent)
    
    -- Generate NOT instruction (XOR with true)
    string comment = "; not operation"
    code = code + indent + result_reg + " = xor i1 " + operand_reg + ", true  " + comment + "\n"
    
    return code
end_function

-- ============================================================================
-- EXPRESSION CODE GENERATION (Recursive)
-- ============================================================================

-- Generate LLVM IR for any expression
function codegen_expression(list expr; string result_reg; string indent) returns string
    if expr == 0 then
        return ""
    end_if
    
    numeric expr_type = get_expr_type(expr)
    
    -- Literal value
    if expr_type == EXPR_LITERAL then
        string value = get_expr_value(expr)
        string code = ""
        
        -- Boolean literals
        if value == "true" then
            code = code + indent + result_reg + " = add i1 0, 1  ; true\n"
            return code
        end_if
        if value == "false" then
            code = code + indent + result_reg + " = add i1 0, 0  ; false\n"
            return code
        end_if
        
        -- Numeric literal
        code = code + indent + result_reg + " = add i64 0, " + value + "  ; literal\n"
        return code
    end_if
    
    -- Variable reference
    if expr_type == EXPR_VARIABLE then
        string var_name = get_expr_value(expr)
        string code = ""
        
        -- Load variable value
        code = code + indent + "; Load variable: " + var_name + "\n"
        code = code + indent + result_reg + " = load i64, i64* %" + var_name + ", align 8\n"
        return code
    end_if
    
    -- Binary operation
    if expr_type == EXPR_BINARY then
        numeric op = get_expr_operator(expr)
        
        -- Arithmetic operations
        if op >= OP_ADD then
            if op <= OP_BIT_XOR then
                return codegen_arithmetic_binary(expr; result_reg; indent)
            end_if
        end_if
        
        -- Comparison operations
        if op >= OP_EQ then
            if op <= OP_GE then
                return codegen_comparison_binary(expr; result_reg; indent)
            end_if
        end_if
        
        -- Logical operations
        if op == OP_AND then
            return codegen_logical_binary(expr, result_reg, indent)
        end_if
        if op == OP_OR then
            return codegen_logical_binary(expr, result_reg, indent)
        end_if
    end_if
    
    -- Unary operation
    if expr_type == EXPR_UNARY then
        numeric op = get_expr_operator(expr)
        
        -- Logical NOT
        if op == OP_NOT then
            return codegen_logical_unary(expr, result_reg, indent)
        end_if
        
        -- Unary minus (negation)
        if op == OP_SUB then
            list operand = get_expr_left(expr)
            string code = ""
            string operand_reg = "%temp_operand"
            code = code + codegen_expression(operand; operand_reg; indent)
            code = code + indent + result_reg + " = sub i64 0, " + operand_reg + "  ; unary minus\n"
            return code
        end_if
    end_if
    
    return ""
end_function

-- ============================================================================
-- COMPLETE OPERATION CODE GENERATION
-- ============================================================================

-- Generate complete LLVM IR for an operator expression
-- expr: Expression node from parser
-- target_var: Optional variable to store result (or "" for temp)
-- Returns: Complete LLVM IR code
function codegen_operator_expression(list expr; string target_var) returns string
    if expr == 0 then
        return ""
    end_if
    
    string code = ""
    string indent = "  "
    
    -- Determine result register
    string result_reg = "%result"
    if target_var != "" then
        result_reg = "%temp_result"
    end_if
    
    -- Generate expression code
    code = code + codegen_expression(expr; result_reg; indent)
    
    -- Store to variable if target provided
    if target_var != "" then
        code = code + indent + "; Store to variable: " + target_var + "\n"
        code = code + indent + "store i64 " + result_reg + ", i64* %" + target_var + ", align 8\n"
    end_if
    
    return code
end_function

-- ============================================================================
-- TYPE CONVERSION HELPERS
-- ============================================================================

-- Convert i1 (boolean) to i64 (numeric)
function codegen_bool_to_i64(string bool_reg; string i64_reg; string indent) returns string
    string code = ""
    code = code + indent + "; Convert i1 to i64\n"
    code = code + indent + i64_reg + " = zext i1 " + bool_reg + " to i64\n"
    return code
end_function

-- Convert i64 to i1 (non-zero = true)
function codegen_i64_to_bool(string i64_reg; string bool_reg; string indent) returns string
    string code = ""
    code = code + indent + "; Convert i64 to i1 (non-zero check)\n"
    code = code + indent + bool_reg + " = icmp ne i64 " + i64_reg + ", 0\n"
    return code
end_function

-- ============================================================================
-- STRING COMPARISON (Future Enhancement)
-- ============================================================================

-- Generate string comparison (calls runtime function)
function codegen_string_compare(string left_reg; string right_reg; string result_reg; string op; string indent) returns string
    string code = ""
    code = code + indent + "; String comparison: " + op + "\n"
    code = code + indent + "%strcmp_result = call i32 @strcmp(i8* " + left_reg + ", i8* " + right_reg + ")\n"
    
    -- Convert strcmp result to boolean based on operator
    if op == "==" then
        code = code + indent + result_reg + " = icmp eq i32 %strcmp_result, 0\n"
    end_if
    if op == "!=" then
        code = code + indent + result_reg + " = icmp ne i32 %strcmp_result, 0\n"
    end_if
    if op == "<" then
        code = code + indent + result_reg + " = icmp slt i32 %strcmp_result, 0\n"
    end_if
    if op == ">" then
        code = code + indent + result_reg + " = icmp sgt i32 %strcmp_result, 0\n"
    end_if
    if op == "<=" then
        code = code + indent + result_reg + " = icmp sle i32 %strcmp_result, 0\n"
    end_if
    if op == ">=" then
        code = code + indent + result_reg + " = icmp sge i32 %strcmp_result, 0\n"
    end_if
    
    return code
end_function

-- ============================================================================
-- END OF OPERATORS CODEGEN MODULE
-- ============================================================================
