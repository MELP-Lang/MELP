-- ============================================================================
-- MELP Stage 1 - Functions CodeGen Module
-- ============================================================================
-- YZ_04 - December 18, 2025
-- Purpose: Generate LLVM IR for function declarations, calls, and returns
--
-- Based on: compiler/stage0/modules/functions/functions_codegen.c
-- Uses: compiler/stage1/modules/core/type_mapper.mlp (YZ_03)
--
-- Handles:
-- - Function declarations (define @func)
-- - Function parameters (parameter allocation)
-- - Function calls (call instruction)
-- - Return statements (ret instruction)
--
-- ARCHITECTURE COMPLIANCE:
-- - ✅ Stateless (no mutable globals, const OK)
-- - ✅ Modular (functions feature isolated)
-- - ✅ Uses core utilities (type_mapper for LLVM type conversion)
-- ============================================================================

-- Import core utilities (YZ_03)
import "../core/type_mapper.mlp"

-- ============================================================================
-- CONSTANTS - LLVM Type Mappings
-- ============================================================================

-- LLVM types for function returns/params
const string LLVM_I64 = "i64"
const string LLVM_I8_PTR = "i8*"
const string LLVM_I1 = "i1"
const string LLVM_VOID = "void"

-- ============================================================================
-- HELPER FUNCTIONS - Type Conversion
-- ============================================================================

-- Convert MELP function parameter type to LLVM type
-- STATELESS: Returns LLVM type string
function param_type_to_llvm(numeric param_type) returns string
    -- FUNC_PARAM_NUMERIC = 0
    if param_type == 0 then
        return LLVM_I64
    end_if
    
    -- FUNC_PARAM_TEXT = 1
    if param_type == 1 then
        return LLVM_I8_PTR
    end_if
    
    -- FUNC_PARAM_BOOLEAN = 2
    if param_type == 2 then
        return LLVM_I1
    end_if
    
    -- FUNC_PARAM_LIST = 6 (pointer to array)
    if param_type == 6 then
        return LLVM_I8_PTR
    end_if
    
    -- Default to i64
    return LLVM_I64
end_function

-- Convert MELP function return type to LLVM type
-- STATELESS: Returns LLVM type string
function return_type_to_llvm(numeric return_type) returns string
    -- FUNC_RETURN_NUMERIC = 0
    if return_type == 0 then
        return LLVM_I64
    end_if
    
    -- FUNC_RETURN_TEXT = 1
    if return_type == 1 then
        return LLVM_I8_PTR
    end_if
    
    -- FUNC_RETURN_BOOLEAN = 2
    if return_type == 2 then
        return LLVM_I1
    end_if
    
    -- FUNC_RETURN_VOID = 3
    if return_type == 3 then
        return LLVM_VOID
    end_if
    
    -- Default to void
    return LLVM_VOID
end_function

-- ============================================================================
-- CODE GENERATION FUNCTIONS (STATELESS PATTERN)
-- ============================================================================

-- Generate LLVM IR for function declaration prologue
-- Input: func_name - function name
--        params - list of [type, name] pairs
--        return_type - numeric return type constant
-- Output: string - LLVM IR code
--
-- STATELESS: Pure function, no side effects
function codegen_function_prologue(string func_name, list params, numeric return_type) returns string
    string ir = ""
    
    -- 1. Function signature
    string llvm_return_type = return_type_to_llvm(return_type)
    
    ir = ir + "define " + llvm_return_type + " @" + func_name + "("
    
    -- 2. Parameters
    numeric param_count = 0
    numeric i = 0
    
    -- Count parameters
    while i < 100 do  -- Max 100 params (Stage 0 limitation)
        list param = params[i]
        if param == 0 then
            -- No more params
            i = 100
        else
            param_count = param_count + 1
            i = i + 1
        end_if
    end_while
    
    -- Build parameter list
    i = 0
    while i < param_count do
        list param = params[i]
        numeric param_type = param[0]
        string param_name = param[1]
        
        string llvm_type = param_type_to_llvm(param_type)
        
        if i > 0 then
            ir = ir + ", "
        end_if
        
        ir = ir + llvm_type + " %" + param_name
        i = i + 1
    end_while
    
    ir = ir + ") {\n"
    
    -- 3. Entry label
    ir = ir + "entry:\n"
    
    -- 4. Allocate stack space for parameters (LLVM convention)
    i = 0
    while i < param_count do
        list param = params[i]
        numeric param_type = param[0]
        string param_name = param[1]
        
        string llvm_type = param_type_to_llvm(param_type)
        
        -- Allocate
        ir = ir + "  %" + param_name + ".addr = alloca " + llvm_type + "\n"
        
        -- Store parameter value
        ir = ir + "  store " + llvm_type + " %" + param_name + ", "
        ir = ir + llvm_type + "* %" + param_name + ".addr\n"
        
        i = i + 1
    end_while
    
    return ir
end_function

-- Generate LLVM IR for function declaration epilogue
-- Input: return_type - numeric return type constant
--        return_value - optional return value (0 for void)
-- Output: string - LLVM IR code
--
-- STATELESS: Pure function, no side effects
function codegen_function_epilogue(numeric return_type, string return_value) returns string
    string ir = ""
    
    string llvm_return_type = return_type_to_llvm(return_type)
    
    -- Return statement
    ir = ir + "  ret " + llvm_return_type
    
    if return_type != 3 then  -- Not void
        ir = ir + " " + return_value
    end_if
    
    ir = ir + "\n"
    
    -- Close function
    ir = ir + "}\n"
    
    return ir
end_function

-- Generate LLVM IR for complete function declaration
-- Input: func_decl - [name, params, return_type, body_start, body_end]
--        body_ir - LLVM IR for function body (from statement codegen)
-- Output: string - Complete LLVM IR for function
--
-- STATELESS: Pure function, no side effects
function codegen_function_declaration(list func_decl, string body_ir) returns string
    string func_name = func_decl[0]
    list params = func_decl[1]
    numeric return_type = func_decl[2]
    
    string ir = ""
    
    -- Prologue
    ir = ir + codegen_function_prologue(func_name, params, return_type)
    
    -- Body
    ir = ir + body_ir
    
    -- Epilogue (with default return for now)
    ir = ir + codegen_function_epilogue(return_type, "0")
    
    return ir
end_function

-- Generate LLVM IR for function call
-- Input: func_call - [func_name, args]
--        register_num - current register number for result
-- Output: list [ir_code, next_register]
--         ir_code - LLVM IR for the call
--         next_register - updated register number
--
-- STATELESS: Takes state, returns new state
function codegen_function_call(list func_call, numeric register_num) returns list
    string func_name = func_call[0]
    list args = func_call[1]
    
    string ir = ""
    numeric current_reg = register_num
    
    -- 1. Load/evaluate arguments
    numeric arg_count = 0
    numeric i = 0
    
    -- Count arguments
    while i < 100 do  -- Max 100 args
        list arg = args[i]
        if arg == 0 then
            i = 100
        else
            arg_count = arg_count + 1
            i = i + 1
        end_if
    end_while
    
    -- For now, assume arguments are simple values
    -- Proper expression codegen would be integrated later
    
    -- 2. Generate call instruction
    -- call i64 @func_name(i64 %arg1, i64 %arg2)
    
    string result_reg = "%" + string(current_reg)
    current_reg = current_reg + 1
    
    ir = ir + "  " + result_reg + " = call i64 @" + func_name + "("
    
    i = 0
    while i < arg_count do
        list arg = args[i]
        
        if i > 0 then
            ir = ir + ", "
        end_if
        
        -- Simple value for now (would be expression result register)
        string arg_value = arg[1]
        ir = ir + "i64 " + arg_value
        
        i = i + 1
    end_while
    
    ir = ir + ")\n"
    
    return [ir, current_reg]
end_function

-- Generate LLVM IR for return statement
-- Input: return_stmt - [return_value]
--        return_type - expected return type
-- Output: string - LLVM IR code
--
-- STATELESS: Pure function, no side effects
function codegen_return_statement(list return_stmt, numeric return_type) returns string
    list return_value = return_stmt[0]
    
    string ir = ""
    string llvm_return_type = return_type_to_llvm(return_type)
    
    ir = ir + "  ret " + llvm_return_type
    
    -- Check if void return
    if return_type != 3 then  -- Not void
        -- For now, assume simple value
        string value = return_value[1]
        ir = ir + " " + value
    end_if
    
    ir = ir + "\n"
    
    return ir
end_function

-- Generate parameter load instruction
-- Helper for accessing function parameters in function body
-- Input: param_name - parameter name
--        param_type - parameter type
--        register_num - current register number
-- Output: list [ir_code, next_register]
--
-- STATELESS: Takes state, returns new state
function codegen_param_load(string param_name, numeric param_type, numeric register_num) returns list
    string llvm_type = param_type_to_llvm(param_type)
    
    string result_reg = "%" + string(register_num)
    numeric next_reg = register_num + 1
    
    string ir = "  " + result_reg + " = load " + llvm_type + ", "
    ir = ir + llvm_type + "* %" + param_name + ".addr\n"
    
    return [ir, next_reg]
end_function

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

-- Convert numeric to string (helper)
-- Stage 0 limitation workaround
function string(numeric n) returns string
    if n == 0 then return "0" end_if
    if n == 1 then return "1" end_if
    if n == 2 then return "2" end_if
    if n == 3 then return "3" end_if
    if n == 4 then return "4" end_if
    if n == 5 then return "5" end_if
    if n == 6 then return "6" end_if
    if n == 7 then return "7" end_if
    if n == 8 then return "8" end_if
    if n == 9 then return "9" end_if
    if n == 10 then return "10" end_if
    
    -- For larger numbers, would need proper conversion
    -- This is a temporary helper
    return "N"
end_function

-- ============================================================================
-- END OF MODULE
-- ============================================================================
