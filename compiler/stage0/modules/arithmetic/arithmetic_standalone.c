#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>
#include "../../lexer.h"

// Arithmetic expression structure
typedef struct ArithExpr {
    char target[64];      // Variable to store result: "numeric c"
    char expr_str[256];   // Full expression as string: "a + b * 2"
    struct ArithExpr *next;
} ArithExpr;

static ArithExpr *expr_list = NULL;
static int expr_count = 0;

// Add arithmetic expression to list
static void add_arithmetic_expr(const char *target, const char *expr) {
    ArithExpr *new_expr = malloc(sizeof(ArithExpr));
    strcpy(new_expr->target, target);
    strcpy(new_expr->expr_str, expr);
    new_expr->next = expr_list;
    expr_list = new_expr;
    expr_count++;
}

// Parse arithmetic expressions: numeric c = a + b
static void arithmetic_parse(Lexer *lexer) {
    Token *prev_tokens[10];
    int token_idx = 0;
    
    Token *token = lexer_next_token(lexer);
    
    while (token->type != TOKEN_EOF) {
        // Look for pattern: NUMERIC IDENTIFIER ASSIGN
        if (token_idx >= 2 &&
            prev_tokens[token_idx - 2]->type == TOKEN_NUMERIC &&
            prev_tokens[token_idx - 1]->type == TOKEN_IDENTIFIER &&
            token->type == TOKEN_ASSIGN) {
            
            char target[64];
            sprintf(target, "%s", prev_tokens[token_idx - 1]->value);
            
            // Collect expression tokens
            char expr[256] = "";
            token_free(token);
            token = lexer_next_token(lexer);
            
            bool has_arithmetic = false;
            while (token->type != TOKEN_EOF) {
                // Check if this is an arithmetic operation
                if (token->type == TOKEN_PLUS ||
                    token->type == TOKEN_MINUS ||
                    token->type == TOKEN_MULTIPLY ||
                    token->type == TOKEN_DIVIDE ||
                    token->type == TOKEN_MOD ||
                    token->type == TOKEN_IDENTIFIER ||
                    token->type == TOKEN_NUMBER ||
                    token->type == TOKEN_LPAREN ||
                    token->type == TOKEN_RPAREN) {
                    
                    if (strlen(expr) > 0) strcat(expr, " ");
                    strcat(expr, token->value);
                    
                    if (token->type == TOKEN_PLUS ||
                        token->type == TOKEN_MINUS ||
                        token->type == TOKEN_MULTIPLY ||
                        token->type == TOKEN_DIVIDE ||
                        token->type == TOKEN_MOD) {
                        has_arithmetic = true;
                    }
                    
                    token_free(token);
                    token = lexer_next_token(lexer);
                } else {
                    break;
                }
            }
            
            // Only add if we found arithmetic operators
            if (has_arithmetic) {
                add_arithmetic_expr(target, expr);
                printf("  ‚úì Arithmetic: %s = %s\n", target, expr);
            }
            
            // Reset token buffer
            for (int i = 0; i < token_idx; i++) {
                if (prev_tokens[i]) token_free(prev_tokens[i]);
            }
            token_idx = 0;
            continue;
        }
        
        // Shift token buffer
        if (token_idx >= 10) {
            if (prev_tokens[0]) token_free(prev_tokens[0]);
            for (int i = 0; i < 9; i++) {
                prev_tokens[i] = prev_tokens[i + 1];
            }
            token_idx = 9;
        }
        prev_tokens[token_idx++] = token;
        token = lexer_next_token(lexer);
    }
    
    // Free remaining tokens
    for (int i = 0; i < token_idx; i++) {
        if (prev_tokens[i]) token_free(prev_tokens[i]);
    }
    if (token) token_free(token);
}

// Generate assembly code for arithmetic expressions
static void arithmetic_codegen(FILE *out) {
    if (expr_count == 0) return;
    
    fprintf(out, "; Arithmetic expressions generated by arithmetic module\n");
    fprintf(out, "section .text\n");
    
    ArithExpr *expr = expr_list;
    while (expr != NULL) {
        fprintf(out, "; %s = %s\n", expr->target, expr->expr_str);
        
        // Simple codegen: load operands and perform operation
        char *expr_copy = strdup(expr->expr_str);
        char *token = strtok(expr_copy, " ");
        char operands[10][64];
        char operators[10][8];
        int operand_count = 0;
        int operator_count = 0;
        
        // Parse expression into operands and operators
        while (token != NULL) {
            if (strcmp(token, "+") == 0 || strcmp(token, "-") == 0 ||
                strcmp(token, "*") == 0 || strcmp(token, "/") == 0 ||
                strcmp(token, "%") == 0 || strcmp(token, "mod") == 0) {
                strcpy(operators[operator_count++], token);
            } else if (strcmp(token, "(") != 0 && strcmp(token, ")") != 0) {
                strcpy(operands[operand_count++], token);
            }
            token = strtok(NULL, " ");
        }
        
        // Generate assembly for simple binary operations
        if (operand_count == 2 && operator_count == 1) {
            fprintf(out, "  ; Load first operand\n");
            
            // Check if operand is a number or variable
            if (isdigit(operands[0][0])) {
                fprintf(out, "  mov rax, %s\n", operands[0]);
            } else {
                fprintf(out, "  mov rax, [%s]\n", operands[0]);
            }
            
            fprintf(out, "  ; Load second operand\n");
            if (isdigit(operands[1][0])) {
                fprintf(out, "  mov rbx, %s\n", operands[1]);
            } else {
                fprintf(out, "  mov rbx, [%s]\n", operands[1]);
            }
            
            if (strcmp(operators[0], "+") == 0) {
                fprintf(out, "  add rax, rbx\n");
            } else if (strcmp(operators[0], "-") == 0) {
                fprintf(out, "  sub rax, rbx\n");
            } else if (strcmp(operators[0], "*") == 0) {
                fprintf(out, "  imul rax, rbx\n");
            } else if (strcmp(operators[0], "/") == 0) {
                fprintf(out, "  xor rdx, rdx\n");
                fprintf(out, "  idiv rbx\n");
            } else if (strcmp(operators[0], "%") == 0 || strcmp(operators[0], "mod") == 0) {
                fprintf(out, "  xor rdx, rdx\n");
                fprintf(out, "  idiv rbx\n");
                fprintf(out, "  mov rax, rdx  ; remainder in rdx\n");
            }
            
            fprintf(out, "  ; Store result\n");
            fprintf(out, "  mov [%s], rax\n", expr->target);
        }
        
        fprintf(out, "\n");
        free(expr_copy);
        expr = expr->next;
    }
}

int main(int argc, char **argv) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <input.mlp> <output.s>\n", argv[0]);
        return 1;
    }

    printf("üîß Arithmetic Module\n");
    printf("===================\n");
    printf("Input:  %s\n", argv[1]);
    printf("Output: %s\n\n", argv[2]);

    // Read input file
    FILE *input = fopen(argv[1], "r");
    if (!input) {
        fprintf(stderr, "‚ùå Error: Cannot open input file %s\n", argv[1]);
        return 1;
    }

    fseek(input, 0, SEEK_END);
    long file_size = ftell(input);
    fseek(input, 0, SEEK_SET);

    char *source = malloc(file_size + 1);
    fread(source, 1, file_size, input);
    source[file_size] = '\0';
    fclose(input);

    // Create lexer and parse
    Lexer *lexer = lexer_create(source);
    arithmetic_parse(lexer);
    lexer_free(lexer);

    printf("\n  ‚úì Arithmetic expressions found: %d\n", expr_count);

    // Generate output
    FILE *output = fopen(argv[2], "w");
    if (!output) {
        fprintf(stderr, "‚ùå Error: Cannot create output file %s\n", argv[2]);
        free(source);
        return 1;
    }

    arithmetic_codegen(output);
    fclose(output);
    free(source);

    printf("\n‚úÖ Arithmetic module complete!\n");
    return 0;
}
