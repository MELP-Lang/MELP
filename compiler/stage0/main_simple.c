#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "lexer.h"

int main(int argc, char** argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <input.mlp> <output.s>\n", argv[0]);
        return 1;
    }
    
    printf("=== MLP 26-Module Compiler (Stage 0) ===\n");
    printf("Compiling: %s -> %s\n\n", argv[1], argv[2]);
    
    // Read source file
    FILE* f = fopen(argv[1], "r");
    if (!f) {
        fprintf(stderr, "Error: Cannot open input file '%s'\n", argv[1]);
        return 1;
    }
    
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    char* source = malloc(size + 1);
    fread(source, 1, size, f);
    source[size] = '\0';
    fclose(f);
    
    // Create lexer
    Lexer* lexer = lexer_create(source);
    
    // Open output file
    FILE* out = fopen(argv[2], "w");
    if (!out) {
        fprintf(stderr, "Error: Cannot create output file '%s'\n", argv[2]);
        free(source);
        return 1;
    }
    
    // Write assembly header
    fprintf(out, "; Generated by MLP 26-Module Compiler\n");
    fprintf(out, "; Source: %s\n\n", argv[1]);
    fprintf(out, "global _start\n\n");
    
    // Data section
    fprintf(out, "section .data\n");
    
    // Parse and compile
    printf("Phase 1: Lexical Analysis\n");
    int token_count = 0;
    int string_count = 0;
    Token* token = lexer_next_token(lexer);
    
    while (token && token->type != TOKEN_EOF) {
        token_count++;
        
        // Handle yazdir() statements
        if (token->type == TOKEN_IDENTIFIER && strcmp(token->value, "yazdir") == 0) {
            printf("  Found: yazdir() statement\n");
            token_free(token);
            token = lexer_next_token(lexer);
            
            if (token && token->type == TOKEN_LPAREN) {
                token_free(token);
                token = lexer_next_token(lexer);
                
                // Get the argument
                if (token && token->type == TOKEN_STRING) {
                    string_count++;
                    printf("    String: \"%s\"\n", token->value);
                    
                    // Write string to data section (add quotes for assembly)
                    fprintf(out, "    str_%d db \"%s\", 10\n", string_count, token->value);
                    fprintf(out, "    str_%d_len equ $ - str_%d\n", string_count, string_count);
                }
                
                token_free(token);
                token = lexer_next_token(lexer);
                
                // Skip closing paren
                if (token && token->type == TOKEN_RPAREN) {
                    token_free(token);
                    token = lexer_next_token(lexer);
                }
            }
        } else {
            token_free(token);
            token = lexer_next_token(lexer);
        }
    }
    
    if (token) token_free(token);
    
    printf("\nPhase 2: Code Generation\n");
    printf("  Tokens: %d\n", token_count);
    printf("  Strings: %d\n", string_count);
    
    // Text section
    fprintf(out, "\nsection .text\n");
    fprintf(out, "_start:\n");
    
    // Generate print calls
    for (int i = 1; i <= string_count; i++) {
        fprintf(out, "    ; Print string %d\n", i);
        fprintf(out, "    mov rax, 1\n");
        fprintf(out, "    mov rdi, 1\n");
        fprintf(out, "    lea rsi, [str_%d]\n", i);
        fprintf(out, "    mov rdx, str_%d_len\n", i);
        fprintf(out, "    syscall\n\n");
    }
    
    // Exit
    fprintf(out, "    ; Exit\n");
    fprintf(out, "    mov rax, 60\n");
    fprintf(out, "    xor rdi, rdi\n");
    fprintf(out, "    syscall\n");
    
    printf("\nâœ… Compilation successful!\n");
    printf("   Output: %s\n", argv[2]);
    printf("\nTo assemble and run:\n");
    printf("   nasm -f elf64 %s -o output.o\n", argv[2]);
    printf("   ld output.o -o output\n");
    printf("   ./output\n");
    
    // Cleanup
    fclose(out);
    free(source);
    
    return 0;
}
