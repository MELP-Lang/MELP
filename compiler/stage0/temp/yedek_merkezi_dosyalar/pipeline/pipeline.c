// Pipeline: Compilation orchestration
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../lexer.h"
#include "../parser.h"
#include "../codegen.h"
#include "../modules/arithmetic/arithmetic_parser.h"
#include "../modules/arithmetic/arithmetic_codegen.h"
#include "../modules/variable/variable.h"
#include "pipeline.h"
#include "../error/error_handler.h"

// Compile source file to assembly
CompileResult pipeline_compile(const char* input_path, const char* output_path) {
    CompileResult result = {0};
    
    printf("=== MLP 26-Module Compiler (Stage 0) ===\n");
    printf("Compiling: %s -> %s\n\n", input_path, output_path);
    
    // Read source file
    FILE* f = fopen(input_path, "r");
    if (!f) {
        fprintf(stderr, "Error: Cannot open input file '%s'\n", input_path);
        result.exit_code = 1;
        return result;
    }
    
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    char* source = malloc(size + 1);
    fread(source, 1, size, f);
    source[size] = '\0';
    fclose(f);
    
    // Create lexer
    Lexer* lexer = lexer_create(source);
    
    // Open output file
    FILE* out = fopen(output_path, "w");
    if (!out) {
        fprintf(stderr, "Error: Cannot create output file '%s'\n", output_path);
        free(source);
        result.exit_code = 1;
        return result;
    }
    
    // Write assembly header
    fprintf(out, "; Generated by MLP 26-Module Compiler\n");
    fprintf(out, "; Source: %s\n\n", input_path);
    fprintf(out, "global _start\n\n");
    
    // STO runtime external functions
    fprintf(out, "; STO Runtime functions\n");
    fprintf(out, "extern sto_bigdec_from_int64\n");
    fprintf(out, "extern sto_bigdec_add\n");
    fprintf(out, "extern sto_bigdec_sub\n");
    fprintf(out, "extern sto_bigdec_mul\n");
    fprintf(out, "extern sto_bigdec_div\n\n");
    
    // Track sections
    char data_section[8192] = "";  // For strings
    char bss_section[8192] = "";    // For variables
    char code_section[16384] = "";  // For code (initialization, etc.)
    int data_len = 0;
    int bss_len = 0;
    int code_len = 0;
    
    // Track variables
    int var_count = 0;
    
    // Parse and compile with SMART PARSER + PHASE 2 Variable Support
    printf("Phase 1: Lexical Analysis & Parsing\n");
    printf("Phase 2: Variable Declarations (ACTIVE)\n");
    int token_count = 0;
    int string_count = 0;
    Token* token = lexer_next_token(lexer);
    
    while (token && token->type != TOKEN_EOF) {
        token_count++;
        
        // SMART PARSER: Check for valid top-level constructs
        switch (token->type) {
            // ✅ VALID: print() statement
            case TOKEN_PRINT:
                printf("  ✓ Valid: print() statement\n");
                token_free(token);
                token = lexer_next_token(lexer);
                
                if (!token || token->type != TOKEN_LPAREN) {
                    error_unexpected_token(token, "'(' after print");
                }
                token_free(token);
                token = lexer_next_token(lexer);
                
                // Get the argument
                if (!token || token->type != TOKEN_STRING) {
                    error_unexpected_token(token, "string literal");
                }
                
                string_count++;
                printf("    String: \"%s\"\n", token->value);
                
                // Append to data section buffer
                data_len += sprintf(data_section + data_len,
                    "    str_%d db \"%s\", 10\n"
                    "    str_%d_len equ $ - str_%d\n",
                    string_count, token->value,
                    string_count, string_count);
                
                token_free(token);
                token = lexer_next_token(lexer);
                
                // Expect closing paren
                if (!token || token->type != TOKEN_RPAREN) {
                    error_unexpected_token(token, "')' after string");
                }
                token_free(token);
                token = lexer_next_token(lexer);
                break;
            
            // ✅ VALID: Type keywords (numeric, string, boolean) for variable declarations
            case TOKEN_NUMERIC:
            case TOKEN_STRING_TYPE:
            case TOKEN_BOOLEAN: {
                printf("  ✓ Variable declaration (type: %s)\n", token->value);
                
                // Simple inline parsing
                VarType var_type = VAR_NUMERIC;
                if (token->type == TOKEN_STRING_TYPE) var_type = VAR_STRING;
                else if (token->type == TOKEN_BOOLEAN) var_type = VAR_BOOLEAN;
                
                token_free(token);
                token = lexer_next_token(lexer); // Get identifier
                
                if (!token || token->type != TOKEN_IDENTIFIER) {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected identifier after type keyword\n");
                    exit(1);
                }
                
                char* var_name = strdup(token->value);
                printf("    Variable: %s (type: ", var_name);
                switch(var_type) {
                    case VAR_NUMERIC: printf("numeric"); break;
                    case VAR_STRING: printf("string"); break;
                    case VAR_BOOLEAN: printf("boolean"); break;
                    default: printf("unknown");
                }
                printf(")\n");
                
                token_free(token);
                token = lexer_next_token(lexer); // Get '='
                
                if (!token || token->type != TOKEN_ASSIGN) {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected '=' after variable name\n");
                    free(var_name);
                    exit(1);
                }
                
                // PHASE 3.5: Parse expression for initialization value
                // Create a new lexer from current position for expression parser
                int saved_pos = lexer->pos;
                int saved_line = lexer->line;
                
                // Append to BSS section buffer first (variable declaration)
                if (var_type == VAR_NUMERIC) {
                    bss_len += sprintf(bss_section + bss_len,
                        "    %s resq 1    ; numeric variable\n", var_name);
                } else if (var_type == VAR_STRING) {
                    bss_len += sprintf(bss_section + bss_len,
                        "    %s resb 256  ; string variable\n", var_name);
                } else if (var_type == VAR_BOOLEAN) {
                    bss_len += sprintf(bss_section + bss_len,
                        "    %s resb 1    ; boolean variable\n", var_name);
                }
                
                // For numeric type, try to parse arithmetic expression
                if (var_type == VAR_NUMERIC) {
                    // Put back current token to lexer position
                    lexer->pos = saved_pos;
                    lexer->line = saved_line;
                    token_free(token);
                    
                    // Create arithmetic parser
                    ArithmeticParser* arith_parser = arithmetic_parser_create(lexer);
                    
                    // Parse expression
                    ArithmeticExpr* expr = arithmetic_parse_expression(arith_parser);
                    
                    if (expr) {
                        printf("    Expression parsed successfully\n");
                        
                        // Generate initialization code
                        code_len += sprintf(code_section + code_len,
                            "    ; Initialize %s\n", var_name);
                        
                        // Simple codegen: if literal, just move immediate value
                        if (expr->is_literal && !expr->left && !expr->right) {
                            code_len += sprintf(code_section + code_len,
                                "    mov rax, %s\n", expr->value);
                            code_len += sprintf(code_section + code_len,
                                "    mov [%s], rax\n\n", var_name);
                        } else {
                            // Complex expression - use full codegen
                            FILE* temp_file = tmpfile();
                            arithmetic_generate_code(temp_file, expr);
                            rewind(temp_file);
                            
                            char buffer[1024];
                            while (fgets(buffer, sizeof(buffer), temp_file)) {
                                code_len += sprintf(code_section + code_len, "%s", buffer);
                            }
                            code_len += sprintf(code_section + code_len,
                                "    mov [%s], r8    ; Store result\n\n", var_name);
                            fclose(temp_file);
                        }
                        
                        arithmetic_expr_free(expr);
                    }
                    
                    // Get current token from arithmetic parser
                    token = arith_parser->current_token;
                    arith_parser->current_token = NULL;  // Don't free it
                    arithmetic_parser_free(arith_parser);
                    
                } else {
                    // For string/boolean, simple parsing for now
                    token_free(token);
                    token = lexer_next_token(lexer);
                    
                    if (token && (token->type == TOKEN_STRING || 
                                  token->type == TOKEN_TRUE || 
                                  token->type == TOKEN_FALSE)) {
                        printf("    Value: %s\n", token->value ? token->value : "(none)");
                        // TODO: Generate initialization code for string/boolean
                        token_free(token);
                        token = lexer_next_token(lexer);
                    } else {
                        fprintf(stderr, "\n❌ SYNTAX ERROR: Expected value after '='\n");
                        free(var_name);
                        exit(1);
                    }
                }
                
                var_count++;
                
                free(var_name);
                continue;
            }
            
            // ✅ VALID: Control flow - if statement
            case TOKEN_IF: {
                printf("  ✓ If statement\n");
                
                token_free(token);
                token = lexer_next_token(lexer); // Get condition
                
                // Simple condition parsing: identifier or boolean
                char* condition = NULL;
                if (token && (token->type == TOKEN_IDENTIFIER || 
                              token->type == TOKEN_TRUE || 
                              token->type == TOKEN_FALSE)) {
                    condition = strdup(token->value);
                    printf("    Condition: %s\n", condition);
                    token_free(token);
                    token = lexer_next_token(lexer);
                } else {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected condition after 'if'\n");
                    exit(1);
                }
                
                // Expect 'then'
                if (!token || token->type != TOKEN_THEN) {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected 'then' after condition\n");
                    free(condition);
                    exit(1);
                }
                printf("    Then block:\n");
                
                token_free(token);
                token = lexer_next_token(lexer);
                
                // Parse then block (simple: just print statements for now)
                while (token && token->type != TOKEN_END && 
                       token->type != TOKEN_ELSE && token->type != TOKEN_EOF) {
                    
                    if (token->type == TOKEN_PRINT) {
                        printf("      - print()\n");
                        token_free(token);
                        token = lexer_next_token(lexer); // '('
                        if (token) token_free(token);
                        token = lexer_next_token(lexer); // string
                        if (token && token->type == TOKEN_STRING) {
                            string_count++;
                            data_len += sprintf(data_section + data_len,
                                "    str_%d db \"%s\", 10\n"
                                "    str_%d_len equ $ - str_%d\n",
                                string_count, token->value,
                                string_count, string_count);
                        }
                        if (token) token_free(token);
                        token = lexer_next_token(lexer); // ')'
                        if (token) token_free(token);
                        token = lexer_next_token(lexer);
                    } else {
                        token_free(token);
                        token = lexer_next_token(lexer);
                    }
                }
                
                // Check for else
                if (token && token->type == TOKEN_ELSE) {
                    printf("    Else block:\n");
                    token_free(token);
                    token = lexer_next_token(lexer);
                    
                    while (token && token->type != TOKEN_END && token->type != TOKEN_EOF) {
                        if (token->type == TOKEN_PRINT) {
                            printf("      - print()\n");
                            token_free(token);
                            token = lexer_next_token(lexer); // '('
                            if (token) token_free(token);
                            token = lexer_next_token(lexer); // string
                            if (token && token->type == TOKEN_STRING) {
                                string_count++;
                                data_len += sprintf(data_section + data_len,
                                    "    str_%d db \"%s\", 10\n"
                                    "    str_%d_len equ $ - str_%d\n",
                                    string_count, token->value,
                                    string_count, string_count);
                            }
                            if (token) token_free(token);
                            token = lexer_next_token(lexer); // ')'
                            if (token) token_free(token);
                            token = lexer_next_token(lexer);
                        } else {
                            token_free(token);
                            token = lexer_next_token(lexer);
                        }
                    }
                }
                
                // Expect 'end'
                if (!token || token->type != TOKEN_END) {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected 'end' to close if statement\n");
                    free(condition);
                    exit(1);
                }
                
                free(condition);
                token_free(token);
                token = lexer_next_token(lexer);
                continue;
            }
            
            // ✅ VALID: Control flow - while loop
            case TOKEN_WHILE: {
                printf("  ✓ While loop\n");
                
                token_free(token);
                token = lexer_next_token(lexer); // Get condition
                
                char* condition = NULL;
                if (token && (token->type == TOKEN_IDENTIFIER || 
                              token->type == TOKEN_TRUE || 
                              token->type == TOKEN_FALSE)) {
                    condition = strdup(token->value);
                    printf("    Condition: %s\n", condition);
                    token_free(token);
                    token = lexer_next_token(lexer);
                } else {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected condition after 'while'\n");
                    exit(1);
                }
                
                // Expect 'do'
                if (!token || token->type != TOKEN_DO) {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected 'do' after condition\n");
                    free(condition);
                    exit(1);
                }
                printf("    Do block:\n");
                
                token_free(token);
                token = lexer_next_token(lexer);
                
                // Parse do block
                while (token && token->type != TOKEN_END && token->type != TOKEN_EOF) {
                    if (token->type == TOKEN_PRINT) {
                        printf("      - print()\n");
                        token_free(token);
                        token = lexer_next_token(lexer); // '('
                        if (token) token_free(token);
                        token = lexer_next_token(lexer); // string
                        if (token && token->type == TOKEN_STRING) {
                            string_count++;
                            data_len += sprintf(data_section + data_len,
                                "    str_%d db \"%s\", 10\n"
                                "    str_%d_len equ $ - str_%d\n",
                                string_count, token->value,
                                string_count, string_count);
                        }
                        if (token) token_free(token);
                        token = lexer_next_token(lexer); // ')'
                        if (token) token_free(token);
                        token = lexer_next_token(lexer);
                    } else {
                        token_free(token);
                        token = lexer_next_token(lexer);
                    }
                }
                
                // Expect 'end'
                if (!token || token->type != TOKEN_END) {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected 'end' to close while loop\n");
                    free(condition);
                    exit(1);
                }
                
                free(condition);
                token_free(token);
                token = lexer_next_token(lexer);
                continue;
            }
            
            // ✅ VALID: Control flow - for loop
            case TOKEN_FOR: {
                printf("  ✓ For loop\n");
                
                token_free(token);
                token = lexer_next_token(lexer); // Get iterator
                
                char* iterator = NULL;
                if (token && token->type == TOKEN_IDENTIFIER) {
                    iterator = strdup(token->value);
                    printf("    Iterator: %s\n", iterator);
                    token_free(token);
                    token = lexer_next_token(lexer);
                } else {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected identifier after 'for'\n");
                    exit(1);
                }
                
                // Expect '='
                if (!token || token->type != TOKEN_ASSIGN) {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected '=' after iterator\n");
                    free(iterator);
                    exit(1);
                }
                
                token_free(token);
                token = lexer_next_token(lexer); // Get start value
                
                char* start_val = NULL;
                if (token && (token->type == TOKEN_NUMBER || token->type == TOKEN_IDENTIFIER)) {
                    start_val = strdup(token->value);
                    token_free(token);
                    token = lexer_next_token(lexer);
                } else {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected start value\n");
                    free(iterator);
                    exit(1);
                }
                
                // Expect 'to'
                if (!token || token->type != TOKEN_TO) {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected 'to' in for loop\n");
                    free(iterator);
                    free(start_val);
                    exit(1);
                }
                
                token_free(token);
                token = lexer_next_token(lexer); // Get end value
                
                char* end_val = NULL;
                if (token && (token->type == TOKEN_NUMBER || token->type == TOKEN_IDENTIFIER)) {
                    end_val = strdup(token->value);
                    printf("    Range: %s to %s\n", start_val, end_val);
                    token_free(token);
                    token = lexer_next_token(lexer);
                } else {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected end value\n");
                    free(iterator);
                    free(start_val);
                    exit(1);
                }
                
                printf("    Do block:\n");
                
                // Parse do block
                while (token && token->type != TOKEN_END && token->type != TOKEN_EOF) {
                    if (token->type == TOKEN_PRINT) {
                        printf("      - print()\n");
                        token_free(token);
                        token = lexer_next_token(lexer); // '('
                        if (token) token_free(token);
                        token = lexer_next_token(lexer); // string
                        if (token && token->type == TOKEN_STRING) {
                            string_count++;
                            data_len += sprintf(data_section + data_len,
                                "    str_%d db \"%s\", 10\n"
                                "    str_%d_len equ $ - str_%d\n",
                                string_count, token->value,
                                string_count, string_count);
                        }
                        if (token) token_free(token);
                        token = lexer_next_token(lexer); // ')'
                        if (token) token_free(token);
                        token = lexer_next_token(lexer);
                    } else {
                        token_free(token);
                        token = lexer_next_token(lexer);
                    }
                }
                
                // Expect 'end'
                if (!token || token->type != TOKEN_END) {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected 'end' to close for loop\n");
                    free(iterator);
                    free(start_val);
                    free(end_val);
                    exit(1);
                }
                
                free(iterator);
                free(start_val);
                free(end_val);
                token_free(token);
                token = lexer_next_token(lexer);
                continue;
            }
            
            // ✅ VALID: Exit statements (exit for, exit while, exit if, exit function)
            case TOKEN_EXIT: {
                printf("  ✓ Exit statement\n");
                
                token_free(token);
                token = lexer_next_token(lexer); // Get exit type
                
                if (!token) {
                    fprintf(stderr, "\n❌ SYNTAX ERROR: Expected keyword after 'exit'\n");
                    exit(1);
                }
                
                // Determine exit type
                const char* exit_type = "unknown";
                switch(token->type) {
                    case TOKEN_FOR:
                        exit_type = "for";
                        printf("    Type: exit for (break from loop)\n");
                        break;
                    case TOKEN_WHILE:
                        exit_type = "while";
                        printf("    Type: exit while (break from loop)\n");
                        break;
                    case TOKEN_IF:
                        exit_type = "if";
                        printf("    Type: exit if (guard clause)\n");
                        break;
                    case TOKEN_FUNCTION:
                        exit_type = "function";
                        printf("    Type: exit function (early return)\n");
                        break;
                    default:
                        fprintf(stderr, "\n❌ SYNTAX ERROR: Invalid exit target\n");
                        fprintf(stderr, "   Expected: for, while, if, or function\n");
                        fprintf(stderr, "   Got: %s\n", token->value ? token->value : "(unknown)");
                        exit(1);
                }
                
                // Note: Code generation for exit will be in Phase 3.5
                // For now, just parse and validate syntax
                
                token_free(token);
                token = lexer_next_token(lexer);
                continue;
            }
            
            // ✅ VALID: Identifiers (for future: variables, functions)
            case TOKEN_IDENTIFIER:
            
            // ❌ INVALID: Arithmetic operators
            case TOKEN_DIVIDE:
            case TOKEN_PLUS:
            case TOKEN_MINUS:
            case TOKEN_MULTIPLY:
            case TOKEN_MOD:
            case TOKEN_POWER:
                error_unexpected_operator(token);
                break;
            
            // ❌ INVALID: Comparison operators
            case TOKEN_EQUAL:
            case TOKEN_NOT_EQUAL:
            case TOKEN_LESS:
            case TOKEN_GREATER:
            case TOKEN_LESS_EQUAL:
            case TOKEN_GREATER_EQUAL:
                error_unexpected_operator(token);
                break;
            
            // ❌ INVALID: Logical operators
            case TOKEN_AND:
            case TOKEN_OR:
            case TOKEN_NOT:
                error_unexpected_operator(token);
                break;
            
            // ❌ INVALID: Number literals
            case TOKEN_NUMBER:
                error_unexpected_literal(token, "number");
                break;
            
            // ❌ INVALID: String literals (not in function call)
            case TOKEN_STRING:
                error_unexpected_literal(token, "string");
                break;
            
            // ❌ INVALID: Other tokens
            case TOKEN_LPAREN:
            case TOKEN_RPAREN:
            case TOKEN_COMMA:
            case TOKEN_SEMICOLON:
            case TOKEN_COLON:
            case TOKEN_DOT:
                error_unexpected_token(token, "statement");
                break;
            
            // ❌ ERROR token from lexer
            case TOKEN_ERROR:
                fprintf(stderr, "\n❌ LEXER ERROR at line %d:\n", token->line);
                if (token->value) {
                    fprintf(stderr, "   %s\n", token->value);
                } else {
                    fprintf(stderr, "   Unknown error\n");
                }
                exit(1);
                break;
            
            // ❌ Unknown token
            default:
                error_invalid_statement(token);
                break;
        }
    }
    
    if (token) token_free(token);
    
    printf("\n=== Phase 2 Summary ===\n");
    printf("  Tokens processed: %d\n", token_count);
    printf("  Variables declared: %d\n", var_count);
    printf("  Strings: %d\n", string_count);
    
    printf("\nPhase 3: Code Generation\n");
    
    // Write data section
    fprintf(out, "section .data\n");
    if (data_len > 0) {
        fprintf(out, "%s", data_section);
    }
    
    // Write BSS section
    if (bss_len > 0) {
        fprintf(out, "\nsection .bss\n");
        fprintf(out, "%s", bss_section);
    }
    
    // Text section
    fprintf(out, "\nsection .text\n");
    fprintf(out, "_start:\n");
    
    // Write initialization code first
    if (code_len > 0) {
        fprintf(out, "    ; Variable initialization\n");
        fprintf(out, "%s", code_section);
    }
    
    // Generate print calls
    for (int i = 1; i <= string_count; i++) {
        fprintf(out, "    ; Print string %d\n", i);
        fprintf(out, "    mov rax, 1\n");
        fprintf(out, "    mov rdi, 1\n");
        fprintf(out, "    lea rsi, [str_%d]\n", i);
        fprintf(out, "    mov rdx, str_%d_len\n", i);
        fprintf(out, "    syscall\n\n");
    }
    
    // Exit
    fprintf(out, "    ; Exit\n");
    fprintf(out, "    mov rax, 60\n");
    fprintf(out, "    xor rdi, rdi\n");
    fprintf(out, "    syscall\n");
    
    printf("\n✅ Compilation successful!\n");
    printf("   Output: %s\n", output_path);
    printf("\nTo assemble and run:\n");
    printf("   nasm -f elf64 %s -o output.o\n", output_path);
    printf("   ld output.o -o output\n");
    printf("   ./output\n");
    
    // Cleanup
    fclose(out);
    free(source);
    
    result.exit_code = 0;
    return result;
}
