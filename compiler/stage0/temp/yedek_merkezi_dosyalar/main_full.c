#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "lexer.h"

// Core Parser Modules
#include "modules/parser_core/parser_core.h"
#include "modules/expression/expression.h"
#include "modules/statement/statement.h"
#include "modules/comments/comments.h"

// Type System & Variables
#include "modules/type_system/type_system.h"
#include "modules/variable/variable.h"
#include "modules/variable/variable_parser.h"
#include "modules/variable/variable_codegen.h"

// Operators
#include "modules/arithmetic/arithmetic.h"
#include "modules/arithmetic/arithmetic_parser.h"
#include "modules/arithmetic/arithmetic_codegen.h"
#include "modules/comparison/comparison.h"
#include "modules/logical/logical.h"
#include "modules/bitwise_operations/bitwise_operations.h"

// Control Flow
#include "modules/control_flow/control_flow.h"

// Data Structures
#include "modules/array/array.h"
#include "modules/string_operations/string_operations.h"
#include "modules/struct/struct.h"

// Functions
#include "modules/functions/functions.h"
#include "modules/lambda/lambda.h"

// I/O
#include "modules/print/print.h"
#include "modules/print/print_parser.h"
#include "modules/print/print_codegen.h"
#include "modules/file_io/file_io.h"

// Memory & Safety
#include "modules/memory/memory.h"
#include "modules/null_safety/null_safety.h"

// Code Generation
#include "modules/codegen_context/codegen_context.h"
#include "modules/optimization_pass/optimization_pass.h"

// STO Runtime
#include "modules/runtime_sto/runtime_sto.h"

// Extra Features
#include "modules/async/async.h"
#include "modules/debug/debug_features.h"

int main(int argc, char** argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <input.mlp> <output.s>\n", argv[0]);
        return 1;
    }
    
    printf("=== MLP 26-Module Compiler (Stage 0) ===\n");
    printf("Compiling: %s -> %s\n\n", argv[1], argv[2]);
    
    // Initialize runtime (if needed)
    // sto_runtime_init();
    
    // Read source file
    FILE* f = fopen(argv[1], "r");
    if (!f) {
        fprintf(stderr, "Error: Cannot open input file '%s'\n", argv[1]);
        return 1;
    }
    
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    char* source = malloc(size + 1);
    fread(source, 1, size, f);
    source[size] = '\0';
    fclose(f);
    
    // Create lexer
    Lexer* lexer = lexer_create(source);
    
    // Open output file
    FILE* out = fopen(argv[2], "w");
    if (!out) {
        fprintf(stderr, "Error: Cannot create output file '%s'\n", argv[2]);
        free(source);
        return 1;
    }
    
    // Write assembly header
    fprintf(out, "; Generated by MLP 26-Module Compiler\n");
    fprintf(out, "; Date: 6 Aralık 2025\n");
    fprintf(out, "; Source: %s\n", argv[1]);
    fprintf(out, "global _start\n\n");
    fprintf(out, "section .data\n");
    fprintf(out, "    newline db 10\n");
    fprintf(out, "    space db 32\n\n");
    
    // Parse and compile
    printf("Phase 1: Lexical Analysis\n");
    int token_count = 0;
    Token* token = lexer_next_token(lexer);
    
    while (token && token->type != TOKEN_EOF) {
        token_count++;
        
        // Handle different token types
        switch (token->type) {
            case TOKEN_IDENTIFIER:
                // Check for keywords
                if (strcmp(token->value, "yazdir") == 0) {
                    // Print statement
                    printf("  Found: yazdir() statement\n");
                    token_free(token);
                    token = lexer_next_token(lexer);
                    
                    if (token && token->type == TOKEN_LPAREN) {
                        token_free(token);
                        token = lexer_next_token(lexer);
                        
                        // Get the argument
                        if (token && token->type == TOKEN_STRING) {
                            printf("    Argument: \"%s\"\n", token->value);
                            
                            // Generate print code
                            fprintf(out, "section .data\n");
                            fprintf(out, "    str_%d db %s, 10\n", token_count, token->value);
                            fprintf(out, "    str_%d_len equ $ - str_%d\n\n", token_count, token_count);
                            
                            fprintf(out, "section .text\n");
                            fprintf(out, "_start:\n");
                            fprintf(out, "    ; Print string\n");
                            fprintf(out, "    mov rax, 1          ; sys_write\n");
                            fprintf(out, "    mov rdi, 1          ; stdout\n");
                            fprintf(out, "    lea rsi, [str_%d]   ; string address\n", token_count);
                            fprintf(out, "    mov rdx, str_%d_len ; length\n", token_count);
                            fprintf(out, "    syscall\n\n");
                        }
                    }
                } else if (strcmp(token->value, "sayi") == 0) {
                    // Variable declaration
                    printf("  Found: variable declaration (sayi)\n");
                }
                break;
                
            case TOKEN_STRING:
                printf("  String literal: \"%s\"\n", token->value);
                break;
                
            case TOKEN_NUMBER:
                printf("  Number: %s\n", token->value);
                break;
                
            default:
                break;
        }
        
        token_free(token);
        token = lexer_next_token(lexer);
    }
    
    if (token) token_free(token);
    
    printf("\nPhase 2: Code Generation\n");
    printf("  Tokens processed: %d\n", token_count);
    
    // Write program exit
    fprintf(out, "    ; Exit program\n");
    fprintf(out, "    mov rax, 60     ; sys_exit\n");
    fprintf(out, "    xor rdi, rdi    ; status 0\n");
    fprintf(out, "    syscall\n");
    
    printf("\n✅ Compilation successful!\n");
    printf("   Output: %s\n", argv[2]);
    
    // Cleanup
    fclose(out);
    free(source);
    // sto_runtime_cleanup();
    
    return 0;
}
